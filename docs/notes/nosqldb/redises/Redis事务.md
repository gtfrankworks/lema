---
title: Redis事务
createTime: 2025/08/26 13:14:50
permalink: /nosqldb/fw6n7ai8/
---
## 一、什么是Redis事务

Redis事务是指**一次性执行多个命令的操作集合**，保证命令按照顺序依次执行，中间不会被其他客户端的命令插入打断，但与传统数据库事务相比，Redis事务不支持回滚（部分失败时不会自动回滚）。

Redis事务的特点：

1. **原子性**：事务中的命令会按顺序依次执行，中间不会被其他客户端的命令打断。
2. **隔离性**：事务执行期间，其他客户端不会看到事务中的部分执行结果。
3. **缺少回滚机制**：Redis事务中命令执行失败不会回滚已执行的命令。
4. **乐观锁机制可选**：通过 `WATCH` 命令实现乐观锁，防止数据被其他客户端修改。


Redis事务 VS 数据库事务：

- 单独的隔离操作：Redis的事务仅仅是保证事务里的操作会被连续独占的执行，redis命令执行是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的。
- 没有隔离级别的概念：因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到“这种问题了。
- 不保证原子性：Redis的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力
- 排他性：Redis会保证一个事务内的命令依次执行，而不会被其他命令插入
## 二、事务命令概览

Redis提供以下事务相关命令：

| 命令      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| `MULTI`   | 开启一个事务块，后续命令会进入事务队列                       |
| `EXEC`    | 执行事务队列中的所有命令                                     |
| `DISCARD` | 取消事务，清空事务队列                                       |
| `WATCH`   | 监视一个或多个 key，如果 key 在事务执行前被修改，则事务被打断 |
| `UNWATCH` | 取消对 key 的监视                                            |

------

## 三、事务使用流程

Redis事务执行流程可以分为以下几步：

1. **开启事务**

   ```
   MULTI
   ```

   开启事务后，Redis会把后续命令放入事务队列，而不立即执行。

2. **加入事务命令**

   ```
   SET key1 value1
   INCR key2
   LPUSH list1 item1
   ```

   这些命令被加入事务队列，并不会立即执行。

3. **执行事务**

   ```
   EXEC
   ```

   Redis会按顺序执行事务队列中的所有命令。如果事务中有命令语法错误，Redis会在执行时返回错误，但**已正确的命令仍会执行**。

4. **取消事务**

   ```
   DISCARD
   ```

   如果在 `EXEC` 之前调用 `DISCARD`，事务队列将被清空，不执行任何命令。

5. **使用 WATCH**

   ```
   WATCH key1 key2
   MULTI
   SET key1 value
   EXEC
   ```

   - `WATCH` 会监视 key1 和 key2，如果在 `EXEC` 执行前这两个 key 被其他客户端修改，事务会被取消（返回 null）。
   - `UNWATCH` 可以取消监控。

------

## 四、事务示例

### 1. 基本事务示例

```
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET user:1:name "Alice"
QUEUED
127.0.0.1:6379> INCR user:1:score
QUEUED
127.0.0.1:6379> EXEC
1) OK
2) (integer) 1
```

说明：

- `MULTI` 后进入事务队列
- `QUEUED` 表示命令已排队
- `EXEC` 执行所有命令

### 2. DISCARD 取消事务

```
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> SET user:2:name "Bob"
QUEUED
127.0.0.1:6379> DISCARD
OK
```

说明：

- 队列中的命令被清空，没有执行

### 3. 使用 WATCH 实现乐观锁

```
127.0.0.1:6379> WATCH stock:product1
OK
127.0.0.1:6379> GET stock:product1
"10"
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> DECR stock:product1
QUEUED
127.0.0.1:6379> EXEC
1) (integer) 9
```

说明：

- 如果在 `EXEC` 前其他客户端修改了 `stock:product1`，事务会失败，返回 `null`

------

## 五、Redis事务的实现机制

1. **命令排队**
   - `MULTI` 后，所有命令不会立即执行，而是加入事务队列。
2. **原子执行**
   - `EXEC` 时，Redis会按顺序执行队列中所有命令。
3. **乐观锁 WATCH**
   - Redis不会阻塞其他客户端，使用乐观锁保证事务的一致性。
4. **无自动回滚**
   - 事务执行中单个命令错误不会回滚其他命令。

------

## 六、事务使用注意事项

1. **Redis事务不是严格的ACID**
   - Redis事务缺少自动回滚
   - 并发写冲突需要 `WATCH` 手动处理
2. **事务中命令错误**
   - 语法错误会在 `EXEC` 时返回错误
   - 逻辑错误（如对非数字 key 使用 `INCR`）会导致该命令失败，但其他命令仍执行
3. **事务队列中不要执行耗时命令**
   - 事务中命令执行是阻塞的，耗时命令会影响其他客户端
4. **WATCH 仅监控事务开始前**
   - 监控 key 在 `EXEC` 执行前发生变化就会导致事务失败

------

## 七、事务与管道（Pipeline）的区别

| 特性     | 事务                           | 管道                           |
| -------- | ------------------------------ | ------------------------------ |
| 原子性   | 是（命令按顺序执行，不被打断） | 否（只提高网络性能）           |
| 错误处理 | 无回滚机制                     | 无回滚机制                     |
| 执行方式 | 一次性执行事务队列             | 批量发送命令，但服务器逐条执行 |
| 使用场景 | 保证命令原子性                 | 提高批量命令性能               |

------

## 八、Redis事务最佳实践

1. 使用事务修改同一组相关 key，保证操作原子性。
2. 结合 `WATCH` 实现乐观锁，防止并发写冲突。
3. 避免在事务中执行耗时命令，如 `KEYS *`。
4. 将事务与 Lua 脚本结合，可以实现更强的原子性和逻辑复杂操作。

------

## 九、Lua脚本替代事务

- Lua脚本可以一次性执行多条命令，且保证原子性。
- 优点：
  - 可以实现复杂业务逻辑
  - 避免 `WATCH` 的乐观锁复杂性
- 示例：

```
EVAL "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end" 1 lock_key 1
```