---
title: 创建型模式
createTime: 2025/08/27 17:27:33
permalink: /design/创建型模式/gx5waz12/
---
## 一、创建型模式

### 1.工厂方法模式

> 工厂方法模式是一种创建型设计模式，它提供了一种将对象的实例化过程封装在工厂类中的方式。在工厂方法模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

#### 1.1.简单工厂模式

简单工厂模式是一种创建型设计模式，它提供了一种将对象的实例化过程封装在工厂类中的方式。在简单工厂模式中，一个工厂类负责创建所有产品的实例。

例如，假设我们有一个抽象产品类`Animal`和两个具体产品类`Dog`和`Cat`：

```java
public abstract class Animal {
    public abstract void speak();
}

public class Dog extends Animal {
    @Override
    public void speak() {
        System.out.println("汪汪汪");
    }
}

public class Cat extends Animal {
    @Override
    public void speak() {
        System.out.println("喵喵喵");
    }
}
```

我们可以创建一个简单工厂类`AnimalFactory`来创建`Dog`和`Cat`对象：

```java
public class AnimalFactory {
    public static Animal createAnimal(String type) {
        if (type == null) {
            return null;
        } else if (type.equalsIgnoreCase("DOG")) {
            return new Dog();
        } else if (type.equalsIgnoreCase("CAT")) {
            return new Cat();
        }
        return null;
    }
}    
```

使用简单工厂模式创建对象的示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        Animal dog = AnimalFactory.createAnimal("DOG");
        dog.speak(); // 输出：汪汪汪

        Animal cat = AnimalFactory.createAnimal("CAT");
        cat.speak(); // 输出：喵喵喵
    }
}
```

#### 1.2.工厂方法模式

工厂方法模式是在简单工厂模式的基础上进行的改进，它将工厂这个概念抽象出来成为接口，然后针对每种目标实现类创建一个工厂实现，一对一来实现。当新增了目标实现，只要同时新增一个工厂实现即可。

在上面的例子中，我们可以将`AnimalFactory`改为接口：

```java
public interface AnimalFactory {
    Animal createAnimal();
}
```

然后创建两个具体的工厂实现类`DogFactory`和`CatFactory`：

```java
public class DogFactory implements AnimalFactory {
    @Override
    public Animal createAnimal() {
        return new Dog();
    }
}

public class CatFactory implements AnimalFactory {
    @Override
    public Animal createAnimal() {
        return new Cat();
    }
} 
```

使用工厂方法模式创建对象的示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        AnimalFactory factory = new DogFactory();
        Animal dog = factory.createAnimal();
        dog.speak(); // 输出：汪汪汪

        factory = new CatFactory();
        Animal cat = factory.createAnimal();
        cat.speak(); // 输出：喵喵喵
    }
}
```

### 2.抽象工厂模式

抽象工厂模式是一种创建型设计模式，它提供了一种将一组具有同一主题的单独工厂封装起来的方式。在抽象工厂模式中，每个工厂都能生产一组相关的产品，例如`Car`和`Bike`。

在上面的例子中，我们可以将`AnimalFactory`改为接口，并添加一个`Product`抽象类：

```java
public interface AnimalFactory {
    Product createProduct();
}

public abstract class Product {
    public abstract void use();
}

```

然后创建两个具体的产品实现类`Dog`和`Cat`：

```java
public class Dog extends Product {
    @Override
    public void use() {
        System.out.println("狗可以用爪子抓东西");
    }
}

public class Cat extends Product {
    @Override
    public void use() {
        System.out.println("猫可以用爪子抓老鼠");
    }
}

```

创建两个具体的工厂实现类`DogFactory`和`CatFactory`：

```java
public class DogFactory implements AnimalFactory {
    @Override
    public Product createProduct() {
        return new Dog();
    }
}

public class CatFactory implements AnimalFactory {
    @Override
    public Product createProduct() {
        return new Cat();
    }
}

```

使用抽象工厂模式创建对象的示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        AnimalFactory dogFactory = new DogFactory();
        Product product = dogFactory.createProduct();
        product.use(); // 输出：狗可以用爪子抓东西

        AnimalFactory catFactory = new CatFactory();
        Product product2 = catFactory.createProduct();
        product2.use(); // 输出：猫可以用爪子抓老鼠
    }
}
```

### 3.建造者模式

建造者模式是一种创建型设计模式，它提供了一种创建对象的最佳方式。这种模式通常用于创建具有多个属性和依赖关系的对象，这些对象不能通过单个构造函数实例化。建造者模式将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。

在Java中，建造者模式通常由以下几个部分组成：

1. **抽象建造者类**：这是一个接口或抽象类，它定义了创建产品的步骤和属性。
2. **具体建造者类**：这是一个实现了抽象建造者类的类，它提供了创建产品的实现。
3. **指挥者类**：这是一个接口或抽象类，它定义了指挥者如何创建产品。
4. **具体指挥者类**：这是一个实现了指挥者接口的类，它提供了指挥者如何创建产品的实现。

建造者模式可以帮助您避免在代码中硬编码复杂对象的创建过程，从而使代码更加灵活和可维护。此外，它还可以使您的代码更加易于测试和维护，因为它将创建过程与表示分离开来。

```java
// 产品类
class Car {
    private String brand;
    private String model;
    private int year;

    public Car(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }

    public String getBrand() {
        return brand;
    }

    public String getModel() {
        return model;
    }

    public int getYear() {
        return year;
    }
}

// 抽象建造者类
abstract class Builder {
    protected Car car = new Car("", "", 0);

    public abstract void buildPartA();
    public abstract void buildPartB();
    public abstract void buildPartC();
    public abstract Car getResult();
}

// 具体建造者类
class ConcreteBuilder extends Builder {
    @Override
    public void buildPartA() {
        car.setBrand("Toyota");
    }

    @Override
    public void buildPartB() {
        car.setModel("Corolla");
    }

    @Override
    public void buildPartC() {
        car.setYear(2020);
    }

    @Override
    public Car getResult() {
        return car;
    }
}

// 指挥者类
class Director {
    public void construct(Builder builder) {
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
    }
}

// 客户端代码
public class BuilderPatternDemo {
    public static void main(String[] args) {
        Director director = new Director();
        Builder builder = new ConcreteBuilder();
        director.construct(builder);
        Car car = builder.getResult();
        System.out.println("品牌：" + car.getBrand());
        System.out.println("型号：" + car.getModel());
        System.out.println("年份：" + car.getYear());
    }
}

```

### 4.原型模式

原型模式是一种创建型设计模式，它通过复制一个原型对象来创建新的对象。原型模式有两种实现方式：浅克隆和深克隆。浅克隆只复制基本类型，不复制引用类型；深克隆即复制基本类型，也复制引用类型。在Java中可以直接使用Object提供的进行浅克隆，但是必须实现一个标识接口Cloneable。原型管理器用于存储和调取原型对象。

在原型模式中，抽象原型类是所有具体原型类的父类，它定义了一个指向它的克隆方法。具体原型类则实现了抽象原型类中的克隆方法，它们之间可以相互转换。

原型模式的优点包括：

1. **避免不必要的重新创建**：当需要创建一个与现有对象相似的对象时，可以通过复制现有对象来创建新对象，避免了重新创建对象的开销。
2. **减少代码复杂度**：通过使用原型模式，可以将对象的创建逻辑封装在原型对象中，降低了代码的复杂度。
3. **提高性能**：由于是通过复制现有对象来创建新对象，因此可以减少对象的创建和销毁次数，从而提高程序的性能。

原型模式的缺点包括：

1. **破坏封装性**：由于原型模式需要访问对象的私有成员变量，因此可能会破坏对象的封装性。
2. **深度复制问题**：如果原型对象包含其他对象，而这些对象也需要进行深度复制，则可能会出现复制不完全的问题。

```java
// 抽象原型类
public abstract class Prototype implements Cloneable {
    private String name;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    // 克隆方法
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

// 具体原型类A
public class ConcretePrototypeA extends Prototype {
    private String fieldA;

    public void setFieldA(String fieldA) {
        this.fieldA = fieldA;
    }

    public String getFieldA() {
        return fieldA;
    }
}

// 具体原型类B
public class ConcretePrototypeB extends Prototype {
    private String fieldB;

    public void setFieldB(String fieldB) {
        this.fieldB = fieldB;
    }

    public String getFieldB() {
        return fieldB;
    }
}

// 原型管理器
public class PrototypeManager {
    private Map<String, Prototype> prototypes = new HashMap<>();

    public void addPrototype(String key, Prototype prototype) {
        prototypes.put(key, prototype);
    }

    public Prototype getPrototype(String key) {
        return prototypes.get(key);
    }
}

// 客户端代码
public class Client {
    public static void main(String[] args) throws CloneNotSupportedException {
        // 创建原型对象
        Prototype prototypeA = new ConcretePrototypeA();
        prototypeA.setName("Prototype A");
        prototypeA.setFieldA("Field A");
        Prototype prototypeB = new ConcretePrototypeB();
        prototypeB.setName("Prototype B");
        prototypeB.setFieldB("Field B");

        // 将原型对象添加到原型管理器中
        PrototypeManager manager = new PrototypeManager();
        manager.addPrototype("A", prototypeA);
        manager.addPrototype("B", prototypeB);

        // 获取原型对象并克隆
        Prototype clonedPrototypeA = (Prototype) prototypeA.clone();
        Prototype clonedPrototypeB = (Prototype) prototypeB.clone();

        // 修改克隆对象的属性值
        clonedPrototypeA.setName("Cloned Prototype A");
        clonedPrototypeA.setFieldA("New Field A");
        clonedPrototypeB.setName("Cloned Prototype B");
        clonedPrototypeB.setFieldB("New Field B");

        // 输出克隆对象的属性值
        System.out.println("Cloned Prototype A: " + clonedPrototypeA.getName() + ", " + clonedPrototypeA.getFieldA());
        System.out.println("Cloned Prototype B: " + clonedPrototypeB.getName() + ", " + clonedPrototypeB.getFieldB());
    }
}
```

在上面的代码中，`Prototype`是抽象原型类，它定义了一个`clone()`方法用于克隆对象。`ConcretePrototypeA`和`ConcretePrototypeB`是具体原型类，它们继承了`Prototype`类并实现了自己的属性和方法。`PrototypeManager`是原型管理器，它维护了一个原型对象的映射表，可以通过键值对的方式获取和存储原型对象。客户端代码中，首先创建了两个原型对象并将它们添加到原型管理器中，然后通过调用`clone()`方法克隆出新的原型对象，最后修改克隆对象的属性值并输出。

#### 补充：在Java中，克隆分为浅克隆和深克隆。

浅克隆是指创建一个新对象，然后将原始对象的非静态字段复制到新对象中。如果字段是基本类型，则它们的值将被直接复制。如果字段是引用类型，则只会复制引用，而不会复制引用指向的对象。这意味着原始对象和克隆对象中的引用类型字段将指向同一个对象。

深克隆不仅会复制原始对象的所有字段，还会递归地复制引用类型字段指向的所有对象。这意味着原始对象和克隆对象中的引用类型字段将指向不同的对象 。

在Java中，可以使用`clone()`方法实现浅克隆，使用序列化和反序列化实现深克隆。

1. 浅克隆

```java
class Person implements Cloneable {
    String name;
    int age;
    Address address;

    public Person(String name, int age, Address address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

class Address implements Cloneable {
    String city;
    String street;

    public Address(String city, String street) {
        this.city = city;
        this.street = street;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        Address address = new Address("Beijing", "Chaoyang");
        Person person1 = new Person("Tom", 20, address);
        Person person2 = (Person) person1.clone();
        System.out.println(person1 == person2); // false
        System.out.println(person1.address == person2.address); // true
    }
}

```

2. 深克隆

```java
import java.io.*;

class Person implements Serializable {
    String name;
    int age;
    Address address;

    public Person(String name, int age, Address address) {
        this.name = name;
        this.age = age;
        this.address = address;
    }
}

class Address implements Serializable {
    String city;
    String street;

    public Address(String city, String street) {
        this.city = city;
        this.street = street;
    }
}

public class Main {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        Address address = new Address("Beijing", "Chaoyang");
        Person person1 = new Person("Tom", 20, address);
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(person1);
        oos.flush();
        oos.close();
        byte[] bytes = bos.toByteArray();
        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
        ObjectInputStream ois = new ObjectInputStream(bis);
        Person person2 = (Person) ois.readObject();
        System.out.println(person1 == person2); // false
        System.out.println(person1.address == person2.address); // false
    }
}

```

### 5.单例模式

单例模式是一种常用的软件设计模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。在Java中，单例模式的定义为：一个类有且仅有一个实例，并且自行实例化向整个系统提供。

#### 5.1.懒汉模式(线程不安全)

```java
public class Singleton_01 {
    private static Singleton_01 instance = null;

    private Singleton_01() {

    }

    public static Singleton_01 getInstance() {
        if (instance == null) {
            instance = new Singleton_01();
        }
        return instance;
    }

}
```

- 单例模式有⼀个特点就是不允许外部直接创建，也就是 new Singleton_01() ，因此这⾥在默认 的构造函数上添加了私有属性 private 。 
- ⽬前此种⽅式的单例确实满⾜了懒加载，但是如果有多个访问者同时去获取对象实例你可以想象成 ⼀堆⼈在抢厕所，就会造成多个同样的实例并存，从⽽没有达到单例的要求。

#### 5.2.懒汉模式(线程安全)

```java
public class Singleton_02 {

    private static Singleton_02 instance;

    private Singleton_02() {

    }

    public static synchronized Singleton_02 getInstance() {
        if (instance == null) {
            instance = new Singleton_02();
        }
        return instance;
    }
}

```

- 此种模式虽然是安全的，但由于把锁加到⽅法上后，所有的访问都因需要锁占⽤导致资源的浪费。 如果不是特殊情况下，不建议此种⽅式实现单例模式。

#### 5.3.饿汉模式(线程安全)

```java
public class Singleton_03 {
    private static Singleton_03 instance=new Singleton_03();

    private Singleton_03(){}

    public static Singleton_03 getInstance(){
        return instance;
    }
}
```

- 此种⽅式与我们开头的第⼀个实例化 Map 基本⼀致，在程序启动的时候直接运⾏加载，后续有外 部需要使⽤的时候获取即可。
- 但此种⽅式并不是懒加载，也就是说⽆论你程序中是否⽤到这样的类都会在程序启动之初进⾏创建。
- 那么这种⽅式导致的问题就像你下载个游戏软件，可能你游戏地图还没有打开呢，但是程序已经将 这些地图全部实例化。到你⼿机上最明显体验就⼀开游戏内存满了，⼿机卡了，需要换了。

#### 5.4.使⽤类的内部类(线程安全)

```java
public class Singleton_04 {
    public static class SingletonHolder {
        public static Singleton_04 instance = new Singleton_04();
    }

    public static Singleton_04 getInstance() {
        return SingletonHolder.instance;
    }

    private Singleton_04() {

    }
}
```

- 使⽤类的静态内部类实现的单例模式，既保证了线程安全有保证了懒加载，同时不会因为加锁的⽅式耗费性能。
- 这主要是因为JVM虚拟机可以保证多线程并发访问的正确性，也就是⼀个类的构造⽅法在多线程环境下可以被正确的加载。
- 此种⽅式也是⾮常推荐使⽤的⼀种单例模式

#### 5.5.双重锁校验(线程安全)

```java
public class Singleton_05 {

    private static Singleton_05 instance;

    private Singleton_05() {

    }

    public static Singleton_05 getInstance() {
        synchronized (Singleton_05.class) {
            if (instance == null) {
                instance = new Singleton_05();
            }
        }
        return instance;
    }
}
```

- 双重锁的⽅式是⽅法级锁的优化，减少了部分获取实例的耗时。
- 同时这种⽅式也满⾜了懒加载。

#### 5.6.CAS「AtomicReference」(线程安全)

```java
public class Singleton_06 {
    public static AtomicReference<Singleton_06> atomicReference = new AtomicReference<>();
    private static Singleton_06 instance;

    private Singleton_06() {

    }

    public static Singleton_06 getInstance() {
        for (; ; ) {
            Singleton_06 instance = atomicReference.get();
            if (instance != null) {
                return instance;
            }
            atomicReference.compareAndSet(null, new Singleton_06());
            return atomicReference.get();
        }

    }
}
```

- java并发库提供了很多原⼦类来⽀持并发访问的数据安全性；AtomicInteger 、 AtomicBoolean 、 AtomicLong 、 AtomicReference 。 AtomicReference 可以封装引⽤⼀个V实例，⽀持并发访问如上的单例⽅式就是使⽤了这样的⼀个特点。 
- 使⽤CAS的好处就是不需要使⽤传统的加锁⽅式保证线程安全，⽽是依赖于CAS的忙等算法，依赖 于底层硬件的实现，来保证线程安全。相对于其他锁的实现没有线程的切换和阻塞也就没有了额外 的开销，并且可以⽀持较⼤的并发性。 
- 当然CAS也有⼀个缺点就是忙等，如果⼀直没有获取到将会处于死循环中。

#### 5.7.Effective Java作者推荐的枚举单例(线程安全)

```java
public enum Singleton_07 {
    INSTANCE;

    public void doSomething() {
        System.out.println(Thread.currentThread().getName() + " do something");
    }
}
```

> 约书亚·布洛克（英语：Joshua J. Bloch，1961年8⽉28⽇－），美国著名程序员。他为Java平台 设计并实作了许多的功能，曾担任Google的⾸席Java架构师（Chief Java Architect）。

- Effective Java 作者推荐使⽤枚举的⽅式解决单例模式，此种⽅式可能是平时最少⽤到的。 
- 这种⽅式解决了最主要的；线程安全、⾃由串⾏化、单⼀实例。