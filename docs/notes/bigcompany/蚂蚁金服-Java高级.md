---
title: 蚂蚁金服-Java高级
createTime: 2025/08/21 13:22:39
permalink: /bigcompany/k9lnfr7m/
---
- ## **一、数据结构相关**

  ### **1. 二叉搜索树（BST）和平衡二叉树的关系及区别**

  **二叉搜索树（BST）**

  - 定义：每个节点满足左子树 < 根 < 右子树。
  - 特点：支持快速查找、插入、删除，平均时间复杂度 O(log n)，最坏情况 O(n)（退化为链表）。

  **平衡二叉树**

  - 在 BST 的基础上，保证树的高度平衡，左右子树高度差 ≤ 1。
  - 优点：保证查找、插入、删除时间复杂度为 O(log n)。

  **AVL 树（强平衡）与红黑树（弱平衡）的区别**

  | 特性          | AVL 树                       | 红黑树                                               |
  | ------------- | ---------------------------- | ---------------------------------------------------- |
  | 平衡程度      | 高度平衡，左右子树高度差 ≤ 1 | 较弱平衡，通过颜色属性约束路径黑色节点数量           |
  | 查找效率      | 高（树更平衡）               | 略低                                                 |
  | 插入/删除效率 | 低（可能频繁旋转）           | 高（旋转次数少）                                     |
  | 适用场景      | 读操作多的场景               | 写操作频繁、如 JDK 的 `TreeMap` / `HashMap` 链表转树 |

  ------

  ### **2. B 树和 B+ 树及 MySQL 使用原因**

  **B 树**

  - 所有关键字分布在整棵树；每个节点保存数据；搜索可能在非叶子节点结束。
  - 查询性能等价于二分查找。

  **B+ 树**

  - 非叶子节点只存索引（关键字，不保存数据），叶子节点存所有数据。
  - 叶子节点通过链表串联，支持顺序遍历。
  - 非叶子节点只做索引，能存更多元素，更“矮胖”，减少 IO。

  **MySQL 使用 B+ 树原因**

  1. 磁盘存储优化：非叶子节点只存索引，可在一个页存储更多节点。
  2. 范围查询高效：只需遍历叶子链表。
  3. 查询稳定：查找总能走到叶子节点。

  ------

  ### **3. HashMap 如何解决 Hash 冲突**

  - **链表法**：每个桶维护链表，冲突时新节点插入链表。
  - **JDK 1.8 优化**：当链表长度 > 8，链表转红黑树，提高查询性能。
  - **原理举例**：

  ```
  hash("key1") → 桶0
  hash("key2") → 桶0
  桶0: key1 → key2 → null   // 链表
  链表长度 > 8 → 转红黑树
  ```

  ------

  ### **4. epoll 与 poll 区别及应用**

  | 特性     | poll               | epoll                           |
  | -------- | ------------------ | ------------------------------- |
  | 机制     | 轮询监听           | 内核事件通知                    |
  | 优势     | 简单               | 大量 fd 性能好，避免轮询开销    |
  | 应用场景 | 连接数少，简单服务 | 高并发网络服务，如 Nginx、Netty |

  ------

  ### **5. 线程池原理 & FixedThreadPool 阻塞队列**

  - **原理**
    1. 线程池维护一组工作线程 `workerSet`。
    2. 任务提交到阻塞队列 `workQueue`。
    3. 空闲线程从队列中取任务执行。
  - **FixedThreadPool**
    - 使用 **无界队列 `LinkedBlockingQueue`**，队列永远不会拒绝任务，线程固定。

  ------

  ### **6. synchronized 与 ReentrantLock 区别**

  | 特性       | synchronized | ReentrantLock          |
  | ---------- | ------------ | ---------------------- |
  | 获取方式   | 隐式         | 显示 lock() / unlock() |
  | 可中断     | 否           | 是，可响应中断         |
  | 公平性     | 不支持       | 可实现公平锁           |
  | 多条件等待 | 不支持       | Condition 支持多个条件 |
  | 实现层     | JVM          | API                    |

  ------

  ### **7. synchronized 锁升级机制**

  - **自旋锁**：线程短时间内等待，避免阻塞。
  - **偏向锁**：偏向第一个获取锁的线程，减少无竞争情况下的 CAS 操作。
  - **轻量级锁**：偏向锁在多线程竞争下升级，仍在用户态自旋。
  - **重量级锁**：线程阻塞挂起，操作系统调度唤醒。

  **联系**：锁从轻到重依次升级，减少开销并保证安全。

  ------

  ### **8. HTTP 问题与 HTTPS 安全机制**

  **HTTP 不足**

  - 明文传输 → 易被窃听
  - 不验证身份 → 易被伪装
  - 无完整性校验 → 易被篡改

  **常用加密算法**

  - MD5、DES、AES、RSA

  **HTTPS 安全保障**

  1. **对称加密**：保证数据传输保密性（AES）。
  2. **非对称加密**：传输密钥安全（RSA）。
  3. **数字证书 & CA**：验证身份。
  4. **摘要算法**：保证报文完整性（SHA）。

  ------

  ## **二、蚂蚁 Java 二面题**

  ### **1. 设计模式大类**

  - **创建型**：Singleton、Factory Method、Abstract Factory、Builder、Prototype
  - **结构型**：Adapter、Bridge、Composite、Decorator、Facade、Flyweight、Proxy
  - **行为型**：Observer、Strategy、Command、Template Method、State、Mediator、Iterator

  ------

  ### **2. volatile 关键字**

  - **可见性**：修改立即刷新到主内存，其他线程可见。
  - **有序性**：禁止指令重排（在 JVM 层面）。
  - **不保证原子性**：如 `i++` 不是原子操作。

  ------

  ### **3. Java 内存结构**

  - **方法区（Metaspace）**：存类信息
  - **堆**：对象实例存储
    - 新生代：Eden + Survivor
    - 老年代：长期存活对象
    - 默认晋升阈值：JVM 8+ 默认 15 岁
  - **栈**：方法调用帧
  - **PC 寄存器**：程序计数
  - **本地方法栈**：Native 方法

  ------

  ### **4. ConcurrentHashMap 线程安全 & JDK1.8 变化**

  - **原理**：分段锁（JDK1.7）→ synchronized + CAS + 链表/红黑树（JDK1.8）
  - **JDK1.8 优化**：每个桶使用 **链表或红黑树**，减少锁粒度，实现更高并发。

  ------

  ### **5. ConcurrentHashMap 底层红黑树原因**

  - 链表过长 → 查询效率低
  - 超过阈值转红黑树 → 保证查找复杂度 O(log n)

  ------

  ### **6. MySQL 优化思路**

  - **索引优化**：B+ 树索引、覆盖索引
  - **SQL 优化**：避免全表扫描、避免 SELECT *
  - **缓存优化**：Redis 缓存热点数据
  - **分库分表**：减小单库压力
  - **连接池**：减少频繁连接开销

  ------

  ### **7. OOM 处理**

  - **分析工具**：jmap、jstack、MAT
  - **处理策略**：
    1. 增加堆内存
    2. 优化对象生命周期
    3. 避免大对象长时间驻留

  ------

  ## **三、蚂蚁 Java 三面题**

  ### **1. 项目介绍**

  - 说明项目背景、业务目标、技术栈、职责、难点及优化方案

  ### **2. Redis 缓存一致性**

  - **双删延时策略**

    ```
    1. 删除缓存
    2. 更新数据库
    3. 延时再删除一次缓存
    ```

  ### **3. Redis 问题**

  - **缓存雪崩**：大量 key 同时过期 → 系统压力
    - 解决：TTL 随机、加锁、限流
  - **缓存击穿**：热点 key 过期 → 频繁请求 DB
    - 解决：互斥锁/互斥队列
  - **缓存穿透**：查询不存在的 key → 全部查询 DB
    - 解决：布隆过滤器或空值缓存

  ### **4. 消息中间件比较**

  | 中间件   | 特点                       | 适用场景           |
  | -------- | -------------------------- | ------------------ |
  | RocketMQ | 高吞吐、分布式、事务消息   | 电商订单、金融系统 |
  | Kafka    | 高吞吐、分布式日志、流处理 | 大数据、日志收集   |
  | RabbitMQ | AMQP、可靠投递、路由灵活   | 企业消息、任务队列 |
  | ActiveMQ | JMS 标准                   | 企业系统整合       |

