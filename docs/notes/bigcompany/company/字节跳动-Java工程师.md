---
title: 字节跳动-Java工程师
createTime: 2025/08/21 13:07:45
permalink: /bigcompany/163gcqrx/
---
- ### 1、为什么要用线程池

  - **答案**：线程池预先创建一定数量的线程以重用，提高响应速度，降低频繁创建销毁线程的开销，控制并发线程数，方便任务管理。

  ------

  ### 2、MySQL优化经验

  - **答案**：
    - 避免全表扫描，建立索引；
    - 避免 `!=` / `<>`；
    - 优先使用数字字段；
    - 避免 `select *`；
    - 减少临时表频繁创建。

  ------

  ### 3、线程死锁及避免方法

  - **答案**：
    - **死锁条件**：互斥、请求与保持、不剥夺、循环等待；
    - **避免方法**：
      1. 加锁顺序统一；
      2. 加锁超时 + 回退重试；
      3. 死锁检测机制。

  ------

  ### 4、Spring中Bean作用域

  - **答案**：
    - `singleton`：全局唯一实例；
    - `prototype`：每次获取新实例；
    - `request`：每次HTTP请求同一实例；
    - `session`：每个HTTP Session同一实例；
    - `globalSession`：Portlet全局共享。

  ------

  ### 5、Spring框架设计模式

  - **答案**：
    - 代理模式：AOP、Remoting；
    - 单例模式：默认 Bean；
    - 模板方法模式：代码复用；
    - 前端控制器模式：DispatcherServlet；
    - 依赖注入模式：IoC 核心；
    - 工厂模式：BeanFactory 创建 Bean。

  ------

  ### 6、SpringMVC核心及请求流程

  - **答案**：
    - 核心：控制反转（IoC）+ 面向切面（AOP）
    - 请求流程：
      1. 用户请求 → DispatcherServlet；
      2. DispatcherServlet 分发到 Controller；
      3. Controller 处理 → ModelAndView；
      4. DispatcherServlet 渲染视图 → 返回响应。

  ------

  ### 7、JVM内存结构

  - **答案**：
    - 程序计数器：线程私有，记录行号；
    - 虚拟机栈：线程私有，存储局部变量、操作数栈；
    - 本地方法栈：线程私有，服务 native 方法；
    - 堆：线程共享，对象实例存储区；
    - 方法区：线程共享，存储类信息、常量、静态变量。

  ------

  ### 8、栈内存溢出

  - **答案**：线程递归调用过深或栈帧过大导致 `StackOverflowError`，可通过 `-Xss` 调节栈大小。

  ------

  ### 9、JVM内存模型

  - **答案**：
    - 线程私有：程序计数器、虚拟机栈、本地方法栈；
    - 线程共享：堆、方法区（JDK8 后元数据区 + 运行时常量池）。

  ------

  ### 10、JVM GC及对象晋升

  - **答案**：
    - 新生代 = Eden + Survivor0 + Survivor1；
    - Minor GC 回收新生代，存活对象进 Survivor；
    - 对象在 Survivor 经历一定次数 Minor GC（默认15）晋升老年代；
    - 老年代满触发 Full GC / Major GC。

  ------

  ### 11、Java垃圾回收算法

  - **答案**：
    - 标记-清除、标记-整理、复制算法、分代收集、引用计数（HotSpot 不用）。

  ------

  ### 12、对象是否存活判断

  - **答案**：通过 **可达性分析**，从 GC Roots 可直接或间接访问的对象为存活对象。

  ------

  ### 13、垃圾回收器及 CMS/G1

  - **答案**：
    - Serial、Parallel、CMS、G1；
    - **CMS**：老年代并发回收，停顿少但有碎片化；
    - **G1**：分区回收，停顿可控，碎片少。

  ------

  ### 14、类加载

  - **答案**：JVM 将 `.class` 文件加载到内存形成 `Class` 对象。

  ------

  ### 15、类加载过程

  - **答案**：
    1. 加载（Load）
    2. 验证（Verify）
    3. 准备（Prepare）
    4. 解析（Resolve）
    5. 初始化（Initialize）

  ------

  ### 16、类加载器及常见类型

  - **答案**：
    - Bootstrap、Extension、App、自定义类加载器。

  ------

  ### 17、双亲委派模型

  - **答案**：子加载器请求加载类时，先委派父加载器，父加载器找不到再自己加载。

  ------

  ### 18、为什么需要双亲委派

  - **答案**：保证核心类（如 `java.lang.*`）唯一，避免重复加载和安全风险。

  ------

  ### 19、怎么打破双亲委派

  - **答案**：使用自定义类加载器，优先加载自己定义的类而非委派给父加载器。

  ------

  ### 20、强引用、软引用、弱引用、虚引用

  | 类型   | 特点                           |
  | ------ | ------------------------------ |
  | 强引用 | 普通引用，GC 不回收            |
  | 软引用 | 内存不足时回收，用于缓存       |
  | 弱引用 | 下一次 GC 回收，用于注册表     |
  | 虚引用 | 无法获取对象，监控对象回收状态 |

