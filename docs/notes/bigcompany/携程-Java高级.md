---
title: 携程-Java高级
createTime: 2025/08/21 14:06:22
permalink: /bigcompany/d2u8unqy/
---
## 1. 描述一下 JVM 加载 Class 文件的原理机制

Java 中的所有类都需要由类加载器装载到 JVM 中才能运行。类加载器本身也是一个类，它负责将 class 文件从硬盘读取到内存中。通常情况下，类的加载是隐式的，只有在特殊用法（如反射）下才需要显式加载类。

Java 的类加载是动态的，并不会一次性加载所有类。程序运行时，基础类（如核心库类）先加载到 JVM，其它类则在需要时才加载，以节省内存开销。

### 类加载器

Java 的类加载器有三种：

| 类加载器         | 作用                            |
| ---------------- | ------------------------------- |
| Bootstrap Loader | 加载系统类（内置类，如 String） |
| ExtClassLoader   | 加载扩展类（扩展库、实现类）    |
| AppClassLoader   | 加载应用类（程序员自定义类）    |

### 委托模型机制

类加载器之间遵循委托机制：

1. 子类加载器收到加载请求时，先委托父加载器加载。
2. 父加载器无法加载时，子加载器才会尝试加载自己的类。

这种机制保证基础类由根加载器加载，提升安全性，防止恶意类覆盖基础类。

```
ClassLoader loader = ClassName.class.getClassLoader();
ClassLoader parentLoader = loader.getParent();
```

> 注意：Bootstrap Loader 在 Java 中没有实体，它是用 C++ 实现的，打印其内容会得到 `null`。

### 类加载流程

1. **装载**：查找并导入 class 文件。
2. **连接**：包括检查、准备和解析。
   - 检查：验证 class 文件正确性。
   - 准备：为静态变量分配存储空间。
   - 解析：将符号引用转换成直接引用（可选）。
3. **初始化**：初始化静态变量和静态代码块。

类的静态方法（如 `main()`）会触发类加载。

------

## 2. 什么是类加载器？

类加载器是负责加载类文件的类。Java 源代码通过 `javac` 编译成 class 文件，然后 JVM 执行字节码。类加载器可从文件系统、网络或其他来源加载类文件。

------

## 3. 类加载器类型

1. **Bootstrap 类加载器**
   - 加载 JDK 内置类（rt.jar）。
   - 父加载器为 `null`。
2. **Extension 类加载器**
   - 先委托父加载器（Bootstrap）加载类。
   - 若失败，从 `jre/lib/ext` 或 `java.ext.dirs` 加载。
3. **Application 类加载器**
   - 加载 classpath 中的应用类。
   - 是 Extension 类加载器的子加载器。

------

## 4. Tomcat 类加载机制

Tomcat 启动时会创建几种类加载器：

| 加载器    | 作用                                | 路径                          |
| --------- | ----------------------------------- | ----------------------------- |
| Bootstrap | 加载 JVM 启动所需类和标准扩展类     | jre/lib/ext                   |
| System    | 加载 Tomcat 启动类（bootstrap.jar） | CATALINA_HOME/bin             |
| Common    | 加载 Tomcat 通用类                  | CATALINA_HOME/lib             |
| Webapp    | 每个应用独立类加载器                | WEB-INF/classes & WEB-INF/lib |

类加载顺序：

1. Bootstrap
2. System
3. Webapp（WEB-INF/classes）
4. Webapp（WEB-INF/lib）
5. Common（CATALINA_HOME/lib）

------

## 5. 类加载器双亲委派模型

**原理**：子类加载器收到加载请求，先委托父类加载器处理，父类无法加载时再由子类加载。

**优点**：

- 安全：保证核心类由根加载器加载，防止恶意类替换核心类。
- 层次清晰：系统类和自定义类加载有序。

------

## 6. Java 内存分配

- 每个 JVM 进程唯一对应一个堆，每个线程有私有栈。
- 对象实例在堆上分配，引用在栈上分配。
- 堆：存储对象本身及数组
- 栈：存储基本类型和对象引用
- 方法区（静态区）：存储类信息和 static 变量

------

## 7. Java 堆结构

- **年轻代**（Young Generation）：存储新对象，快速回收短生命周期对象。包括 Eden、两个 Survivor 区。
- **年老代**（Old Generation）：存储经历多次 GC 的长生命周期对象。
- **持久代 / 元空间（Permanent Generation / MetaSpace）**：存储类信息和静态数据。JDK 1.8 后改为 MetaSpace，占用本地内存。

------

## 8. 内存区域变化

- 方法区从永久代变为 MetaSpace（Java 8+）。
- String 从永久代移入堆中。

------

## 9. 各个区域作用

| 区域       | 作用                                       |
| ---------- | ------------------------------------------ |
| 程序计数器 | 当前线程执行字节码行号指示器               |
| 虚拟机栈   | 方法执行的内存模型，局部变量、操作栈       |
| 本地方法栈 | 支持 native 方法执行                       |
| 堆         | 存放对象实例，线程共享                     |
| 方法区     | 存储类信息、常量、静态变量、即时编译器代码 |

------

## 10. Java 内存泄漏

Java 有垃圾回收机制，但仍可能出现内存泄漏：

- 可达但无用对象无法被 GC 回收
- 例：Hibernate 的一级缓存对象未关闭或清空

------

## 11. Java 类加载过程

1. 装载（Load）
2. 连接（Link）：检查、准备、解析
3. 初始化（Initialization）

------

## 12. 什么是 GC？为什么要有 GC？

GC（Garbage Collection）即垃圾回收：

- 自动管理内存，回收无用对象
- 避免内存泄漏和 OutOfMemoryError
- 提升开发效率，减少手动管理内存的复杂性

------

## 13. Java 垃圾回收机制

- JVM 通过分代回收机制管理对象
- 年轻代使用 Minor GC，快速回收短生命周期对象
- 老年代使用 Major / Full GC，回收长期存活对象
- 回收策略包括标记-清除、标记-整理、复制算法等

------

## 14. 如何判断一个对象是否存活？

- 对象可通过引用访问，则为存活
- GC 判断对象不可达，则可回收

------

## 15. 垃圾回收优点与原理

- **优点**：自动内存管理，避免内存泄漏，提高安全性
- **原理**：
  1. 标记-清除（Mark-Sweep）
  2. 复制算法（Copying）

------

## 16. 深拷贝与浅拷贝

- **浅拷贝**：复制对象的引用，原对象和新对象共享数据
- **深拷贝**：复制对象及其引用对象的所有数据，完全独立

------

## 17. 什么是分布式垃圾回收（DGC）？它是如何工作的？

### 概念

分布式垃圾回收（Distributed Garbage Collection, DGC）用于管理分布式系统中跨 JVM 或跨机器的对象生命周期。传统的垃圾回收只管理单 JVM 内存，而 DGC 可以处理网络传输中的远程对象引用，确保不再使用的远程对象被回收。

### 工作原理

1. **引用计数（Reference Counting）**
   - 每个远程对象维护一个引用计数器
   - 当远程引用创建或销毁时，计数器递增或递减
   - 计数器为 0 时，对象可被回收
   - 问题：循环引用无法回收
2. **标记-清除（Mark-Sweep）**
   - DGC 定期扫描远程对象引用图
   - 标记可达对象
   - 回收不可达对象
   - 可结合心跳机制避免误回收
3. **租约机制（Lease / Time-based）**
   - 每个远程引用有租约时间
   - 客户端定期续租
   - 未续租的对象被认为不可用，DGC 回收

### 解题思路

- 理解 DGC 目的是解决 **远程对象生命周期管理**
- 关注 DGC 的挑战：
  - 网络延迟
  - 客户端断开连接
  - 循环引用
- 掌握常用实现机制：引用计数、标记-清除、租约机制
- 实际应用：RMI、分布式缓存、微服务远程对象管理