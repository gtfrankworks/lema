---
title: 腾讯-Java高级
createTime: 2025/08/21 13:04:32
permalink: /bigcompany/xxvp1nck/
---
### 1. 从简历项目中选一个项目，遇到的重大挑战和解决思路

- **举例**：在微服务项目中，实现分布式事务。
- **挑战**：跨多个微服务更新数据时保证一致性。
- **解决思路**：
  - 使用 **TCC（Try-Confirm-Cancel）模式** 或 **Saga模式**；
  - 对关键业务操作增加重试和补偿机制；
  - 使用消息队列确保异步操作可靠执行；
  - 严格日志记录和异常捕获。

------

### 2. 一段代码执行多个 Redis 命令，不加锁如何保证原子性？

- **解决方法**：使用 **Lua 脚本**在 Redis 中原子执行多个命令。
   示例：

```
-- KEYS[1], KEYS[2] 是 key，ARGV[1] 是 value
redis.call("SET", KEYS[1], ARGV[1])
redis.call("INCR", KEYS[2])
return 1
```

- Redis 会把 Lua 脚本当作一个命令执行，保证原子性。

------

### 3. 数据结构：二叉树、红黑树

- **二叉树**：每个节点最多两个子节点。适合排序、查找。
- **红黑树**：
  - 自平衡二叉查找树；
  - 每个节点有颜色标记（红/黑），保证树高为 O(log n)；
  - 常用于 TreeMap、TreeSet。

------

### 4. B-tree 和 B+tree 区别

| 特性     | B-tree                         | B+tree                           |
| -------- | ------------------------------ | -------------------------------- |
| 数据位置 | 内部节点和叶子节点均可存储数据 | 只存储在叶子节点                 |
| 顺序访问 | 需中序遍历                     | 叶子节点通过指针顺序访问，遍历快 |
| 查询性能 | 层级较多                       | 层级更少，查询更稳定             |
| 应用场景 | 数据库索引、文件系统           | MySQL InnoDB 索引、文件系统      |

------

### 5. MySQL 哪个版本和存储引擎使用 B+tree？

- **InnoDB**（MySQL 5.x/8.x）使用 **B+tree** 索引。
- **为什么不使用红黑树**：
  - B+tree 支持顺序访问和范围查询；
  - 红黑树不适合磁盘存储，磁盘 IO 随机访问成本高。

------

### 6. 常见消息中间件区别

| 特性       | ActiveMQ     | RabbitMQ             | RocketMQ | Kafka      |
| ---------- | ------------ | -------------------- | -------- | ---------- |
| 开发语言   | Java         | Erlang               | Java     | Scala      |
| 单机吞吐量 | 万级         | 万级                 | 10万级   | 10万级     |
| 时效性     | ms级         | us级                 | ms级     | ms级以内   |
| 可用性     | 高           | 高                   | 非常高   | 非常高     |
| 功能特性   | 成熟、协议多 | 高并发、管理界面丰富 | 扩展性佳 | 面向大数据 |

- **选择建议**：
  - 中小型公司：RabbitMQ；
  - 大型公司：RocketMQ；
  - 日志采集、大数据：Kafka。

------

### 7. RabbitMQ 如何保证消息可靠性

1. **消息不丢失**：
   - 开启 confirm 或事务；
   - 持久化交换机、队列、消息；
   - 手动 ack。
2. **消息不重复消费**：
   - 幂等性处理。
3. **消息顺序**：
   - 同队列、单消费者。
4. **消息重试**：
   - SpringBoot：`@Retryable` + `@Recover` 注解控制重试次数和延迟。

------

### 8. Spring Cloud 服务发现原理

- 客户端定期（30s）发送心跳更新租约，若失败超过阈值（90s），服务会被移除。
- Eureka Server 节点之间复制注册信息，实现高可用。
- 客户端可缓存服务列表，即使 Eureka 挂掉仍可访问服务。

------

### 9. Spring Cloud 核心组件

- **Eureka**：服务注册与发现
- **Ribbon**：客户端负载均衡
- **Feign**：基于注解的 HTTP 客户端
- **Hystrix**：服务熔断、线程隔离
- **Zuul**：API 网关
- **其他注册中心**：Zookeeper、Consul

------

### 10. 微服务限流方式

- **令牌桶（Token Bucket）**
- **漏桶（Leaky Bucket）**
- **计数器（Counter）**
- **滑动窗口（Sliding Window）**

------

### 11. 限流的情况下，服务隔离还有没有必要？

- **有必要**：
  - 限流是保护服务入口，防止请求过载；
  - 服务隔离保证不同服务故障不影响整体系统，避免雪崩效应。

------

### 12. Dubbo 负载均衡

- **负载均衡算法**：
  - Random、RoundRobin、LeastActive、ConsistentHash
- **位置**：
  - 一般在 **客户端** 进行负载均衡，客户端选择调用哪台服务。

------

### 13. Redis 分布式锁实现

- **方式**：
  - SET key value NX PX timeout
  - 使用 Redisson 库简化实现
- **注意事项**：
  - 防止死锁：设置过期时间
  - 保证释放锁是持有者自己释放（Lua 脚本检查 value）

------

### 14. 看过的源码设计亮点

- **Spring BeanFactory**：使用 **工厂模式**创建 Bean
- **Spring AOP**：使用 **动态代理模式**实现横切关注点
- **MyBatis**：使用 **模板方法模式**和 **代理模式**
- **设计亮点**：
  - IOC/DI 解耦
  - 延迟加载
  - 面向接口编程

------

### 15. 如何实现 AOP？项目应用场景

- **实现方式**：
  - 基于 **动态代理**（JDK/CGlib）
  - 基于 **AspectJ 注解**
- **项目应用**：
  - 日志记录
  - 权限校验
  - 事务管理
  - 性能统计

------

### 16. 后置处理器作用

- **BeanPostProcessor**：
  - 在 Bean 初始化前后执行额外逻辑
  - 示例：修改属性、注入依赖、动态代理

------

### 17. Spring Bean 作用域

- **单例（singleton）**：默认，一个容器只有一个实例
- **原型（prototype）**：每次获取一个新实例
- **request**：每次 HTTP 请求创建一个 Bean
- **session**：每个会话一个 Bean
- **使用场景**：
  - request 作用域适合 **Web 请求级别的对象**（如用户会话数据、上下文信息）