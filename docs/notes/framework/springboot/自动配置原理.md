---
title: 自动配置原理
createTime: 2025/08/27 16:34:09
permalink: /framework/springboot/hmt40bzv/
---
# 自动配置原理

## 1.@SpringBootApplication

一切的来自起源SpringBoot(3.1.0)的启动类，我们发现main方法上面有个注解：`@SpringBootApplication`

```java
package com.satan.boot;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Boot3TestDemo4Application {

    public static void main(String[] args) {
        SpringApplication.run(Boot3TestDemo4Application.class, args);
    }

}
```

`@SpringBootApplication` 标注在某个类上说明这个类是 SpringBoot 的主配置类， SpringBoot 就应该运行这个类的main方法来启动 SpringBoot 应用；它的本质是一个组合注解，我们点进去查看该类的元信息主要包含3个注解：

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
    //...
}
```

- `@SpringBootConfiguration`（里面就是@Configuration，标注当前类为配置类，其实只是做了一层封装改了个名字而已）
- `@EnableAutoConfiguration`（开启自动配置）
- `@ComponentScan`（包扫描）

注：**@Inherited是一个标识，用来修饰注解，如果一个类用上了@Inherited修饰的注解，那么其子类也会继承这个注解**

我们下面逐一分析这3个注解作用

###  1.1.@SpringBootConfiguration

- 我们继续点`@SpringBootConfiguration`进去查看源码如下：

```java			
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
@Indexed
public @interface SpringBootConfiguration {
    @AliasFor(
        annotation = Configuration.class
    )
    boolean proxyBeanMethods() default true;
}

```

`@Configuration`标注在某个类上，表示这是一个 springboot的`配置类`。可以向容器中注入组件。

### 1.2 @ComponentScan

- `@ComponentScan`：配置用于 Configuration 类的组件扫描指令。
- 提供与 `Spring XML` 的 `<context:component-scan>` 元素并行的支持。
- 可以 `basePackageClasses` 或`basePackages `来定义要扫描的特定包。 如果没有定义特定的包，将从声明该注解的类的`包开始扫描`。

### 1.3 @EnableAutoConfiguration

- @EnableAutoConfiguration顾名思义就是：`开启自动导入配置`
- 这个注解是SpringBoot的重点，我们下面详细讲解

## 2.@EnableAutoConfiguration

我们点进去看看该注解有什么内容

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage   //自动导包
@Import({AutoConfigurationImportSelector.class}) //自动配置导入选择
public @interface EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

    Class<?>[] exclude() default {};

    String[] excludeName() default {};
}
```

### 2.1.@AutoConfigurationPackage

- 自动导入配置包
- 点进去查看代码：

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import({AutoConfigurationPackages.Registrar.class})
public @interface AutoConfigurationPackage {
    String[] basePackages() default {};

    Class<?>[] basePackageClasses() default {};
}
```

- 它的作用是让 Spring Boot 自动扫描指定的包或类所在的包，以便自动配置相关的 Bean 或组件。

- `Import` 为spring的注解，导入一个配置文件，在springboot中为给容器导入一个组件，而导入的组件由 AutoConfigurationPackages.class的内部类`Registrar.class` 执行逻辑来决定是如何导入的。

#### 2.1.1 @Import({Registrar.class})

点Registrar.class进去查看源码如下：

```java
static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {
        Registrar() {
        }

        public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
            AutoConfigurationPackages.register(registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0]));
        }

        public Set<Object> determineImports(AnnotationMetadata metadata) {
            return Collections.singleton(new PackageImports(metadata));
        }
}
```

注：**Registrar实现了`ImportBeanDefinitionRegistrar`类，就可以被注解@Import导入到spring容器里。**

这个地方打断点

![image.png](/images/springboot/e2abee9b30a1458b835500930080aa06tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp)

运行可以查看到AutoConfigurationPackages.*register*(registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0]))；的值为当前启动类所在的包名

结论：**@AutoConfigurationPackage 就是将主配置类（@SpringBootApplication 标注的类）所在的包下面所有的组件都扫描注冊到 spring 容器中。**

### 2.2.@Import({AutoConfigurationImportSelector.class})

作用：AutoConfigurationImportSelector`开启自动配置类的导包的选择器`，即是带入哪些类，有选择性的导入。

点AutoConfigurationImportSelector.class进入查看源码，这个类中有两个方法见名知意：

1. selectImports：用于根据注解元数据获取自动配置类并返回其全限定名数组。

   具体来说，`selectImports()` 方法会先检查当前环境中是否启用了自动配置，如果没有启用，则会直接返回空数组。否则，它会调用 `getAutoConfigurationEntry()` 方法获取自动配置条目，并通过 `getConfigurations()` 方法获取候选的自动配置类。最后，通过 `StringUtils.toStringArray()` 方法将自动配置类列表转换为字符串数组并返回。

   总之，该方法主要用于在应用程序启动时加载自动配置类，进而实现对各种功能的统一、标准化和协作式管理。

   ```java
   public String[] selectImports(AnnotationMetadata annotationMetadata) {
           if (!this.isEnabled(annotationMetadata)) {
               return NO_IMPORTS;
           } else {
               AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata);
               return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
           }
       }
   ```

2. getAutoConfigurationEntry：具体来说，`getAutoConfigurationEntry()` 方法根据当前环境中是否启用了自动配置来决定是否返回空对象。如果启用了自动配置，则从注解元数据 `annotationMetadata` 和注解属性 `attributes` 中获取候选的自动配置类。然后，通过 `removeDuplicates()` 方法删除重复项，再通过 `getExclusions()` 方法获取需要排除的依赖，并将其从候选的自动配置类中移除。接着，通过 `filter()` 方法筛选出需要保留的自动配置类。最后，调用 `fireAutoConfigurationImportEvents()` 方法触发自动配置导入事件，以便其他组件也能对自动配置进行监听和处理。

   总之，该方法是 Spring Boot 自动配置机制的核心，通过自动扫描、检测和筛选等步骤，实现了自动配置的灵活、高效和可靠。

   ```java
   protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
       if (!this.isEnabled(annotationMetadata)) {
           return EMPTY_ENTRY;
       } else {
           AnnotationAttributes attributes = this.getAttributes(annotationMetadata);
            // 这打个断点，看看 返回的数据
           List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
           //删除重复项
           configurations = this.removeDuplicates(configurations);
           Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);
           //检查
           this.checkExcludedClasses(configurations, exclusions);
           //删除需要排除的依赖
           configurations.removeAll(exclusions);
           configurations = this.getConfigurationClassFilter().filter(configurations);
           this.fireAutoConfigurationImportEvents(configurations, exclusions);
           return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);
       }
   }
   ```

![image-20230605153115062](/images/springboot/image-20230605153115062.png)

configurations数组长度为150，并且文件后缀名都为 `**AutoConfiguration`

结论： **这些都是候选的配置类，经过去重，去除需要的排除的依赖，最终的组件才是这个环境需要的所有组件。有了自动配置，就不需要我们自己手写配置的值了，配置类有默认值的。**

我们继续往下看看是如何返回需要配置的组件的

#### 2.2.1.getCandidateConfigurations(annotationMetadata, attributes)

方法如下：

```java
protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
        List<String> configurations = ImportCandidates.load(AutoConfiguration.class, this.getBeanClassLoader()).getCandidates();
        Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.");
        return configurations;
    }
```

这是 Spring Boot 自动配置的核心代码之一，用于获取自动配置类的候选列表。

具体来说，`getCandidateConfigurations()` 方法会通过 `ImportCandidates.load()` 方法，从指定路径 `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` 中加载所有 `AutoConfiguration` 类型的候选配置。然后，它会检查是否加载到了自动配置类，并在没有找到时抛出异常。最后，将所有候选配置（即自动配置类）返回。

总之，该方法是 Spring Boot 自动配置机制的重要部分，通过自动扫描和加载，实现了对各种功能的快速、便捷和精准的自动配置。

org.springframework.boot.autoconfigure.AutoConfiguration.imports文件位置如下：

![image-20230605160726517](/images/springboot/image-20230605160726517.png)

![image-20230605160745380](/images/springboot/image-20230605160745380.png)

- 由图可知文件内包含146个自动配置类的全类名
- 并不是这146个自动配置类都能生效
- 每一个自动配置类，都有条件注解`@ConditionalOnxxx`，只有条件成立，才能生效 

## 3.流程总结图

![SpringBoot自动配置流程.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e787ee7bfb1c417aa8624a5a5c9de438~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

## 4.常用的Conditional注解

- 在加载自动配置类的时候，并不是将spring.factories的配置全部加载进来，而是通过@Conditional等注解的判断进行动态加载
- @Conditional其实是spring底层注解，意思就是根据不同的条件，来进行自己不同的条件判断，如果满足指定的条件，那么配置类里边的配置才会生效。
- 常用的Conditional注解：
  - @ConditionalOnClass ： classpath中存在该类时起效
  - @ConditionalOnMissingClass ： classpath中不存在该类时起效
  - @ConditionalOnBean ： DI容器中存在该类型Bean时起效
  - @ConditionalOnMissingBean ： DI容器中不存在该类型Bean时起效
  - @ConditionalOnSingleCandidate ： DI容器中该类型Bean只有一个或@Primary的只有一个时起效
  - @ConditionalOnExpression ： SpEL表达式结果为true时
  - @ConditionalOnProperty ： 参数设置或者值一致时起效
  - @ConditionalOnResource ： 指定的文件存在时起效
  - @ConditionalOnJndi ： 指定的JNDI存在时起效
  - @ConditionalOnJava ： 指定的Java版本存在时起效
  - @ConditionalOnWebApplication ： Web应用环境下起效
  - @ConditionalOnNotWebApplication ： 非Web应用环境下起效

## 5.@Import支持导入的三种方式

- 带有@Configuration的配置类
- ImportSelector 的实现
- ImportBeanDefinitionRegistrar 的实现