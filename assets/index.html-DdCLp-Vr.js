import{a as s,c as a,b as e,o as n}from"./app-ZQgO6-gU.js";const l={};function h(d,i){return n(),a("div",null,i[0]||(i[0]=[e(`<blockquote><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</p></blockquote><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>今天一大早就来了图书馆🏫，刚坐下来就迫不及待的开始看命令模式的相关资料📚。不过这个模式跟我之前的理解出入特别大。</p><p>最开始的时候，我以为的命令模式就是<code>函数回调</code>。但后来发现并不是，但他们两个确实是有关系，这一切的答案都藏在 GOF 的设计模式一书中。</p><h2 id="开始学习" tabindex="-1"><a class="header-anchor" href="#开始学习"><span>开始学习</span></a></h2><p>在软件设计模式之始 GOF 的原著中，命令模式的讲解还是在他们开发的那个编辑工具中，其用来讲解的案例就是我们日常编辑使用的编辑工具中，在工具栏有很多个功能按钮，或者菜单按钮。 就比如编辑工具中的一个 <code>新增文件</code> 的按钮🆕吧。GOF 要表达的意思就是，这个 <code>新增文件</code> 对系统本身来讲就是给使用者提供的一个命令，我们在用的过程中可以给编辑器发送不同的命令，但是这个 <code>新增文件</code> 的操作并不是在这个按钮上实现的，同时对于我们发送命令的人来说，也不知道具体这个 <code>新增文件</code> 这个动作是由谁来执行、怎么执行，这对我们来讲完全是透明的。</p><p>我们先不讨论这样做的好处，先看下这里面要说的几个角色</p><ol><li>客户端应用</li><li><code>新增文件</code>按钮（调用新增文件操作命令）</li><li>操作命令</li><li>操作接收（负责具体的操作执行）</li></ol><p>我试着按照这个结构写了一下这个代码</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Client</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> args</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        FileReceiver</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> fileReceiver</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> FileReceiver</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        AddFileCommand</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> addFileCommand</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> AddFileCommand</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">fileReceiver</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        Invoker</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> invoker</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Invoker</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        invoker</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">setCommand</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">addFileCommand</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        invoker</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">executeCommand</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>客户端应用 <code>Client</code></li><li><code>新增文件</code>按钮（调用新增文件操作）<code>Invoker</code></li><li>操作命令 <code>AddFileCommand</code></li><li>操作接收者 <code>FileReceiver</code></li></ol><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-text"><span class="line"><span>新增文件</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="关于-命令-的疑惑-🤔" tabindex="-1"><a class="header-anchor" href="#关于-命令-的疑惑-🤔"><span>关于 ‘命令’ 的疑惑 🤔</span></a></h2><p>按照上面的方式实现下来，我有一种感觉，有种脱裤子放屁的感觉，我直接调用 FileReceiver 不香吗</p><p>非要这样</p><figure><img src="https://i.loli.net/2020/11/28/oqEZfATCtK2UuQk.png" alt="command.png" tabindex="0" loading="lazy"><figcaption>command.png</figcaption></figure><p>我以为，使用者利用按钮直接调用对应的操作不就行了吗？就像我下面这样中间非要放一个命令对象（将具体的请求包装成了这个对象）？</p><figure><img src="https://i.loli.net/2020/11/28/SiylpQUYxGRAb91.png" alt="command-no-command" tabindex="0" loading="lazy"><figcaption>command-no-command</figcaption></figure><h2 id="解惑-命令-🤪" tabindex="-1"><a class="header-anchor" href="#解惑-命令-🤪"><span>解惑 ‘命令’ 🤪</span></a></h2><p>不过不久我就找到了答案💡</p><p>首先看下命令模式要解决的问题❔：<u>对请求排队、下载或记录请求日志，以及支持可撤消的操作。</u></p><p>然后我们开始思考🤔如果没有中间这个 “命令” 角色，那这些功能做在哪里？只能做在接收者，也就是逻辑具体的实现里面，那这是不是违背了一个设计原则，叫做 <code>单一职责原则</code> ？而且对这种 ”辅助型“ 的功能变多会导致逻辑实现类<strong>变得越来越”肿胀“</strong>，没错，就是”肿胀“！</p><p>并且这也使得调用者和实现者之间通过这个“命令”进行解耦，然后我们使用依赖倒置原则，将“命令”提取出来一个抽象类，这使得扩展请求也变得容易了。而且对于高层模块来说，自己完全不需要关心调用的时候具体的请求内容和实现内容，通过“命令”来完成自己的操作，比如点一个按钮、遥控器下的按键（从这里还可以看出，多个命令可以对应一个接受者，比如数字键的换台）、去餐厅点菜。这样一看，命令模式还真是符合这种设计思路的命名啊。</p><h2 id="命令模式类图-📌" tabindex="-1"><a class="header-anchor" href="#命令模式类图-📌"><span>命令模式类图 📌</span></a></h2><figure><img src="https://i.loli.net/2020/11/28/8HJOtxMFsq6PjoE.png" alt="command-UML" tabindex="0" loading="lazy"><figcaption>command-UML</figcaption></figure><p>主要结构</p><ol><li>调用者，也是暴露给客户端的对象 <code>Invoker</code></li><li>命令接口，<code>Command</code>（满足依赖倒置原则，便于扩展）</li><li>具体的命令，这里要包含谁来接受这个命令的接受者对象 <code>ConcreteCommand</code></li><li>命令的接收者，这里没有列实现类是因为任何类都可以是接收者 <code>Receiver</code></li></ol><h2 id="代码-📃" tabindex="-1"><a class="header-anchor" href="#代码-📃"><span>代码 📃</span></a></h2><p>命令模式这篇使用的是通用框架写了一个实现，在这基础上事实上我们可以做很多扩展，比如再 <code>Invoker</code> 类中将 command 换成 <code>List&lt;Command&gt;</code> 来实现请求的排队、撤销等操作。</p><figure><img src="https://i.loli.net/2020/12/03/ZE2fTd4FHQYhxeo.png" alt="image-20201128142121299" tabindex="0" loading="lazy"><figcaption>image-20201128142121299</figcaption></figure><h2 id="总结-📚" tabindex="-1"><a class="header-anchor" href="#总结-📚"><span>总结 📚</span></a></h2><p><strong>适用场景：</strong></p><ol><li>需要记录请求记录；</li><li>请求可以进行排队处理；</li><li>请求可以进行撤销、重做；</li><li>具体接收者来决定请求是否执行（关于这一点，如果请求不是封装成一个对象的话，判断起来是比较困难的）</li></ol><p>不过这种模式并不是一个常用的思想，一定是当你想要对请求做一些事情的时候才考虑，具体的事情就上面提到的 4 点，不然的话使用这种模式真的就是我上面说的，“脱裤子放屁了”。</p><p>最后再来一句话来总结一下命令模式，“张三，把门关一下”。这里我就是 Invoker，“把门关一下“ 就是 command （命令），“张三” 是 receiver （接收者）。更多时候，我们实际开发中，”把门关一下“ 都是定义好的，”我“直接选就行了，就像遥控器上的按键一样。但切记这个模式的使用时机，别做”恶心“人的事！</p><p>如果哪里有问题或者有疑问，欢迎加我微信（lvgocc）讨论，或者直接进群交流！天凉了🥶🥶，进群一起取暖也好啊😁，等你~</p>`,36)]))}const p=s(l,[["render",h]]),k=JSON.parse('{"path":"/design/8hdhv0sd/","title":"命令模式","lang":"zh-CN","frontmatter":{"title":"命令模式","createTime":"2025/08/27 23:26:03","permalink":"/design/8hdhv0sd/"},"readingTime":{"minutes":4.89,"words":1467},"git":{"createdTime":1756736713000},"filePathRelative":"notes/design/命令模式.md","headers":[]}');export{p as comp,k as data};
