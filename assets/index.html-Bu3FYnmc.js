import{a as n,c as a,b as i,o as e}from"./app-ZQgO6-gU.js";const l={};function d(r,s){return e(),a("div",null,s[0]||(s[0]=[i(`<p>Redis 提供了 <strong>三种持久化策略</strong>：</p><ol><li><strong>RDB（快照持久化，Snapshotting）</strong></li><li><strong>AOF（日志持久化，Append Only File）</strong></li><li><strong>RDB + AOF 混合持久化（Hybrid Persistence，4.0+）</strong></li></ol><hr><h2 id="_1️⃣-rdb-快照持久化" tabindex="-1"><a class="header-anchor" href="#_1️⃣-rdb-快照持久化"><span>1️⃣ RDB（快照持久化）</span></a></h2><h3 id="📍-原理" tabindex="-1"><a class="header-anchor" href="#📍-原理"><span>📍 原理</span></a></h3><ul><li>Redis 会在某个时刻，把<strong>内存中的数据以快照的形式保存到磁盘文件（dump.rdb）</strong>。</li><li>本质上是一个 <strong>全量备份</strong>。</li></ul><h3 id="📍-触发方式" tabindex="-1"><a class="header-anchor" href="#📍-触发方式"><span>📍 触发方式</span></a></h3><ul><li><p><strong>手动触发</strong>：</p><ul><li><code>SAVE</code>：在主线程直接保存 RDB，<strong>阻塞 Redis 服务</strong>。</li><li><code>BGSAVE</code>：fork 出子进程写 RDB 文件，主进程继续处理请求（常用）。</li></ul></li><li><p><strong>自动触发</strong>： 配置 <code>redis.conf</code>，满足条件时自动保存：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>save 900 1      # 900 秒内至少有 1 次写操作</span></span>
<span class="line"><span>save 300 10     # 300 秒内至少有 10 次写操作</span></span>
<span class="line"><span>save 60 10000   # 60 秒内至少有 10000 次写操作</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>特殊情况触发</strong>：</p><ul><li>执行 <code>FLUSHALL</code>（清空数据）时会生成空 RDB。</li><li>Redis 关机时（<code>shutdown</code>），如果配置了 <code>save</code>，也会触发 <code>SAVE</code>。</li></ul></li></ul><h3 id="📍-rdb-文件写入过程" tabindex="-1"><a class="header-anchor" href="#📍-rdb-文件写入过程"><span>📍 RDB 文件写入过程</span></a></h3><ol><li>Redis <strong>fork</strong> 子进程。</li><li>子进程遍历内存数据，序列化写入临时文件（<code>temp.rdb</code>）。</li><li>写入完成后替换旧的 <code>dump.rdb</code> 文件。</li></ol><blockquote><p>使用 <strong>写时复制（Copy-On-Write, COW）机制</strong>： 在 fork 后，子进程共享父进程的内存页；当父进程有写操作时，才复制内存页，避免大量复制，提高效率。</p></blockquote><h3 id="📍-优缺点" tabindex="-1"><a class="header-anchor" href="#📍-优缺点"><span>📍 优缺点</span></a></h3><p>✅ 优点：</p><ul><li>RDB 文件小，适合全量备份、迁移。</li><li>恢复速度快（直接加载 RDB 文件到内存）。 ❌ 缺点：</li><li>只能定时快照，<strong>丢失上一次快照后的数据</strong>。</li><li><code>BGSAVE</code> 时会 fork 子进程，内存翻倍，<strong>大内存实例性能受影响</strong>。</li></ul><hr><h2 id="_2️⃣-aof-日志持久化" tabindex="-1"><a class="header-anchor" href="#_2️⃣-aof-日志持久化"><span>2️⃣ AOF（日志持久化）</span></a></h2><h3 id="📍-原理-1" tabindex="-1"><a class="header-anchor" href="#📍-原理-1"><span>📍 原理</span></a></h3><ul><li>Redis 会把每条 <strong>写命令（如 SET、HSET）</strong> 追加到 AOF 文件（appendonly.aof）。</li><li>重启时，Redis 通过回放 AOF 文件里的命令，恢复数据。</li></ul><h3 id="📍-aof-写入过程" tabindex="-1"><a class="header-anchor" href="#📍-aof-写入过程"><span>📍 AOF 写入过程</span></a></h3><ol><li><strong>命令追加</strong>：将写命令写入 AOF 缓冲区（内存）。</li><li><strong>同步写磁盘</strong>：由 <code>appendfsync</code> 决定写盘策略： <ul><li><code>always</code>：每条命令都写盘（最安全，最慢）。</li><li><code>everysec</code>（默认）：每秒写盘一次（最多丢 1 秒数据）。</li><li><code>no</code>：由操作系统决定（写入频率不可控）。</li></ul></li></ol><h3 id="📍-aof-文件过大-→-重写-rewrite" tabindex="-1"><a class="header-anchor" href="#📍-aof-文件过大-→-重写-rewrite"><span>📍 AOF 文件过大 → 重写（rewrite）</span></a></h3><ul><li>长期运行，AOF 文件会越来越大（包含所有历史命令）。</li><li>Redis 提供 <strong>重写机制</strong>： <ol><li>Fork 一个子进程，扫描内存中的数据。</li><li>生成一份新的 AOF 文件（用最少的命令集表示当前数据）。</li><li>新文件写好后替换旧的 AOF。</li></ol></li></ul><h3 id="📍-触发方式-1" tabindex="-1"><a class="header-anchor" href="#📍-触发方式-1"><span>📍 触发方式</span></a></h3><ul><li><p>手动：<code>BGREWRITEAOF</code>。</p></li><li><p>自动：根据配置触发，比如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>auto-aof-rewrite-min-size 64mb</span></span>
<span class="line"><span>auto-aof-rewrite-percentage 100</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>含义：AOF 文件大小超过 64MB 且比上次重写后大一倍时，触发重写。</p></li></ul><h3 id="📍-优缺点-1" tabindex="-1"><a class="header-anchor" href="#📍-优缺点-1"><span>📍 优缺点</span></a></h3><p>✅ 优点：</p><ul><li>数据更安全（丢失数据少，最多 1 秒）。</li><li>AOF 日志可读性强，容易做数据恢复。 ❌ 缺点：</li><li>文件比 RDB 大，恢复速度慢。</li><li>重写过程也需要 fork 子进程，占用内存。</li></ul><hr><h2 id="_3️⃣-rdb-aof-混合持久化-redis-4-0" tabindex="-1"><a class="header-anchor" href="#_3️⃣-rdb-aof-混合持久化-redis-4-0"><span>3️⃣ RDB + AOF 混合持久化（Redis 4.0+）</span></a></h2><h3 id="📍-原理-2" tabindex="-1"><a class="header-anchor" href="#📍-原理-2"><span>📍 原理</span></a></h3><ul><li><strong>AOF 重写时</strong>，不再只写纯命令，而是在新 AOF 文件的开头写一份 <strong>RDB 快照</strong>。</li><li>后续再追加增量命令。</li></ul><p>这样恢复时：</p><ol><li>先加载 RDB 部分（快速恢复大部分数据）。</li><li>再回放后续 AOF 命令（保证最新数据）。</li></ol><h3 id="📍-优缺点-2" tabindex="-1"><a class="header-anchor" href="#📍-优缺点-2"><span>📍 优缺点</span></a></h3><p>✅ 优点：</p><ul><li>结合 RDB（快速恢复）+ AOF（数据更完整）的优势。</li><li>适合生产环境。 ❌ 缺点：</li><li>文件格式更复杂，兼容性要求高。</li></ul><hr><h2 id="_4️⃣-性能与应用场景对比" tabindex="-1"><a class="header-anchor" href="#_4️⃣-性能与应用场景对比"><span>4️⃣ 性能与应用场景对比</span></a></h2><table><thead><tr><th>持久化方式</th><th>数据安全性</th><th>文件大小</th><th>恢复速度</th><th>性能影响</th><th>应用场景</th></tr></thead><tbody><tr><td>RDB</td><td>中等（丢最后一次快照后数据）</td><td>小</td><td>快</td><td>低（偶尔 BGSAVE）</td><td>全量备份、灾难恢复</td></tr><tr><td>AOF</td><td>高（秒级丢失）</td><td>大</td><td>慢</td><td>中等（频繁写日志）</td><td>高可靠性要求（订单、支付）</td></tr><tr><td>RDB+AOF</td><td>高（秒级丢失）</td><td>中等</td><td>较快</td><td>中等</td><td>生产环境推荐</td></tr></tbody></table><hr><h2 id="_5️⃣-最佳实践建议" tabindex="-1"><a class="header-anchor" href="#_5️⃣-最佳实践建议"><span>5️⃣ 最佳实践建议</span></a></h2><ol><li><strong>生产环境推荐</strong>： 开启 <strong>RDB + AOF 混合持久化</strong>，兼顾性能与安全。</li><li><strong>仅做缓存</strong>： 可以关闭持久化，完全依赖内存（比如 CDN 缓存）。</li><li><strong>大内存实例（&gt;50GB）</strong>： <ul><li>使用 <code>BGSAVE</code> / <code>BGREWRITEAOF</code> 时注意 fork 开销。</li><li>推荐使用 <code>lazy-free</code> 异步释放内存。</li></ul></li><li><strong>定期备份 RDB 文件</strong>： <ul><li>即使启用了 AOF，也建议周期性备份 RDB，用于灾备。</li></ul></li></ol><hr><p>📌 <strong>一句话总结</strong>：</p><ul><li><strong>RDB</strong>：轻量、快速，但不实时。</li><li><strong>AOF</strong>：更安全，但更重。</li><li><strong>RDB + AOF</strong>：性能与安全的最佳平衡，是 <strong>生产环境推荐方案</strong>。</li></ul><h1 id="📊-redis-持久化机制流程图" tabindex="-1"><a class="header-anchor" href="#📊-redis-持久化机制流程图"><span>📊 Redis 持久化机制流程图</span></a></h1><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>                ┌───────────────────┐</span></span>
<span class="line"><span>                │   Redis 内存数据   │</span></span>
<span class="line"><span>                └─────────┬─────────┘</span></span>
<span class="line"><span>                          │</span></span>
<span class="line"><span>          ┌───────────────┼────────────────┐</span></span>
<span class="line"><span>          │                               │</span></span>
<span class="line"><span>   ┌──────▼───────┐               ┌───────▼───────┐</span></span>
<span class="line"><span>   │     RDB      │               │      AOF      │</span></span>
<span class="line"><span>   └──────┬───────┘               └───────┬───────┘</span></span>
<span class="line"><span>          │                               │</span></span>
<span class="line"><span>   ┌──────▼───────────────┐       ┌───────▼─────────────────────┐</span></span>
<span class="line"><span>   │ fork 子进程           │       │ 写命令 → AOF 缓冲区          │</span></span>
<span class="line"><span>   │ 写 dump.rdb 快照文件  │       │ appendfsync → 写入磁盘      │</span></span>
<span class="line"><span>   └───────────────┬──────┘       └───────────┬─────────────────┘</span></span>
<span class="line"><span>                   │                          │</span></span>
<span class="line"><span>          ┌────────▼────────┐         ┌───────▼───────────────┐</span></span>
<span class="line"><span>          │   恢复时直接载入 │         │ AOF 重写（fork 子进程） │</span></span>
<span class="line"><span>          │   dump.rdb 文件 │         │ 生成新 appendonly.aof  │</span></span>
<span class="line"><span>          └─────────────────┘         └───────────────────────┘</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>                   ┌─────────────────────┐</span></span>
<span class="line"><span>                   │   RDB + AOF 混合    │</span></span>
<span class="line"><span>                   └─────────┬──────────┘</span></span>
<span class="line"><span>                             │</span></span>
<span class="line"><span>        ┌────────────────────▼────────────────────┐</span></span>
<span class="line"><span>        │ AOF 文件 = RDB 快照 + 后续写命令         │</span></span>
<span class="line"><span>        │ 恢复时：先加载 RDB 部分，再回放命令      │</span></span>
<span class="line"><span>        └────────────────────────────────────────┘</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>这样你可以一眼看到：</p><ul><li><strong>RDB</strong>：fork 子进程写快照，恢复快但可能丢数据。</li><li><strong>AOF</strong>：命令追加日志，数据更安全，但恢复慢。</li><li><strong>混合模式</strong>：先存 RDB 快照，再存命令，兼顾性能与安全。</li></ul>`,50)]))}const p=n(l,[["render",d]]),o=JSON.parse('{"path":"/nosqldb/redises/qbr291jr/","title":"Redis 持久化详解","lang":"zh-CN","frontmatter":{"title":"Redis 持久化详解","createTime":"2025/08/26 13:12:11","permalink":"/nosqldb/redises/qbr291jr/"},"readingTime":{"minutes":4.22,"words":1267},"git":{"createdTime":1756736713000},"filePathRelative":"notes/nosqldb/redises/Redis持久化详解.md","headers":[]}');export{p as comp,o as data};
