import{a as e,c as a,b as n,o as c}from"./app-ZQgO6-gU.js";const l={};function i(t,o){return c(),a("div",null,o[0]||(o[0]=[n('<h3 id="_1、锁可以锁在哪里" tabindex="-1"><a class="header-anchor" href="#_1、锁可以锁在哪里"><span>1、锁可以锁在哪里？</span></a></h3><p>Java 为程序加锁主要有两种方式：synchronized 与 Lock。</p><p><strong>synchronized 可以修饰的范围</strong>：</p><ul><li><strong>非静态方法</strong>：加对象锁（每个对象实例一个锁）</li><li><strong>静态方法</strong>：加类锁（类级别锁，所有对象共享）</li><li><strong>代码块</strong>：可以选择锁对象或类锁</li></ul><p><strong>Lock 接口使用方法</strong>：</p><ul><li><code>lock()</code>：加锁</li><li><code>unlock()</code>：释放锁</li></ul><p>Lock 相比 synchronized 更灵活，可以实现公平锁、中断锁等高级功能。</p><h3 id="_2、怎么利用反射获取类中的对象" tabindex="-1"><a class="header-anchor" href="#_2、怎么利用反射获取类中的对象"><span>2、怎么利用反射获取类中的对象？</span></a></h3><ol><li>获取 Class 对象：<code>Class&lt;?&gt; clazz = Class.forName(&quot;类名&quot;);</code> 或 <code>类名.class</code></li><li>获取构造方法：<code>Constructor&lt;?&gt; constructor = clazz.getConstructor(参数类型列表);</code></li><li>创建对象实例：<code>Object obj = constructor.newInstance(参数列表);</code></li></ol><h3 id="_3、http-和-https-区别" tabindex="-1"><a class="header-anchor" href="#_3、http-和-https-区别"><span>3、HTTP 和 HTTPS 区别</span></a></h3><ol><li><strong>传输安全性</strong>：HTTP 明文传输，HTTPS 加密传输（SSL/TLS）</li><li><strong>证书要求</strong>：HTTPS 需要 CA 颁发证书</li><li><strong>连接速度</strong>：HTTP 建立连接快，HTTPS 因 SSL 握手慢</li><li><strong>端口不同</strong>：HTTP 80，HTTPS 443</li><li><strong>服务器资源消耗</strong>：HTTPS 相比 HTTP 更高，因加密解密操作</li></ol><h3 id="_4、tcp-ip-协议" tabindex="-1"><a class="header-anchor" href="#_4、tcp-ip-协议"><span>4、TCP/IP 协议</span></a></h3><ol><li>TCP/IP 是协议簇，开放标准，独立于硬件和操作系统</li><li>广泛应用于局域网、广域网和互联网</li><li>使用统一的网络地址方案，每台设备有唯一 IP</li><li>提供高可靠性服务，确保数据正确传输</li></ol><h3 id="_5、aop-和-ioc-的应用" tabindex="-1"><a class="header-anchor" href="#_5、aop-和-ioc-的应用"><span>5、AOP 和 IOC 的应用</span></a></h3><p><strong>IOC（控制反转）</strong>：主要通过 BeanFactory 接口及其实现类来实现，例如 Spring 容器管理 Bean 的生命周期和依赖注入</p><p><strong>AOP（面向切面编程）</strong>：应用于日志记录、权限验证、事务管理等横切关注点</p><h3 id="_6、spring-中-bean-是否线程安全" tabindex="-1"><a class="header-anchor" href="#_6、spring-中-bean-是否线程安全"><span>6、Spring 中 Bean 是否线程安全</span></a></h3><ol><li><strong>单例 Bean（默认）</strong>：所有线程共享一个实例，如果 Bean 无状态，则线程安全；有状态 Bean 可能出现线程安全问题，可使用 ThreadLocal 或加锁</li><li><strong>原型 Bean（scope=&quot;prototype&quot;）</strong>：每次创建新实例，线程之间互不共享，自然线程安全</li></ol><h3 id="_7、maven-中-package-与-install-的区别" tabindex="-1"><a class="header-anchor" href="#_7、maven-中-package-与-install-的区别"><span>7、Maven 中 package 与 install 的区别</span></a></h3><ul><li><strong>package</strong>：编译项目并打包成 jar/war 文件，放在 target 目录</li><li><strong>install</strong>：将 package 生成的包安装到本地仓库（~/.m2/repository），供其他项目依赖</li></ul><h3 id="_8、常用设计模式" tabindex="-1"><a class="header-anchor" href="#_8、常用设计模式"><span>8、常用设计模式</span></a></h3><ol><li>单例模式（Singleton）</li><li>工厂模式（Factory）</li><li>抽象工厂模式（Abstract Factory）</li><li>观察者模式（Observer）</li><li>代理模式（Proxy）</li><li>策略模式（Strategy）</li><li>模板方法模式（Template Method）</li></ol><h3 id="_9、简单工厂与抽象工厂区别" tabindex="-1"><a class="header-anchor" href="#_9、简单工厂与抽象工厂区别"><span>9、简单工厂与抽象工厂区别</span></a></h3><ul><li><strong>简单工厂</strong>：由一个工厂类根据参数创建不同对象，工厂类固定</li><li><strong>抽象工厂</strong>：提供接口创建一系列相关或相互依赖的对象，工厂接口可多种实现</li></ul><h3 id="_10、常用-linux-基本操作命令" tabindex="-1"><a class="header-anchor" href="#_10、常用-linux-基本操作命令"><span>10、常用 Linux 基本操作命令</span></a></h3><ul><li>文件与目录：<code>ls</code>, <code>cd</code>, <code>mkdir</code>, <code>rm</code>, <code>cp</code>, <code>mv</code></li><li>文件查看：<code>cat</code>, <code>less</code>, <code>more</code>, <code>tail</code>, <code>head</code></li><li>权限管理：<code>chmod</code>, <code>chown</code></li><li>查找：<code>find</code>, <code>grep</code></li><li>进程管理：<code>ps</code>, <code>top</code>, <code>kill</code></li><li>压缩与解压：<code>tar</code>, <code>gzip</code>, <code>zip</code>, <code>unzip</code></li><li>网络操作：<code>ping</code>, <code>netstat</code>, <code>ifconfig</code>, <code>curl</code>, <code>wget</code></li></ul><h3 id="_11、concurrenthashmap-扩容机制" tabindex="-1"><a class="header-anchor" href="#_11、concurrenthashmap-扩容机制"><span>11、ConcurrentHashMap 扩容机制</span></a></h3><ol><li>ConcurrentHashMap 采用分段锁（JDK1.7）或 Node 数组 + CAS + synchronized（JDK1.8）</li><li>当链表长度超过阈值时（TREEIFY_THRESHOLD），链表会转化为红黑树</li><li>扩容时，会创建新数组，将原数组中的元素重新哈希并迁移到新数组，迁移过程中使用 CAS 保证线程安全</li></ol>',28)]))}const s=e(l,[["render",i]]),d=JSON.parse('{"path":"/bigcompany/wm34b8w8/","title":"软通动力-Java工程师","lang":"zh-CN","frontmatter":{"title":"软通动力-Java工程师","createTime":"2025/08/21 14:10:05","permalink":"/bigcompany/wm34b8w8/"},"readingTime":{"minutes":2.82,"words":846},"git":{"createdTime":1756736713000},"filePathRelative":"notes/bigcompany/company/软通动力-Java工程师.md","headers":[]}');export{s as comp,d as data};
