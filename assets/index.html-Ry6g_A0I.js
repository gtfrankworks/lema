import{a as n,c as e,b as a,o as i}from"./app-ZQgO6-gU.js";const d="/lema/images/mysql/2.png",c="/lema/images/mysql/3.png",l="/lema/images/mysql/4.png",p="/lema/images/mysql/5.png",o="/lema/images/mysql/6.png",t={};function r(m,s){return i(),e("div",null,s[0]||(s[0]=[a('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>数据库优化是一个任重而道远的任务，想要做优化必须深入理解数据库的各种特性。在开发过程中我们经常会遇到一些原因很简单但造成的后果却很严重的疑难杂症，这类问题往往还不容易定位，排查费时费力最后发现是一个很小的疏忽造成的，又或者是因为不了解某个技术特性产生的。</p><p>于数据库层面，最常见的恐怕就是索引失效了，且一开始因为数据量小还不易被发现。但随着业务的拓展数据量的提升，性能问题慢慢的就体现出来了，处理不及时还很容易造成雪球效应，最终导致数据库卡死甚至瘫痪。造成索引失效的原因可能有很多种，相关技术博客已经有太多了，今天我要记录的是<strong>隐式转换造成的索引失效</strong>。</p><h2 id="数据准备" tabindex="-1"><a class="header-anchor" href="#数据准备"><span>数据准备</span></a></h2><p>首先使用存储过程生成 1000 万条测试数据， 测试表一共建立了 7 个字段（包括主键），<code>num1</code>和<code>num2</code>保存的是和<code>ID</code>一样的顺序数字，其中<code>num2</code>是字符串类型。 <code>type1</code>和<code>type2</code>保存的都是主键对 5 的取模，目的是模拟实际应用中常用类似 type 类型的数据，但是<code>type2</code>是没有建立索引的。 <code>str1</code>和<code>str2</code>都是保存了一个 20 位长度的随机字符串，<code>str1</code>不能为<code>NULL</code>，<code>str2</code>允许为<code>NULL</code>，相应的生成测试数据的时候我也会在<code>str2</code>字段生产少量<code>NULL</code>值（每 100 条数据产生一个<code>NULL</code>值）。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>-- 创建测试数据表</span></span>\n<span class="line"><span>DROP TABLE IF EXISTS test1;</span></span>\n<span class="line"><span>CREATE TABLE `test1` (</span></span>\n<span class="line"><span>    `id` int(11) NOT NULL,</span></span>\n<span class="line"><span>    `num1` int(11) NOT NULL DEFAULT &#39;0&#39;,</span></span>\n<span class="line"><span>    `num2` varchar(11) NOT NULL DEFAULT &#39;&#39;,</span></span>\n<span class="line"><span>    `type1` int(4) NOT NULL DEFAULT &#39;0&#39;,</span></span>\n<span class="line"><span>    `type2` int(4) NOT NULL DEFAULT &#39;0&#39;,</span></span>\n<span class="line"><span>    `str1` varchar(100) NOT NULL DEFAULT &#39;&#39;,</span></span>\n<span class="line"><span>    `str2` varchar(100) DEFAULT NULL,</span></span>\n<span class="line"><span>    PRIMARY KEY (`id`),</span></span>\n<span class="line"><span>    KEY `num1` (`num1`),</span></span>\n<span class="line"><span>    KEY `num2` (`num2`),</span></span>\n<span class="line"><span>    KEY `type1` (`type1`),</span></span>\n<span class="line"><span>    KEY `str1` (`str1`),</span></span>\n<span class="line"><span>    KEY `str2` (`str2`)</span></span>\n<span class="line"><span>) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span></span>\n<span class="line"><span>-- 创建存储过程</span></span>\n<span class="line"><span>DROP PROCEDURE IF EXISTS pre_test1;</span></span>\n<span class="line"><span>DELIMITER //</span></span>\n<span class="line"><span>CREATE PROCEDURE `pre_test1`()</span></span>\n<span class="line"><span>BEGIN</span></span>\n<span class="line"><span>    DECLARE i INT DEFAULT 0;</span></span>\n<span class="line"><span>    SET autocommit = 0;</span></span>\n<span class="line"><span>    WHILE i &lt; 10000000 DO</span></span>\n<span class="line"><span>        SET i = i + 1;</span></span>\n<span class="line"><span>        SET @str1 = SUBSTRING(MD5(RAND()),1,20);</span></span>\n<span class="line"><span>        -- 每100条数据str2产生一个null值</span></span>\n<span class="line"><span>        IF i % 100 = 0 THEN</span></span>\n<span class="line"><span>            SET @str2 = NULL;</span></span>\n<span class="line"><span>        ELSE</span></span>\n<span class="line"><span>            SET @str2 = @str1;</span></span>\n<span class="line"><span>        END IF;</span></span>\n<span class="line"><span>        INSERT INTO test1 (`id`, `num1`, `num2`,</span></span>\n<span class="line"><span>        `type1`, `type2`, `str1`, `str2`)</span></span>\n<span class="line"><span>        VALUES (CONCAT(&#39;&#39;, i), CONCAT(&#39;&#39;, i),</span></span>\n<span class="line"><span>        CONCAT(&#39;&#39;, i), i%5, i%5, @str1, @str2);</span></span>\n<span class="line"><span>        -- 事务优化，每一万条数据提交一次事务</span></span>\n<span class="line"><span>        IF i % 10000 = 0 THEN</span></span>\n<span class="line"><span>            COMMIT;</span></span>\n<span class="line"><span>        END IF;</span></span>\n<span class="line"><span>    END WHILE;</span></span>\n<span class="line"><span>END;</span></span>\n<span class="line"><span>// DELIMITER ;</span></span>\n<span class="line"><span>-- 执行存储过程</span></span>\n<span class="line"><span>CALL pre_test1();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数据量比较大，还涉及使用<code>MD5</code>生成随机字符串，所以速度有点慢，稍安勿躁，耐心等待即可。</p><p>1000 万条数据，我用了 33 分钟才跑完（实际时间跟你电脑硬件配置有关）。这里贴几条生成的数据，大致长这样。</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="sql-测试" tabindex="-1"><a class="header-anchor" href="#sql-测试"><span>SQL 测试</span></a></h2><p>先来看这组 SQL，一共四条，我们的测试数据表<code>num1</code>是<code>int</code>类型，<code>num2</code>是<code>varchar</code>类型，但是存储的数据都是跟主键<code>id</code>一样的顺序数字，两个字段都建立有索引。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>1: SELECT * FROM `test1` WHERE num1 = 10000;</span></span>\n<span class="line"><span>2: SELECT * FROM `test1` WHERE num1 = &#39;10000&#39;;</span></span>\n<span class="line"><span>3: SELECT * FROM `test1` WHERE num2 = 10000;</span></span>\n<span class="line"><span>4: SELECT * FROM `test1` WHERE num2 = &#39;10000&#39;;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这四条 SQL 都是有针对性写的，12 查询的字段是 int 类型，34 查询的字段是<code>varchar</code>类型。12 或 34 查询的字段虽然都相同，但是一个条件是数字，一个条件是用引号引起来的字符串。这样做有什么区别呢？先不看下边的测试结果你能猜出这四条 SQL 的效率顺序吗？</p><p>经测试这四条 SQL 最后的执行结果却相差很大，其中 124 三条 SQL 基本都是瞬间出结果，大概在 0.001<s>0.005 秒，在千万级的数据量下这样的结果可以判定这三条 SQL 性能基本没差别了。但是第三条 SQL，多次测试耗时基本在 4.5</s>4.8 秒之间。</p><p>为什么 34 两条 SQL 效率相差那么大，但是同样做对比的 12 两条 SQL 却没什么差别呢？查看一下执行计划，下边分别 1234 条 SQL 的执行计划数据：</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，124 三条 SQL 都能使用到索引，连接类型都为<code>ref</code>，扫描行数都为 1，所以效率非常高。再看看第三条 SQL，没有用上索引，所以为全表扫描，<code>rows</code>直接到达 1000 万了，所以性能差别才那么大。</p><p>仔细观察你会发现，34 两条 SQL 查询的字段<code>num2</code>是<code>varchar</code>类型的，查询条件等号右边加引号的第 4 条 SQL 是用到索引的，那么是查询的数据类型和字段数据类型不一致造成的吗？如果是这样那 12 两条 SQL 查询的字段<code>num1</code>是<code>int</code>类型，但是第 2 条 SQL 查询条件右边加了引号为什么还能用上索引呢。</p><p>查阅 MySQL 相关文档发现是隐式转换造成的，看一下官方的描述：</p><blockquote><p>官方文档：<a href="https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html?spm=5176.100239.blogcont47339.5.1FTben" target="_blank" rel="noopener noreferrer">12.2 Type Conversion in Expression Evaluation</a></p><p>当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。某些转换是隐式发生的。例如，MySQL 会根据需要自动将字符串转换为数字，反之亦然。以下规则描述了比较操作的转换方式：</p><ol><li>两个参数至少有一个是<code>NULL</code>时，比较的结果也是<code>NULL</code>，特殊的情况是使用<code>&lt;=&gt;</code>对两个<code>NULL</code>做比较时会返回<code>1</code>，这两种情况都不需要做类型转换</li><li>两个参数都是字符串，会按照字符串来比较，不做类型转换</li><li>两个参数都是整数，按照整数来比较，不做类型转换</li><li>十六进制的值和非数字做比较时，会被当做二进制串</li><li>有一个参数是<code>TIMESTAMP</code>或<code>DATETIME</code>，并且另外一个参数是常量，常量会被转换为<code>timestamp</code></li><li>有一个参数是<code>decimal</code>类型，如果另外一个参数是<code>decimal</code>或者整数，会将整数转换为<code>decimal</code>后进行比较，如果另外一个参数是浮点数，则会把<code>decimal</code>转换为浮点数进行比较</li><li><strong>所有其他情况下，两个参数都会被转换为浮点数再进行比较</strong></li></ol></blockquote><p>根据官方文档的描述，我们的第 23 两条 SQL 都发生了隐式转换，第 2 条 SQL 的查询条件<code>num1 = &#39;10000&#39;</code>，左边是<code>int</code>类型右边是字符串，第 3 条 SQL 相反，那么根据官方转换规则第 7 条，左右两边都会转换为浮点数再进行比较。</p><p>先看第 2 条 SQL：<code>SELECT * FROM </code>test1<code> WHERE num1 = &#39;10000&#39;;</code> <strong>左边为 int 类型</strong><code>10000</code>，转换为浮点数还是<code>10000</code>，右边字符串类型<code>&#39;10000&#39;</code>，转换为浮点数也是<code>10000</code>。两边的转换结果都是唯一确定的，所以不影响使用索引。</p><p>第 3 条 SQL：<code>SELECT * FROM </code>test1<code> WHERE num2 = 10000;</code> <strong>左边是字符串类型</strong><code>&#39;10000&#39;</code>，转浮点数为 10000 是唯一的，右边<code>int</code>类型<code>10000</code>转换结果也是唯一的。但是，因为左边是检索条件，<code>&#39;10000&#39;</code>转到<code>10000</code>虽然是唯一，但是其他字符串也可以转换为<code>10000</code>，比如<code>&#39;10000a&#39;</code>，<code>&#39;010000&#39;</code>，<code>&#39;10000&#39;</code>等等都能转为浮点数<code>10000</code>，这样的情况下，是不能用到索引的。</p><p>关于这个<strong>隐式转换</strong>我们可以通过查询测试验证一下，先插入几条数据，其中<code>num2=&#39;10000a&#39;</code>、<code>&#39;010000&#39;</code>和<code>&#39;10000&#39;</code>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>INSERT INTO `test1` (`id`, `num1`, `num2`, `type1`, `type2`, `str1`, `str2`) VALUES (&#39;10000001&#39;, &#39;10000&#39;, &#39;10000a&#39;, &#39;0&#39;, &#39;0&#39;, &#39;2df3d9465ty2e4hd523&#39;, &#39;2df3d9465ty2e4hd523&#39;);</span></span>\n<span class="line"><span>INSERT INTO `test1` (`id`, `num1`, `num2`, `type1`, `type2`, `str1`, `str2`) VALUES (&#39;10000002&#39;, &#39;10000&#39;, &#39;010000&#39;, &#39;0&#39;, &#39;0&#39;, &#39;2df3d9465ty2e4hd523&#39;, &#39;2df3d9465ty2e4hd523&#39;);</span></span>\n<span class="line"><span>INSERT INTO `test1` (`id`, `num1`, `num2`, `type1`, `type2`, `str1`, `str2`) VALUES (&#39;10000003&#39;, &#39;10000&#39;, &#39; 10000&#39;, &#39;0&#39;, &#39;0&#39;, &#39;2df3d9465ty2e4hd523&#39;, &#39;2df3d9465ty2e4hd523&#39;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后使用第三条 SQL 语句<code>SELECT * FROM </code>test1<code> WHERE num2 = 10000;</code>进行查询：</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从结果可以看到，后面插入的三条数据也都匹配上了。那么这个字符串隐式转换的规则是什么呢？为什么<code>num2=&#39;10000a&#39;</code>、<code>&#39;010000&#39;</code>和<code>&#39;10000&#39;</code>这三种情形都能匹配上呢？查阅相关资料发现规则如下：</p><ol><li><strong>不以数字开头</strong>的字符串都将转换为<code>0</code>。如<code>&#39;abc&#39;</code>、<code>&#39;a123bc&#39;</code>、<code>&#39;abc123&#39;</code>都会转化为<code>0</code>；</li><li><strong>以数字开头的</strong>字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如<code>&#39;123abc&#39;</code>会转换为<code>123</code>，<code>&#39;012abc&#39;</code>会转换为<code>012</code>也就是<code>12</code>，<code>&#39;5.3a66b78c&#39;</code>会转换为<code>5.3</code>，其他同理。</li></ol><p>现对以上规则做如下测试验证：</p><p><img src="'+p+'" alt="" loading="lazy"> 如此也就印证了之前的查询结果了。</p><p>再次写一条 SQL 查询 str1 字段：<code>SELECT * FROM </code>test1<code> WHERE str1 = 1234;</code></p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="分析和总结" tabindex="-1"><a class="header-anchor" href="#分析和总结"><span>分析和总结</span></a></h2><p>通过上面的测试我们发现 MySQL 使用操作符的一些特性：</p><ol><li>当操作符<strong>左右两边的数据类型不一致</strong>时，会发生<strong>隐式转换</strong>。</li><li>当 where 查询操作符<strong>左边为数值类型</strong>时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。</li><li>当 where 查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</li><li>字符串转换为数值类型时，非数字开头的字符串会转化为<code>0</code>，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。</li></ol><p>所以，我们在写 SQL 时一定要养成良好的习惯，查询的字段是什么类型，等号右边的条件就写成对应的类型。特别当查询的字段是字符串时，等号右边的条件一定要用引号引起来标明这是一个字符串，否则会造成索引失效触发全表扫描。</p>',37)]))}const u=n(t,[["render",r]]),g=JSON.parse('{"path":"/db/mysql/ex4liy8k/","title":"数据库优化","lang":"zh-CN","frontmatter":{"title":"数据库优化","createTime":"2025/08/25 10:23:36","permalink":"/db/mysql/ex4liy8k/"},"readingTime":{"minutes":8.32,"words":2496},"git":{"createdTime":1756736713000},"filePathRelative":"notes/db/mysql/3.md","headers":[]}');export{u as comp,g as data};
