import{a as n,c as h,b as i,e as d,d as s,w as l,f as r,r as o,o as c}from"./app-ZQgO6-gU.js";const t={};function p(u,e){const a=o("font");return c(),h("div",null,[e[3]||(e[3]=i(`<h4 id="_1-redis-是什么" tabindex="-1"><a class="header-anchor" href="#_1-redis-是什么"><span>1. Redis 是什么？</span></a></h4><p>Redis是一个开源的C语言编写、支持网络、可基于内存亦可持久化的日志型、高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。</p><ul><li>性能优秀，数据在内存中，读写速度非常快，支持并发10W QPS <ul><li>读 110000次/s</li><li>写 81000次/s</li></ul></li><li>丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等</li><li>支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载</li><li>所有操作都是原子性的，还支持对几个操作合并后的原子性</li><li>主从复制，哨兵，高可用</li><li>可以用作分布式锁</li><li>可以作为消息中间件使用，支持发布订阅</li></ul><h4 id="_2-redis-数据类型" tabindex="-1"><a class="header-anchor" href="#_2-redis-数据类型"><span>2. Redis 数据类型</span></a></h4><table><thead><tr><th>类型</th><th>特性</th><th>应用场景</th></tr></thead><tbody><tr><td>String</td><td>可以存储任何数据【字符串、整数（取值范围同长整形：64 or 32 位有符号整数）、浮点数、图片、序列化的对象、...】。<br>string类型是二进制安全的，最大能存储512M。<br>支持自增、自减操作。</td><td>...</td></tr><tr><td>Hash</td><td>存储键值对的无序散列表，微缩版Redis</td><td>存储对象属性</td></tr><tr><td>List</td><td>双向链表，增删快</td><td>消息队列</td></tr><tr><td>Set</td><td>hash表实现，元素不重复</td><td>利用唯一性，统计访问网站的所有 ip</td></tr><tr><td>Sorted Set</td><td>与 Set 相比，每个元素增加了一个 score 作为有序映射</td><td>排行榜</td></tr></tbody></table><h4 id="_3-redis-为什么使用单线程-还这么快" tabindex="-1"><a class="header-anchor" href="#_3-redis-为什么使用单线程-还这么快"><span>3. Redis 为什么使用单线程，还这么快？</span></a></h4><p>因为 Redis 完全是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了，毕竟采用多线程会有很多麻烦。</p><p>Redis 之所以快，是因为；</p><ul><li>Redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度是O(1)</li><li>数据结构简单，对数据操作也简单</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗</li><li>使用多路复用IO模型(<b>一个线程，通过记录I/O流的状态来同时管理多个I/O，可以提高服务器的吞吐能力</b>)</li></ul><h4 id="_4-redis-内存满了怎么办" tabindex="-1"><a class="header-anchor" href="#_4-redis-内存满了怎么办"><span>4. Redis 内存满了怎么办？</span></a></h4><blockquote><p>配置内存大小</p></blockquote><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># redis.conf 配置文件中配置</span></span>
<span class="line"><span>maxmemory 100mb</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 命令修改</span></span>
<span class="line"><span>~&gt; config set maxmemory 100mb</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Redis 定义了几种内存淘汰策略</p><table><thead><tr><th>策略</th><th>说明</th></tr></thead><tbody><tr><td>noeviction(默认策略)</td><td>对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</td></tr><tr><td>allkeys-lru</td><td>从所有 key 中使用 LRU 算法进行淘汰</td></tr><tr><td>volatile-lru</td><td>从设置了过期时间的 key 中使用 LRU 算法进行淘汰</td></tr><tr><td>allkeys-random</td><td>从所有 key 中随机淘汰数据</td></tr><tr><td>volatile-random</td><td>从设置了过期时间的 key 中随机淘汰</td></tr><tr><td>volatile-ttl</td><td>在设置了过期时间的 key 中，根据 key 的过期时间进行淘汰，越早过期的优先被淘汰</td></tr></tbody></table><blockquote><p>设置内存淘汰策略</p></blockquote><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># 修改 redis.conf 文件</span></span>
<span class="line"><span>maxmemory-policy allkeys-lru</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 命令修改</span></span>
<span class="line"><span>config get maxmemory-policy</span></span>
<span class="line"><span>config set max-memory-policy allkeys-lru</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,16)),d(a,{color:"#398BDE"},{default:l(()=>e[0]||(e[0]=[s("b",null,"扩展——LRU算法",-1)])),_:1,__:[0]}),e[4]||(e[4]=s("blockquote",null,[s("p",null,[r("LUR(Least Recently Used): 最近最少使用，是一种缓存置换算法。如果一个数据在最近一段时间没有被用到，那么将来被用到的可能性也很小，就可以被淘汰。 "),s("br"),s("br"),r("Reids 通过随机采样，每次随机出 5(默认，使用 maxmemory-samples 10修改) 个 key，从里面淘汰掉最近最少使用的 key。")])],-1)),d(a,{color:"#398BDE"},{default:l(()=>e[1]||(e[1]=[s("b",null,"扩展——LFU算法(Redis4.0)",-1)])),_:1,__:[1]}),e[5]||(e[5]=i('<blockquote><p>LFU(Least Frequently Used): 最不常用，根据 key 的最近被访问的频率进行淘汰(即保留热点数据)。</p></blockquote><p>LRU 共有两种策略:</p><ul><li><p>volatite-lfu</p><p>在设置了过期时间的 key 中使用 LFU 算法淘汰数据</p></li><li><p>allkeys-lfu</p><p>在所有 key 中使用 LFU 算法淘汰数据</p></li></ul><h4 id="_4-redis-相对于-memcache-的优势" tabindex="-1"><a class="header-anchor" href="#_4-redis-相对于-memcache-的优势"><span>4. Redis 相对于 Memcache 的优势？</span></a></h4><ul><li>支持持久化</li><li>支持丰富的数据类型</li></ul><h4 id="_5-memcached-与-redis-对比" tabindex="-1"><a class="header-anchor" href="#_5-memcached-与-redis-对比"><span>5.Memcached 与 Redis 对比</span></a></h4><ul><li><p>性能</p><ul><li>两者性能都比较高</li></ul></li><li><p>数据类型</p><ul><li>Memcached 数据结构单一</li><li>Redis 非常丰富</li></ul></li><li><p>内存大小</p><ul><li>Redis 在 2.0 后增加了自己的 VM 特性，突破物理内存的限制。</li><li>Memcached 可以修改最大可用内存的大小来管理内存，采用 LRU 算法。</li></ul></li><li><p>持久化</p><ul><li>Redis 依赖快照、AOF 进行持久化。但 AOF 在增强可靠性的同时，对性能也有所影响。</li><li>Memcached 不支持持久化、通常用来做缓存，以提升性能。</li></ul></li><li><p>value 数据大小</p><ul><li>Redis 的 value 最大限制是 1GB。</li><li>Memcached 只能保存 1MB 以内的数据。</li></ul></li><li><p>数据一致性（事务支持）</p><ul><li>Memcached 在并发场景下用 CAS 保证一致性。</li><li>Redis 对事务支持比较弱，只能保证事务中的每个操作连续执行。</li></ul></li><li><p>应用场景</p><ul><li>Reids 适合数据量较少、性能和运算要求高的场景。</li><li>Memcached 适合提升性能的场景。适合读多写少，如果数据量比较大，则可以采用分片的方式来解决。</li></ul></li></ul><h4 id="_6-一个字符串类型的值能存储最大容量是多少" tabindex="-1"><a class="header-anchor" href="#_6-一个字符串类型的值能存储最大容量是多少"><span>6.一个字符串类型的值能存储最大容量是多少？</span></a></h4><p>512MB</p><h4 id="_7-redis-的持久化机制是什么-各自的优缺点" tabindex="-1"><a class="header-anchor" href="#_7-redis-的持久化机制是什么-各自的优缺点"><span>7.Redis 的持久化机制是什么？各自的优缺点？</span></a></h4><blockquote><p>RDB</p></blockquote><ul><li><p><strong>优点</strong>：</p></li><li><ul><li>（1）<code>RDB</code>会生成多个数据文件，每个数据文件都代表了某一个时刻中<code>redis</code>的数据，这种多个数据文件的方式，非常适合做<strong>冷备</strong>，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说<code>Amazon</code>的<code>S3</code>云服务上去，在国内可以是阿里云的<code>ODPS</code>分布式存储上，以预定好的备份策略来定期备份<code>redis</code>中的数据</li><li>（2）<code>RDB</code>对<code>redis</code>对外提供的读写服务，影响非常小，可以让<code>redis</code>保持高性能，因为<code>redis</code>主进程只需要<code>fork</code>一个子进程，让子进程执行磁盘<code>IO</code>操作来进行<code>RDB</code>持久化即可</li><li>（3）相对于<code>AOF</code>持久化机制来说，直接基于<code>RDB</code>数据文件来重启和恢复<code>redis</code>进程，更加快速</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>1）如果想要在<code>redis</code>故障时，尽可能少的丢失数据，那么<code>RDB</code>没有<code>AOF</code>好。一般来说，<code>RDB</code>数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦<code>redis</code>进程宕机，那么会丢失最近5分钟的数据</li><li>（2）<code>RDB</code>每次在<code>fork</code>子进程来执行<code>RDB</code>快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒</li></ul></li></ul><blockquote><p>AOF</p></blockquote><ul><li><p><strong>优点</strong>：</p></li><li><ul><li>（1）<code>AOF</code>可以更好的保护数据不丢失，一般<code>AOF</code>会每隔1秒，通过一个后台线程执行一次<code>fsync</code>操作，最多丢失1秒钟的数据</li><li>（2）<code>AOF</code>日志文件以<code>append-only</code>模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修复</li><li>（3）<code>AOF</code>日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。因为在<code>rewrite log</code>的时候，会对其中的指导进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的<code>merge</code>后的日志文件<code>ready</code>的时候，再交换新老日志文件即可。</li><li>（4）<code>AOF</code>日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用<code>flushall</code>命令清空了所有数据，只要这个时候后台<code>rewrite</code>还没有发生，那么就可以立即拷贝<code>AOF</code>文件，将最后一条<code>flushall</code>命令给删了，然后再将该<code>AOF</code>文件放回去，就可以通过恢复机制，自动恢复所有数据</li></ul></li><li><p><strong>缺点</strong>：</p></li><li><ul><li>（1）对于同一份数据来说，<code>AOF</code>日志文件通常比<code>RDB</code>数据快照文件更大</li><li>（2）<code>AOF</code>开启后，支持的写<code>QPS</code>会比<code>RDB</code>支持的写<code>QPS</code>低，因为<code>AOF</code>一般会配置成每秒<code>fsync</code>一次日志文件，当然，每秒一次<code>fsync</code>，性能也还是很高的</li><li>（3）以前<code>AOF</code>发生过bug，就是通过<code>AOF</code>记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似<code>AOF</code>这种较为复杂的基于命令日志<code>/merge/</code>回放的方式，比基于<code>RDB</code>每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有bug。不过<code>AOF</code>就是为了避免<code>rewrite</code>过程导致的bug，因此每次<code>rewrite</code>并不是基于旧的指令日志进行merge的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</li></ul></li><li></li></ul><h4 id="_8-redis-常见性能问题和解决方案有哪些" tabindex="-1"><a class="header-anchor" href="#_8-redis-常见性能问题和解决方案有哪些"><span>8.Redis 常见性能问题和解决方案有哪些?</span></a></h4><p>Redis 常见的性能问题主要是开启持久化功能的情况下引起的，比如 RDB 持久化对 CPU 资源的占用，如果这期间写请求很多还触发了 rehash 扩容操作，由于 Copy-on-write 机制，还会造成大量的内存页拷贝，这就会造成 Redis 性能降低。建议不要开启 RDB 或者主节点不开启，主从复制触发的 RDB 无法避免但可以尽量在写请求少的时候触发主从复制，不要让主节点挂载太多从节点，不要在一台机器上部署多个 redis 实例。</p><p>RDB 期间，写命令会存在复制积压缓冲区，如果缓冲区不够用（大量写请求），就会陷入一直 BGSAVE 的死循环，这种情况需要调整复制积压缓冲区的大小。</p><p>AOF 过于频繁（每条命令都保存）也会影响性能，一般设置 1 s 一次；AOF 文件过大还会影响 master 重启恢复的速度；AOF 重写对 CPU 和内存的占用也很大，也会影响性能。</p><p>总之 master 节点不建议开启持久化功能，一般从节点开启 AOF 每秒一次就行，从节点不要太多，避免复制风暴（多台从节点同时复制占用资源），最后就是网速问题，主从节点最好部署在同一局域网。</p><h4 id="_9-redis-为什么会读到过期数据" tabindex="-1"><a class="header-anchor" href="#_9-redis-为什么会读到过期数据"><span>9.Redis 为什么会读到过期数据？</span></a></h4><p>主要是由 Redis 的删除策略导致：</p><ul><li><strong>惰性删除</strong>：master 节点每次读取命令时都会检查键是否超时，如果超时则执行 del 命令删除键对象，之后异步把 del 命令发送给 slave 节点，这样可以保证数据复制的一致性，<strong>slave 节点是永远不会主动去删除超时数据</strong>的。</li><li><strong>定时删除</strong>：Redis 的 master 节点在内部定时任务，会循环采样一定数量的键，当发现采样的键过期时，会执行 del 命令，之后再同步给 slave节点，<strong>采样速度跟不上数据过期速度</strong>。</li><li><strong>主动删除</strong>：当前已用内存<strong>超过 maxMemory 限定时，才会触发主动清理策略</strong>。主动删除的前提是设置了 maxMemory 的值。</li></ul><p><strong>根本原因就是 slave 节点不能主动 delete 过期 key。</strong></p><blockquote><p>Redis 3.2 以经解决了 Redis 删除策略导致的过期数据（slave 节点读取数据之前会检查过期时间来决定是否返回数据）。</p></blockquote><h4 id="_10-为什么-redis-需要把所有数据放到内存中" tabindex="-1"><a class="header-anchor" href="#_10-为什么-redis-需要把所有数据放到内存中"><span>10.为什么 Redis 需要把所有数据放到内存中？</span></a></h4><p>避免磁盘 IO，提升读写性能</p><h4 id="_11-redis-的同步机制了解么" tabindex="-1"><a class="header-anchor" href="#_11-redis-的同步机制了解么"><span>11.Redis 的同步机制了解么？</span></a></h4><h4 id="_12-pipeline-有什么好处-为什么要用-pipeline" tabindex="-1"><a class="header-anchor" href="#_12-pipeline-有什么好处-为什么要用-pipeline"><span>12.Pipeline 有什么好处，为什么要用 Pipeline？</span></a></h4><p>减少网络开销，一条一条命令与 redis 进行交互和多条命令一次性提交给 redis，肯定是后者更快。</p><h4 id="_13-是否使用过-redis-集群-集群的原理是什么" tabindex="-1"><a class="header-anchor" href="#_13-是否使用过-redis-集群-集群的原理是什么"><span>13.是否使用过 Redis 集群，集群的原理是什么？</span></a></h4><h4 id="_14-redis-集群方案什么情况下会导致整个集群不可用" tabindex="-1"><a class="header-anchor" href="#_14-redis-集群方案什么情况下会导致整个集群不可用"><span>14.Redis 集群方案什么情况下会导致整个集群不可用？</span></a></h4><h4 id="_15-redis-支持的-java-客户端都有哪些-官方推荐用哪个" tabindex="-1"><a class="header-anchor" href="#_15-redis-支持的-java-客户端都有哪些-官方推荐用哪个"><span>15.Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？</span></a></h4><h4 id="_16-jedis-与-redisson-对比有什么优缺点" tabindex="-1"><a class="header-anchor" href="#_16-jedis-与-redisson-对比有什么优缺点"><span>16.Jedis 与 Redisson 对比有什么优缺点？</span></a></h4><h4 id="_17-redis-如何设置密码及验证密码" tabindex="-1"><a class="header-anchor" href="#_17-redis-如何设置密码及验证密码"><span>17.Redis 如何设置密码及验证密码？</span></a></h4><h4 id="_18-说说-redis-哈希槽的概念" tabindex="-1"><a class="header-anchor" href="#_18-说说-redis-哈希槽的概念"><span>18.说说 Redis 哈希槽的概念？</span></a></h4><h4 id="_19-redis-集群的主从复制模型是怎样的" tabindex="-1"><a class="header-anchor" href="#_19-redis-集群的主从复制模型是怎样的"><span>19.Redis 集群的主从复制模型是怎样的？</span></a></h4><h4 id="_20-redis-集群会有写操作丢失吗-为什么" tabindex="-1"><a class="header-anchor" href="#_20-redis-集群会有写操作丢失吗-为什么"><span>20.Redis 集群会有写操作丢失吗？为什么？</span></a></h4><h4 id="_21-redis-集群之间是如何复制的" tabindex="-1"><a class="header-anchor" href="#_21-redis-集群之间是如何复制的"><span>21.Redis 集群之间是如何复制的？</span></a></h4><h4 id="_22-redis-集群最大节点个数是多少" tabindex="-1"><a class="header-anchor" href="#_22-redis-集群最大节点个数是多少"><span>22.Redis 集群最大节点个数是多少？</span></a></h4><h4 id="_23-redis-集群如何选择数据库" tabindex="-1"><a class="header-anchor" href="#_23-redis-集群如何选择数据库"><span>23.Redis 集群如何选择数据库？</span></a></h4><h4 id="_24-怎么测试-redis-的连通性" tabindex="-1"><a class="header-anchor" href="#_24-怎么测试-redis-的连通性"><span>24.怎么测试 Redis 的连通性？</span></a></h4><h4 id="_25-怎么理解-redis-事务" tabindex="-1"><a class="header-anchor" href="#_25-怎么理解-redis-事务"><span>25.怎么理解 Redis 事务？</span></a></h4><h4 id="_26-redis-事务相关的命令有哪几个" tabindex="-1"><a class="header-anchor" href="#_26-redis-事务相关的命令有哪几个"><span>26.Redis 事务相关的命令有哪几个？</span></a></h4><h4 id="_27-redis-key-的过期时间和永久有效分别怎么设置" tabindex="-1"><a class="header-anchor" href="#_27-redis-key-的过期时间和永久有效分别怎么设置"><span>27.Redis key 的过期时间和永久有效分别怎么设置？</span></a></h4><h4 id="_28-redis-如何做内存优化" tabindex="-1"><a class="header-anchor" href="#_28-redis-如何做内存优化"><span>28.Redis 如何做内存优化？</span></a></h4><h4 id="_29-redis-回收进程如何工作的" tabindex="-1"><a class="header-anchor" href="#_29-redis-回收进程如何工作的"><span>29.Redis 回收进程如何工作的？</span></a></h4><h4 id="_30-都有哪些办法可以降低-redis-的内存使用情况呢" tabindex="-1"><a class="header-anchor" href="#_30-都有哪些办法可以降低-redis-的内存使用情况呢"><span>30.都有哪些办法可以降低 Redis 的内存使用情况呢？</span></a></h4><h4 id="_31-redis-的内存用完了会发生什么" tabindex="-1"><a class="header-anchor" href="#_31-redis-的内存用完了会发生什么"><span>31.Redis 的内存用完了会发生什么？</span></a></h4><h4 id="_32-一个-redis-实例最多能存放多少的-keys-list、set、sorted-set他们最多能存放多少元素" tabindex="-1"><a class="header-anchor" href="#_32-一个-redis-实例最多能存放多少的-keys-list、set、sorted-set他们最多能存放多少元素"><span>32.一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set他们最多能存放多少元素？</span></a></h4><h4 id="_33-mysql-里有-2000w-数据-redis-中只存-20w-的数据-如何保证redis-中的数据都是热点数据" tabindex="-1"><a class="header-anchor" href="#_33-mysql-里有-2000w-数据-redis-中只存-20w-的数据-如何保证redis-中的数据都是热点数据"><span>33.MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证Redis 中的数据都是热点数据？</span></a></h4><h4 id="_34-redis-最适合的场景是什么" tabindex="-1"><a class="header-anchor" href="#_34-redis-最适合的场景是什么"><span>34.Redis 最适合的场景是什么？</span></a></h4><h4 id="_35-假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来" tabindex="-1"><a class="header-anchor" href="#_35-假如-redis-里面有-1-亿个-key-其中有-10w-个-key-是以某个固定的已知的前缀开头的-如果将它们全部找出来"><span>35.假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</span></a></h4><h4 id="_36-如果有大量的-key-需要设置同一时间过期-一般需要注意什么" tabindex="-1"><a class="header-anchor" href="#_36-如果有大量的-key-需要设置同一时间过期-一般需要注意什么"><span>36.如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</span></a></h4><h4 id="_37-使用过-redis-做异步队列么-你是怎么用的" tabindex="-1"><a class="header-anchor" href="#_37-使用过-redis-做异步队列么-你是怎么用的"><span>37.使用过 Redis 做异步队列么，你是怎么用的？</span></a></h4><h4 id="_38-使用过-redis-分布式锁么-它是什么回事" tabindex="-1"><a class="header-anchor" href="#_38-使用过-redis-分布式锁么-它是什么回事"><span>38.使用过 Redis 分布式锁么，它是什么回事？</span></a></h4><h4 id="_39-如何预防缓存穿透与雪崩" tabindex="-1"><a class="header-anchor" href="#_39-如何预防缓存穿透与雪崩"><span>39.如何预防缓存穿透与雪崩？</span></a></h4><ul><li><p><strong>缓存穿透</strong></p><ol><li>当查询数据库为空的时候，把这个 key 缓存起来</li><li>使用布隆过滤器</li></ol></li><li><p><strong>缓存雪崩</strong></p></li></ul><blockquote><p>在某一时刻，大量缓存同时失效导致所有请求都去查询数据库，导致数据库压力过大而挂掉。</p></blockquote>',58)),d(a,{color:"#398BDE"},{default:l(()=>e[2]||(e[2]=[r("解决方案",-1)])),_:1,__:[2]}),e[6]||(e[6]=i('<ol><li>缓存高可用，比如 Redis 集群</li><li>缓存失效时间要设计好。不同的数据有不同的有效期，尽量保证不要在同一时刻失效，统一规划有效期，让失效时间分布均匀即可。</li><li>定时更新热门数据，以刷新缓存，从而避免自动失效。</li><li>服务限流和接口限流。如果服务和接口都有限流机制，就算缓存全部失效了，但是请求的总量是有限制的，可以在承受范围之类，这样短时间内系统响应慢点，但不至于挂掉，影响整个系统。</li><li>从数据库获取缓存需要的数据时加锁控制，本地锁或分布式锁都可以。当所有请求都不能命中缓存，这时候就要去数据库查询，如果同时并发的量大，也会导致雪崩的发生，可以在对数据库查询的地方进行加锁控制，不要让所有请求都过去，这样可以保证存储服务不挂掉。</li></ol><h4 id="_40-redis-可能会导致的问题" tabindex="-1"><a class="header-anchor" href="#_40-redis-可能会导致的问题"><span>40. Redis 可能会导致的问题？</span></a></h4><ul><li><p>缓存和数据库双写一致性问题</p><ul><li>通过代码保证 redis 和关系型数据库的数据一致性是不可靠的</li><li>可以使用 canal 监控数据库的 binlog 将数据的变化实时同步到 redis</li></ul></li><li><p>缓存击穿：如果某一个热点数据的缓存过期了，那么当大量用户同时访问这个热点数据时，就会导致数据库在缓存过期的瞬间压力突然增大；</p></li><li><p>缓存雪崩：如果大量数据的缓存同时失效（可能是给大量缓存设置了相同的过期时间，也可能是缓存服务器出现故障等），那么全部的后台请求将直接奔向数据库，从而导致数据库压力过大；</p></li><li><p>缓存穿透：一般而言，我们会将那些频繁查询的数据放入缓存，并不会缓存毫无意义的数据。但这也给一些不怀好意的人带来了可乘之机：如果有人恶意大量查询一些不存在的商品，那么这些查询请求就会绕过缓存而直达数据库，因此也会给数据库带来很大压力。</p></li></ul><blockquote><p>不难发现，缓存击穿、缓存雪崩和缓存穿透都是由于某种情况下的“缓存失效”所导致的。三者也都有各自的解决方案，举例如下：</p></blockquote><ul><li>避免缓存击穿：通过一个线程实时监控热点数据的过期时间，如果发现某个缓存快要过期了，就开启一个异步线程去更新缓存，从而重置过期时间。或者也可以简单一点：在秒杀开始前，手工的设置热点数据在秒杀期间不会过期。；</li><li>避免缓存雪崩：搭建缓存集群（如 Redis 集群），并合理的分配缓存的过期时间；</li><li>避免缓存穿透：对于不存在的商品，也将其以value=&quot;“的形式进行缓存（例如， key =“不存在的商品”, value =”&quot;）。这样一来，当以后再次查询“不存在的商品”时，也能迅速的从缓存中查到结果(结果就是&quot;&quot;)。此外，为了防止大量无效数据长时间占用缓存容量，可以将这些无意义缓存的过期时间设置的短一些。</li></ul><h4 id="_41-reids-为什么快、高并发的原因" tabindex="-1"><a class="header-anchor" href="#_41-reids-为什么快、高并发的原因"><span>41. Reids 为什么快、高并发的原因？</span></a></h4><ul><li><p>纯内存数据库</p></li><li><p>Redis 采用了单线程的模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争。</p></li><li><p>另外，数据结构也帮了不少忙，Redis 全程使用 hash 结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</p></li><li><p>还有一点，Redis 采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</p></li><li><p>采用了非阻塞 I/O 多路复用机制，使用了单线程来轮询描述符，减少了线程切换时上下文的切换和竞争。</p></li></ul><h4 id="_42-redis-做分布式锁的时候有需要注意的问题" tabindex="-1"><a class="header-anchor" href="#_42-redis-做分布式锁的时候有需要注意的问题"><span>42. Redis 做分布式锁的时候有需要注意的问题？</span></a></h4><p>一定要保证自己加的锁，自己才能释放。碰到过一种场景，线程A 加锁后执行太久（可能是涉及到 RPC 调用，超时了），锁超时释放了，线程B 就获得锁了，这时线程 A 终于执行到释放锁的逻辑，把线程B 的锁释放了，线程C 获得锁，可能又被线程B 释放，就这样恶性循环。这种情况分布式锁的作用就失效了，无法保证顺序执行。</p><p>锁超时释放，要么是过期时间不合理，要么是网络问题，要么是调用其他服务不稳定引起，应该尽可能缩小锁的范围。</p><p>因为锁超时释放而获得的锁可以添加额外的逻辑，比如转成关系型数据库加锁，或者中断原本持有锁的线程，锁超时释放了，业务逻辑也按失败处理。</p><p>想要中断原本持有锁的线程就要使用 RPC 调用，分布式锁可以用 hash 来实现，key 存放 <code>ip + 线程ID</code>，value 存放过期时间，加锁前 java 代码也要用 Map 保存 Thread 对象，key 为线程ID，这样就能通过线程ID 获取线程对象进行 interrupt 中断操作了。</p><h4 id="_43-如果是-redis-是单点部署的-会带来什么问题" tabindex="-1"><a class="header-anchor" href="#_43-如果是-redis-是单点部署的-会带来什么问题"><span>43. 如果是 Redis 是单点部署的，会带来什么问题？</span></a></h4><p>宕机直接导致所有访问 redis 的请求失败</p><h4 id="_44-那你准备怎么解决单点问题呢" tabindex="-1"><a class="header-anchor" href="#_44-那你准备怎么解决单点问题呢"><span>44. 那你准备怎么解决单点问题呢？</span></a></h4><p>主从 + Sentinel、Cluster</p><h4 id="_45-集群模式下-比如主从模式-有没有什么问题呢" tabindex="-1"><a class="header-anchor" href="#_45-集群模式下-比如主从模式-有没有什么问题呢"><span>45. 集群模式下，比如主从模式，有没有什么问题呢？</span></a></h4><p>使用分布式锁时，当获取锁后，master 还未将命令同步到 slave，新的 master 被选举出来，分布式锁又可以获取了，这就出现了一个锁同一时刻被两个线程持有。</p><h4 id="_46-你知道-redis-是怎么解决集群模式也不靠谱的问题的吗" tabindex="-1"><a class="header-anchor" href="#_46-你知道-redis-是怎么解决集群模式也不靠谱的问题的吗"><span>46. 你知道 Redis 是怎么解决集群模式也不靠谱的问题的吗？</span></a></h4><h4 id="_47-那你简单的介绍一下-redlock-吧" tabindex="-1"><a class="header-anchor" href="#_47-那你简单的介绍一下-redlock-吧"><span>47. 那你简单的介绍一下 Redlock 吧？</span></a></h4><h4 id="_48-你觉得-redlock-有什么问题呢" tabindex="-1"><a class="header-anchor" href="#_48-你觉得-redlock-有什么问题呢"><span>48. 你觉得 Redlock 有什么问题呢？</span></a></h4><h4 id="_49-加入设置参数-maxmemory-为-100m-当数据超过-100m-时-redis-会怎样处理" tabindex="-1"><a class="header-anchor" href="#_49-加入设置参数-maxmemory-为-100m-当数据超过-100m-时-redis-会怎样处理"><span>49. 加入设置参数 maxmemory 为 100M，当数据超过 100M 时，Redis 会怎样处理？</span></a></h4><p>当内存满了 100M 的时候，如果还接收到 set 命令， redis 将先尝试剔除设置过 expire 信息的 key，而不管该 key 的过期时间还没有到达，根据淘汰算法进行删除。</p><p>如果带有 expire 信息的 key 都删光了，那么将返回错误。这样， redis 将不再接收写请求，只接收 get 请求。</p><h4 id="_50-无法从连接池中获取连接-超时-可能的原因" tabindex="-1"><a class="header-anchor" href="#_50-无法从连接池中获取连接-超时-可能的原因"><span>50. 无法从连接池中获取连接（超时）可能的原因</span></a></h4><ul><li>慢查询阻塞：池子连接都被 hang 住。</li><li>资源参数不合理：例如 QPS 高，池子小。</li><li>连接泄露（没有close()）：也就是没有归还连接，可以用 client list、netstat 观察连接的一个增长情况，最重要的是 <code>try…catch…finally</code>。</li></ul><h4 id="_51-为什么-bgsave-和-aof-重写的时候-rehash-的负载因子变成-5-了" tabindex="-1"><a class="header-anchor" href="#_51-为什么-bgsave-和-aof-重写的时候-rehash-的负载因子变成-5-了"><span>51. 为什么 bgsave 和 aof 重写的时候 rehash 的负载因子变成 5 了</span></a></h4><p>因为 bgsave 和 aof 重写是 fork 一个子进程去做的，内核把父进程中所有内存页的权限都设置为 read-only，当父进程需要修改数据时需要拷贝一份数据页，在 bgsave 和 aof 重写期间 rehash 可能造成大量的内存拷贝，性能低下，所以这个期间触发 rehash 的条件从【负载因子 = 1】变成了 【负载因子 = 5】。</p><h4 id="_52-reids-服务器操作系统基本信息告警-你认为是那些原因" tabindex="-1"><a class="header-anchor" href="#_52-reids-服务器操作系统基本信息告警-你认为是那些原因"><span>52. Reids 服务器操作系统基本信息告警，你认为是那些原因？</span></a></h4><ul><li><p>从节点太多造成复制风暴；</p></li><li><p>全量同步过程未结束，主节点接收大量写请求，复制积压缓冲区满了，触发重新同步；</p></li><li><p>网络较差，主从断开重连后，又要重新同步（Redis 2.8 以前只能全量同步，不支持增量）；</p></li><li><p>BigKey 造成网络 IO 超时。</p></li></ul><h4 id="_53-redis-可以用在哪些业务上" tabindex="-1"><a class="header-anchor" href="#_53-redis-可以用在哪些业务上"><span>53. redis 可以用在哪些业务上？</span></a></h4><ul><li>缓存</li><li>分布式锁</li><li>简易的分布式消息队列（Lists 或 Streams）</li><li>简易的订阅通知（Pub/Sub)</li><li>延时通知（键过期事件通知）</li><li>附近的人（GEO）</li><li>用户签到</li></ul><h4 id="_54-redis-有什么缺点" tabindex="-1"><a class="header-anchor" href="#_54-redis-有什么缺点"><span>54. Redis 有什么缺点？</span></a></h4><ul><li>缓存和数据库双写一致性问题</li><li>缓存雪崩问题</li><li>缓存穿透问题</li><li>缓存的并发竞争问题</li></ul><h4 id="_55-使用-redis-有哪些好处" tabindex="-1"><a class="header-anchor" href="#_55-使用-redis-有哪些好处"><span>55. 使用 Redis 有哪些好处</span></a></h4><ul><li>速度快，因为数据存在内存中，类似于<code>HashMap</code>，<code>HashMap</code>的优势就是查找和操作的时间复杂度都是O(1)</li><li>支持丰富数据类型，支持<code>string</code>，<code>list</code>，<code>set</code>，<code>sorted</code> <code>set</code>，<code>hash</code></li><li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li><li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除。</li></ul><h4 id="_56-redis-提供了几种数据淘汰策略-该怎么选择" tabindex="-1"><a class="header-anchor" href="#_56-redis-提供了几种数据淘汰策略-该怎么选择"><span>56. Redis 提供了几种数据淘汰策略？该怎么选择？</span></a></h4><p>默认策略是不清除，内存满了就不再接收写请求，直接返回错误。另外还有 3 种策略：随机清除、LRU 和 LFU，这 3 种策略分别可以选择是针对所有 key 还是只针对有过期时间的 key。</p><ul><li>LRU 是最近最少使用，Redis 是随机采样，默认配置是每次取 5 个 key，进行判别</li><li>LFU 是最少使用</li></ul><p>最后还有一种，从设置了过期时间的 key 中挑最快过期的进行淘汰。</p><p>如果所有 key 的访问频率都差不多使用随机淘汰就好，如果有部分数据访问频率不高就使用 lru。</p><h4 id="_57-redis-为什么之前一直不使用多线程-6-0-为什么又使用了" tabindex="-1"><a class="header-anchor" href="#_57-redis-为什么之前一直不使用多线程-6-0-为什么又使用了"><span>57. Redis 为什么之前一直不使用多线程，6.0 为什么又使用了？</span></a></h4><p>使用 Redis 的瓶颈主要是内存和网络，CPU 不会成为瓶颈，使用多线程会增加线程切换的开销、还会带来一些并发读写的问题、增加了复杂度。</p><p>对于 80% 的公司来说，8w 到 10w 的 QPS 已经足够了，不过随着业务场景越来越复杂，有些公司动不动就上亿的交易量，因此需要更大的 QPS，采用分布式的 Redis 解决方案，增加了运维成本、服务器投入成本。所以 6.0 版本为了提高网络 IO 性能使用了多线程来处理网络数据的读写和协议解析，执行命令仍然是单线程的，而且默认是禁用多线程的，需要将 <code>io-threads-do-reads</code> 参数设置为 yes 才会启用多线程。</p><p>官方推荐至少要 4 核的机器才开启多线程，线程数的设置不能高于 cpu 核心数，而且超过 8 个基本上没有意义。</p><h4 id="_58-redis6-0多线程的实现机制" tabindex="-1"><a class="header-anchor" href="#_58-redis6-0多线程的实现机制"><span>58. Redis6.0多线程的实现机制？</span></a></h4><p>主线程获取可读的 socket 会先放入一个等待队列，等待队列满了再交给一个 IO 线程组处理，读取 socket 中的数据和协议解析由 IO 线程组完成，这里是并发执行的，提升了 IO 效率，期间主线程阻塞，IO 线程组处理完后，主线程才开始执行所有请求命令。</p><h4 id="_59-redis-如何做到高可用" tabindex="-1"><a class="header-anchor" href="#_59-redis-如何做到高可用"><span>59. Redis 如何做到高可用？</span></a></h4><p>redis 有两种持久化方式 AOF 和 RDB 能够尽量不丢失数据，Redis 还支持主从、集群部署保证服务的可用性。</p>',49))])}const _=n(t,[["render",p]]),R=JSON.parse('{"path":"/bigcompany/kvmajx4g/","title":"Redis常见的面试题","lang":"zh-CN","frontmatter":{"title":"Redis常见的面试题","createTime":"2025/08/26 09:22:59","permalink":"/bigcompany/kvmajx4g/"},"readingTime":{"minutes":21.79,"words":6537},"git":{"createdTime":1756736713000},"filePathRelative":"notes/bigcompany/mianshiti/redis.md","headers":[]}');export{_ as comp,R as data};
