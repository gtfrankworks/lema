import{a as n,c as a,b as i,o as e}from"./app-ZQgO6-gU.js";const t={};function l(r,s){return e(),a("div",null,s[0]||(s[0]=[i(`<ul><li><h3 id="_1、哪些情况下的对象会被垃圾回收机制处理掉" tabindex="-1"><a class="header-anchor" href="#_1、哪些情况下的对象会被垃圾回收机制处理掉"><span><strong>1、哪些情况下的对象会被垃圾回收机制处理掉？</strong></span></a></h3><ul><li>JVM 使用 <strong>可达性分析算法</strong>（Reachability Analysis）判定对象是否可回收。</li><li><strong>GC Roots</strong> 是起点，虚拟机从 GC Roots 出发沿着引用链寻找对象，如果某对象 <strong>无法被 GC Roots 到达</strong>，就认为该对象可以回收。</li><li>典型回收场景： <ol><li>局部变量引用超出作用域</li><li>对象被显式置为 null</li><li>对象只在弱引用、软引用、虚引用下被引用</li></ol></li></ul><hr><h3 id="_2、哪些对象可以被看做是-gc-roots" tabindex="-1"><a class="header-anchor" href="#_2、哪些对象可以被看做是-gc-roots"><span><strong>2、哪些对象可以被看做是 GC Roots？</strong></span></a></h3><ol><li><strong>虚拟机栈</strong>中本地变量表引用的对象（栈帧里的引用）。</li><li><strong>方法区</strong>中的类静态属性和常量引用的对象。</li><li><strong>本地方法栈</strong>中 JNI（Native 方法）引用的对象。</li></ol><hr><h3 id="_3、对象不可达-一定会被垃圾收集器回收么" tabindex="-1"><a class="header-anchor" href="#_3、对象不可达-一定会被垃圾收集器回收么"><span><strong>3、对象不可达，一定会被垃圾收集器回收么？</strong></span></a></h3><ul><li>不一定。对象不可达后，如果实现了 <strong><code>finalize()</code> 方法</strong>，可能先进入 <strong>F-Queue（finalize 队列）</strong>，等待 JVM 调用。</li><li>只有 finalize 执行完成后，才会被真正回收。</li><li>因此对象还有一次“逃生机会”，也叫 <strong>终结逃逸</strong>。</li></ul><hr><h3 id="_4、讲一下常见编码方式" tabindex="-1"><a class="header-anchor" href="#_4、讲一下常见编码方式"><span><strong>4、讲一下常见编码方式</strong></span></a></h3><ul><li><strong>目的</strong>：将字符映射成计算机可存储的二进制。</li><li><strong>常见编码</strong>： <ol><li><strong>ASCII</strong>：7 位，128 个字符，控制字符 0-31，打印字符 32-126。</li><li><strong>ISO-8859-1</strong>：扩展 ASCII，256 个字符，覆盖大部分西欧语言。</li><li><strong>GB2312</strong>：双字节，符号区 A1-A7，汉字区 B0-B7，共 6763 个汉字。</li><li><strong>GBK</strong>：扩展 GB2312，编码范围 8140-FEFE，能表示 21003 个汉字。</li><li><strong>UTF-16</strong>：固定 2 字节表示 Unicode 字符。</li><li><strong>UTF-8</strong>：变长编码，1~6 字节表示字符，节约空间并兼容 ASCII。</li></ol></li></ul><hr><h3 id="_5、utf-8-编码中的中文占几个字节-int-类型占几个字节" tabindex="-1"><a class="header-anchor" href="#_5、utf-8-编码中的中文占几个字节-int-类型占几个字节"><span><strong>5、UTF-8 编码中的中文占几个字节？int 类型占几个字节？</strong></span></a></h3><ul><li><strong>UTF-8 中文</strong>：通常占 <strong>3 个字节</strong>（少数特殊字符 2 或 4 字节）。</li><li><strong>int 类型</strong>：固定 <strong>4 个字节</strong>。</li></ul><hr><h3 id="_6、静态代理与动态代理的区别及使用场景" tabindex="-1"><a class="header-anchor" href="#_6、静态代理与动态代理的区别及使用场景"><span><strong>6、静态代理与动态代理的区别及使用场景</strong></span></a></h3><ul><li><strong>概念</strong>：代理模式为对象提供代理，以控制对真实对象的访问，实现解耦。</li></ul><table><thead><tr><th>特性</th><th>静态代理</th><th>动态代理</th></tr></thead><tbody><tr><td>创建时间</td><td>编译时</td><td>运行时</td></tr><tr><td>是否固定</td><td>固定代理类</td><td>可代理多个类</td></tr><tr><td>实现方式</td><td>手动或工具生成</td><td>反射 + Proxy</td></tr><tr><td>场景</td><td>单一对象、简单控制</td><td>Spring AOP、Retrofit 接口调用</td></tr></tbody></table><p><strong>动态代理实现步骤</strong>：</p><ol><li>实现 <code>InvocationHandler</code> 接口</li><li>使用 <code>Proxy.newProxyInstance()</code> 创建代理对象</li><li>利用反射获取构造函数并实例化代理</li></ol><hr><h3 id="_7、java-的异常体系" tabindex="-1"><a class="header-anchor" href="#_7、java-的异常体系"><span><strong>7、Java 的异常体系</strong></span></a></h3><ul><li><strong>Throwable</strong>：所有异常/错误的父类。 <ul><li><strong>Error</strong>（不可处理）：OOM、ThreadDeath 等，JVM 通常终止程序。</li><li><strong>Exception</strong>（可处理）： <ul><li><strong>运行时异常 RuntimeException</strong>：NullPointerException、IndexOutOfBoundsException。</li><li><strong>非运行时异常 Checked Exception</strong>：IOException、SQLException、FileNotFoundException。</li></ul></li></ul></li></ul><hr><h3 id="_8、解析与分派" tabindex="-1"><a class="header-anchor" href="#_8、解析与分派"><span><strong>8、解析与分派</strong></span></a></h3><ul><li><strong>解析</strong>：编译期或类加载阶段就确定的方法调用地址（静态）。</li><li><strong>分派</strong>：运行期根据对象实际类型调用方法（动态）。 <ul><li><strong>静态分派</strong>：方法重载，根据参数静态类型决定调用版本。</li><li><strong>动态分派</strong>：方法重写，根据对象实际类型决定调用版本。</li></ul></li></ul><hr><h3 id="_9、修改对象-a-的-equals-方法签名-hashmap-会调用哪个-equals-方法" tabindex="-1"><a class="header-anchor" href="#_9、修改对象-a-的-equals-方法签名-hashmap-会调用哪个-equals-方法"><span><strong>9、修改对象 A 的 equals 方法签名，HashMap 会调用哪个 equals 方法？</strong></span></a></h3><ul><li>HashMap 调用的是 <strong>对象当前的 equals 方法</strong>。</li><li>如果 equals 没有重写，则使用 Object 的 equals（== 比较引用地址）。</li></ul><hr><h3 id="_10、java-实现多态的机制" tabindex="-1"><a class="header-anchor" href="#_10、java-实现多态的机制"><span><strong>10、Java 实现多态的机制</strong></span></a></h3><ul><li><strong>多态实现依赖</strong>：方法重写 + 动态分派（虚方法表）。</li><li><strong>原理</strong>：运行期根据对象实际类型在虚方法表中找到方法实现并调用。</li></ul><hr><h3 id="_11、如何将一个-java-对象序列化到文件" tabindex="-1"><a class="header-anchor" href="#_11、如何将一个-java-对象序列化到文件"><span><strong>11、如何将一个 Java 对象序列化到文件？</strong></span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>import java.io.*;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class Person implements Serializable { </span></span>
<span class="line"><span>    String name; </span></span>
<span class="line"><span>    int age; </span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Person p = new Person();</span></span>
<span class="line"><span>ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;person.dat&quot;));</span></span>
<span class="line"><span>oos.writeObject(p);</span></span>
<span class="line"><span>oos.close();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>要求</strong>：对象类实现 <code>Serializable</code> 接口。</li><li><strong>应用</strong>：对象持久化、网络传输。</li></ul><hr><h3 id="_12、java-反射理解" tabindex="-1"><a class="header-anchor" href="#_12、java-反射理解"><span><strong>12、Java 反射理解</strong></span></a></h3><ul><li><strong>反射</strong>：程序在运行时获取类信息并操作对象、方法、字段。</li><li><strong>用途</strong>：框架、依赖注入、动态代理、序列化等。</li><li><strong>例子</strong>：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>Class&lt;?&gt; clazz = Class.forName(&quot;Person&quot;);</span></span>
<span class="line"><span>Method m = clazz.getMethod(&quot;setName&quot;, String.class);</span></span>
<span class="line"><span>m.invoke(clazz.newInstance(), &quot;Tom&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_13、java-注解理解" tabindex="-1"><a class="header-anchor" href="#_13、java-注解理解"><span><strong>13、Java 注解理解</strong></span></a></h3><ul><li><strong>注解</strong>：提供元数据给程序或工具。</li><li><strong>用途</strong>：编译检查、运行期处理、代码生成、框架配置。</li><li><strong>例子</strong>：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>@Override</span></span>
<span class="line"><span>@Deprecated</span></span>
<span class="line"><span>public void oldMethod() {}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_14、泛型原理" tabindex="-1"><a class="header-anchor" href="#_14、泛型原理"><span><strong>14、泛型原理</strong></span></a></h3><ul><li><strong>原理</strong>：编译期类型检查 + 类型擦除（Type Erasure）</li><li><strong>例子</strong>：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>List&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span>
<span class="line"><span>list.add(&quot;abc&quot;); // 编译器检查类型</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>底层</strong>：泛型信息在编译期使用，运行期擦除成 Object 或边界类型。</li></ul><hr><h3 id="_15、java-中-string-了解" tabindex="-1"><a class="header-anchor" href="#_15、java-中-string-了解"><span><strong>15、Java 中 String 了解</strong></span></a></h3><ul><li><strong>特点</strong>：不可变、线程安全、常量池存储</li><li><strong>优势</strong>：缓存哈希值、共享字符串、避免数据不一致</li><li><strong>例子</strong>：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>String s1 = &quot;abc&quot;;</span></span>
<span class="line"><span>String s2 = &quot;abc&quot;; // 引用同一个常量池对象</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_16、string-为什么设计成不可变" tabindex="-1"><a class="header-anchor" href="#_16、string-为什么设计成不可变"><span><strong>16、String 为什么设计成不可变？</strong></span></a></h3><ul><li><strong>安全性</strong>：常量池共享，提高安全性（如 ClassLoader、HashMap key）</li><li><strong>效率</strong>：可以缓存 hashCode，提高查找性能</li><li><strong>线程安全</strong>：不可变对象天然线程安全</li><li><strong>实例共享</strong>：多个变量可共享同一对象，节约内存</li></ul></li></ul>`,1)]))}const d=n(t,[["render",l]]),g=JSON.parse('{"path":"/bigcompany/zpz0w2hc/","title":"京东-Java中级","lang":"zh-CN","frontmatter":{"title":"京东-Java中级","createTime":"2025/08/21 13:25:17","permalink":"/bigcompany/zpz0w2hc/"},"readingTime":{"minutes":4.2,"words":1261},"git":{"createdTime":1756736713000},"filePathRelative":"notes/bigcompany/company/京东-Java中级.md","headers":[]}');export{d as comp,g as data};
