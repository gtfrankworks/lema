import{a as e,c as i,b as a,o as n}from"./app-ZQgO6-gU.js";const o={};function g(r,t){return n(),i("div",null,t[0]||(t[0]=[a('<blockquote><p>在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</p></blockquote><p>还记得那些年你的游戏存档吗？</p><p><strong>Don&#39;t Starve</strong></p><figure><img src="https://i.loli.net/2020/11/28/uWjlqrXoOhPLIxY.jpg" alt="Don&#39;t Starve.jpg" tabindex="0" loading="lazy"><figcaption>Don&#39;t Starve.jpg</figcaption></figure><p><strong>unascribed-game1</strong></p><figure><img src="https://i.loli.net/2020/11/28/18vxNgFbsJpASw6.jpg" alt="unascribed-game.jpg" tabindex="0" loading="lazy"><figcaption>unascribed-game.jpg</figcaption></figure><p><strong>unascribed-game2</strong></p><figure><img src="https://i.loli.net/2020/11/28/Dl5H9G82FkpO4P1.jpg" alt="unascribed-game2.jpg" tabindex="0" loading="lazy"><figcaption>unascribed-game2.jpg</figcaption></figure><h2 id="自己实现一个简易版的游戏存档功能" tabindex="-1"><a class="header-anchor" href="#自己实现一个简易版的游戏存档功能"><span>自己实现一个简易版的游戏存档功能</span></a></h2><p>今天写一个游戏存档功能练习一下编码基本功。</p><p><strong>需求分析</strong></p><ol><li>需要有个管理存档的角色，那么多个存档总要有人来管啊，想存档或者读档需要它说了算。</li><li>还需要有个具体的存档对象，方便我们管理呀。</li></ol><p><strong>需求设计</strong></p><ol><li>存档对象的管理角色 Caretaker 管理存档对象</li><li>存档对象 Memento 具体的存档对象</li><li>存档的创建者 Originator 管理“存档”这件事，创建恢复存档。</li></ol><h2 id="代码-📃" tabindex="-1"><a class="header-anchor" href="#代码-📃"><span>代码 📃</span></a></h2><blockquote><p>完整源码关注回复“源码获取”</p></blockquote><figure><img src="https://i.loli.net/2020/11/28/ODChyStnGzM47Lo.png" alt="memento-source" tabindex="0" loading="lazy"><figcaption>memento-source</figcaption></figure><p>测试结果</p><figure><img src="https://i.loli.net/2020/11/28/57jB1tPbwWDsdJR.png" alt="memento-test" tabindex="0" loading="lazy"><figcaption>memento-test</figcaption></figure><p><strong>展示存档列表</strong></p><figure><img src="https://i.loli.net/2020/11/28/9SrAQZD465qW1zl.png" alt="memento-list-test" tabindex="0" loading="lazy"><figcaption>memento-list-test</figcaption></figure><h2 id="备忘录模式类图-📌" tabindex="-1"><a class="header-anchor" href="#备忘录模式类图-📌"><span>备忘录模式类图 📌</span></a></h2><figure><img src="https://i.loli.net/2020/11/28/hHtJlIPN9OTw4KL.png" alt="memento-UML1" tabindex="0" loading="lazy"><figcaption>memento-UML1</figcaption></figure><p>上面的代码是以这种类图方式实现的，不过这在 Java 中显然有可以优化的地方。即将 Caretaker 角色优化掉。优化后的类图</p><figure><img src="https://i.loli.net/2020/11/28/GNXw8MnRPskxbSh.png" alt="memento-UML2" tabindex="0" loading="lazy"><figcaption>memento-UML2</figcaption></figure><blockquote><p>两个写法的完整源码关注回复“源码获取”，优化版代码在 optimization 目录中</p></blockquote><h2 id="总结-📚" tabindex="-1"><a class="header-anchor" href="#总结-📚"><span>总结 📚</span></a></h2><p>由于备忘录模式使用这种代码构建的方式在 Java 中并不多，这要得益于 Java 的 <code>Serializable</code> 接口，可以使用序列化来完成备份的操作。所以只是简单的使用一个游戏存档案例记录一下这个知识点，配合学习理解的最好的再就应该是文档编辑功能中的 <code>ctrl+z</code>了。</p><p>备忘录模式可以使我们对一个对象的状态进行保存，在需要的时候快速恢复。不得不说的就是备忘录模式如果保存的大量的对象时，内存的占用还是需要关注一下的。在备忘录模式中保存对象的时候，可以配合原型模式来一起使用。</p><p>最后，这个模式在 Java 中应该不太香，原因上面也说了。所以<strong>我对这个设计模式仅作为了解</strong>，真正要使用它的话我还是会尽可能的考虑使用 <code>Serializable</code>。</p><p>**优点：**无侵入备份/恢复对象状态（<strong>在 Java 里不是很香</strong>）。</p><p><strong>缺点：<strong>GOF 中的写法在 Java 中</strong>不香</strong>，同时使用这种模式需考虑内存占用问题。</p>',32)]))}const s=e(o,[["render",g]]),l=JSON.parse('{"path":"/design/f9qgzqgn/","title":"备忘录模式","lang":"zh-CN","frontmatter":{"title":"备忘录模式","createTime":"2025/08/27 23:23:37","permalink":"/design/f9qgzqgn/"},"readingTime":{"minutes":2.23,"words":668},"git":{"createdTime":1756736713000},"filePathRelative":"notes/design/备忘录模式.md","headers":[]}');export{s as comp,l as data};
