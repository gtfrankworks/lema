import{a as i,c as t,b as r,o as s}from"./app-ZQgO6-gU.js";const a={};function n(o,l){return s(),t("div",null,l[0]||(l[0]=[r('<ul><li><h3 id="_1-jdk1-7-→-jdk1-8-map-底层变化" tabindex="-1"><a class="header-anchor" href="#_1-jdk1-7-→-jdk1-8-map-底层变化"><span>1. <strong>JDK1.7 → JDK1.8 Map 底层变化</strong></span></a></h3><ul><li><strong>HashMap 数据结构</strong>： <ul><li><strong>JDK1.7</strong>：数组 + 链表。每个元素存储在数组中的一个“桶”，如果多个 key 的 hash 冲突，就用链表挂在同一个桶上。</li><li><strong>JDK1.8</strong>：数组 + 链表 + 红黑树。链表长度 &gt; 8 时，链表转为红黑树，提高查找效率。</li></ul></li><li><strong>原因</strong>：避免哈希冲突严重时链表退化为 O(n) 查找。</li><li><strong>并发问题</strong>： <ul><li>JDK1.7/1.8 HashMap 都不线程安全；</li><li>并发插入可能出现死循环。</li></ul></li><li><strong>类比</strong>：1.7 像“排队找东西”，1.8 多了“二叉树快通道”，查找快。</li></ul><p><strong>面试扩展</strong>：</p><ul><li>HashMap resize 的时候也可能触发链表转换为红黑树。</li><li>为什么 8？经验值，链表太短用红黑树反而浪费内存。</li></ul><hr><h3 id="_2-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#_2-concurrenthashmap"><span>2. <strong>ConcurrentHashMap</strong></span></a></h3><ul><li><strong>核心思想</strong>：线程安全、降低锁竞争。</li><li><strong>JDK1.7</strong>： <ul><li>分段锁（Segment）：每段独立锁，锁粒度较粗。</li></ul></li><li><strong>JDK1.8</strong>： <ul><li>CAS + synchronized + 链表/红黑树。</li><li>使用 <code>Node</code> + <code>ForwardingNode</code> + <code>TreeBin</code> 实现高并发。</li></ul></li><li><strong>优势</strong>： <ul><li>多线程可以同时读写不同桶；</li><li>避免全表锁，提高性能。</li></ul></li><li><strong>应用场景</strong>： <ul><li>高并发缓存、统计计数器、线程安全集合。</li></ul></li></ul><hr><h3 id="_3-并发-vs-并行" tabindex="-1"><a class="header-anchor" href="#_3-并发-vs-并行"><span>3. <strong>并发 vs 并行</strong></span></a></h3><table><thead><tr><th>概念</th><th>描述</th><th>类比</th></tr></thead><tbody><tr><td>并发</td><td>多任务交替执行</td><td>一位厨师轮流做几道菜</td></tr><tr><td>并行</td><td>多任务同时执行</td><td>多位厨师同时做不同菜</td></tr></tbody></table><ul><li><strong>总结</strong>：并发强调“交替调度”，并行强调“同时执行”，多线程不一定并行，单核 CPU 并发，多核 CPU 可并行。</li></ul><hr><h3 id="_4-jdk1-7-→-jdk1-8-jvm-内存变化" tabindex="-1"><a class="header-anchor" href="#_4-jdk1-7-→-jdk1-8-jvm-内存变化"><span>4. <strong>JDK1.7 → JDK1.8 JVM 内存变化</strong></span></a></h3><ul><li><strong>JDK1.7</strong>： <ul><li>堆：Young（Eden + Survivor）、Old；</li><li>方法区：Permanent Generation（存放类元信息、静态变量、字符串常量）。</li></ul></li><li><strong>JDK1.8</strong>： <ul><li>永久代移除 → MetaSpace（存放类元信息，位于本地内存）。</li></ul></li><li><strong>好处</strong>： <ul><li>避免 PermGen OutOfMemoryError；</li><li>MetaSpace 可动态增长；</li><li>GC 更高效，可回收类卸载。</li></ul></li><li><strong>类比</strong>：PermGen = 固定容量文件柜 → 易满；MetaSpace = 云存储 → 自动扩容。</li></ul><hr><h3 id="_5-设计中间件" tabindex="-1"><a class="header-anchor" href="#_5-设计中间件"><span>5. <strong>设计中间件</strong></span></a></h3><ol><li><strong>RPC（远程调用）</strong>： <ul><li>屏蔽网络调用细节，像调用本地方法。</li><li>需要序列化/反序列化，网络传输。</li></ul></li><li><strong>消息中间件（MQ）</strong>： <ul><li>异步通信、队列、发布订阅。</li><li>可实现解耦、缓冲高峰流量。</li></ul></li><li><strong>对象请求代理（ORB / OTM）</strong>： <ul><li>封装通信协议，统一接口。</li><li>支持同步、异步、广播。</li></ul></li><li><strong>事务处理监控</strong>： <ul><li>保证 ACID；</li><li>进程管理、负载均衡；</li><li>分布式事务控制。</li></ul></li></ol><ul><li><strong>类比</strong>：中间件像交通枢纽，协调各个服务、消息、事务高效流动。</li></ul><hr><h3 id="_6-中间件定义" tabindex="-1"><a class="header-anchor" href="#_6-中间件定义"><span>6. <strong>中间件定义</strong></span></a></h3><ul><li><strong>概念</strong>：操作系统和应用程序之间的软件，用于通信和集成。</li><li><strong>功能</strong>： <ul><li>消息传递；</li><li>远程调用；</li><li>对象代理；</li><li>事务管理。</li></ul></li><li><strong>分类</strong>： <ul><li>RPC；</li><li>消息队列（ActiveMQ、RabbitMQ、Kafka）；</li><li>对象请求代理（CORBA）；</li><li>事务处理监控（分布式事务协调）。</li></ul></li></ul><hr><h3 id="_7-threadlocal" tabindex="-1"><a class="header-anchor" href="#_7-threadlocal"><span>7. <strong>ThreadLocal</strong></span></a></h3><ul><li><strong>作用</strong>：线程级变量，线程安全。</li><li><strong>原理</strong>： <ul><li>每个线程维护一个 <code>ThreadLocalMap</code>；</li><li><code>ThreadLocal.set()</code> → 当前线程 Map 存值；</li><li><code>ThreadLocal.get()</code> → 当前线程 Map 取值；</li></ul></li><li><strong>应用</strong>： <ul><li>事务上下文；</li><li>用户会话信息；</li><li>数据库连接池（每线程独占）。</li></ul></li><li><strong>类比</strong>：每个线程有自己的储物柜，别人不能碰。</li></ul><hr><h3 id="_8-hashcode-vs-equals-vs" tabindex="-1"><a class="header-anchor" href="#_8-hashcode-vs-equals-vs"><span>8. <strong>hashCode() vs equals() vs ==</strong></span></a></h3><table><thead><tr><th>方法</th><th>比较内容</th><th>说明</th></tr></thead><tbody><tr><td><code>==</code></td><td>内存地址</td><td>是否同一对象</td></tr><tr><td><code>equals()</code></td><td>对象内容</td><td>可重写逻辑判断</td></tr><tr><td><code>hashCode()</code></td><td>散列值</td><td>HashMap/HashSet 判断位置</td></tr></tbody></table><ul><li><strong>规律</strong>： <ul><li>equals 相等 → hashCode 必然相等；</li><li>hashCode 相等 → equals 不一定相等；</li></ul></li><li><strong>类比</strong>：hashCode = 快递单号，equals = 快递内容，== = 快递仓库里的实际箱子。</li></ul><hr><h3 id="_9-mysql-索引无法使用情况" tabindex="-1"><a class="header-anchor" href="#_9-mysql-索引无法使用情况"><span>9. <strong>MySQL 索引无法使用情况</strong></span></a></h3><ol><li>OR 条件：部分列有索引也无效；</li><li>多列索引未按最左前缀使用；</li><li>LIKE %xxx：开头模糊匹配不使用索引；</li><li>类型转换：列类型与查询类型不一致；</li><li>索引列运算/函数：如 <code>YEAR(date)</code>；</li><li>优化器判断全表扫描比索引更快。</li></ol><p><strong>不推荐索引的字段</strong>：</p><ul><li>唯一性差；</li><li>频繁更新；</li><li>不在 WHERE 条件使用；</li><li>使用 <code>&lt;&gt;</code> 或 <code>%</code> 开头模糊查询。</li></ul><hr><h3 id="_10-mysql-分库策略" tabindex="-1"><a class="header-anchor" href="#_10-mysql-分库策略"><span>10. <strong>MySQL 分库策略</strong></span></a></h3><ul><li><strong>垂直分库</strong>：不同业务拆分不同库；</li><li><strong>水平分库</strong>：同表数据拆分不同库；</li><li><strong>索引优化</strong>： <ul><li>覆盖索引；</li><li>组合索引；</li><li>避免冗余索引；</li></ul></li><li><strong>SQL 优化</strong>： <ul><li>避免 SELECT *；</li><li>JOIN 优化子查询；</li><li>批量操作减少网络往返；</li><li>使用 EXPLAIN 分析执行计划。</li></ul></li></ul><hr><h3 id="_11-分布式事务解决方案" tabindex="-1"><a class="header-anchor" href="#_11-分布式事务解决方案"><span>11. <strong>分布式事务解决方案</strong></span></a></h3><ul><li>两阶段提交（2PC）：先准备 → 再提交；</li><li>三阶段提交（3PC）：多一阶段防止阻塞；</li><li>TCC（Try/Confirm/Cancel）：可补偿事务；</li><li>基于消息队列的最终一致性：异步重试机制。</li></ul><hr><h3 id="_12-sql-优化技巧" tabindex="-1"><a class="header-anchor" href="#_12-sql-优化技巧"><span>12. <strong>SQL 优化技巧</strong></span></a></h3><ul><li>避免全表扫描；</li><li>避免函数/运算影响索引；</li><li>使用覆盖索引减少回表；</li><li>批量处理减少网络开销；</li><li>分页优化（<code>LIMIT + 索引</code>）；</li><li>复杂查询优化 JOIN 顺序、子查询改为 JOIN。</li></ul><hr><h3 id="_13-mysql-存储引擎" tabindex="-1"><a class="header-anchor" href="#_13-mysql-存储引擎"><span>13. <strong>MySQL 存储引擎</strong></span></a></h3><table><thead><tr><th>引擎</th><th>特点</th><th>场景</th></tr></thead><tbody><tr><td>InnoDB</td><td>支持事务、行锁、聚集索引</td><td>OLTP，高并发写操作</td></tr><tr><td>MyISAM</td><td>不支持事务、表锁、非聚集索引</td><td>OLAP，读多写少</td></tr></tbody></table><ul><li><strong>聚集索引</strong>：数据和主键一起存储，查询主键快速；</li><li><strong>非聚集索引</strong>：索引 + 数据分离，需要回表查数据；</li><li><strong>为什么 B+ 树而不是 Hash</strong>： <ul><li>支持范围查询；</li><li>顺序存储，提高磁盘 IO 连续性；</li><li>Hash 只适合等值查询，不支持范围。</li></ul></li></ul><hr><h3 id="_14-红黑树原理" tabindex="-1"><a class="header-anchor" href="#_14-红黑树原理"><span>14. <strong>红黑树原理</strong></span></a></h3><ul><li><strong>规则</strong>： <ol><li>节点红/黑；</li><li>根黑；</li><li>红节点不能连续；</li><li>任意路径黑节点数相同；</li></ol></li><li><strong>特点</strong>： <ul><li>保证 O(log n) 查找、插入、删除；</li><li>HashMap 长链表 &gt; 8 转红黑树。</li></ul></li><li><strong>类比</strong>：像书架，每层书数均衡，查书快。</li></ul></li></ul>',1)]))}const d=i(a,[["render",n]]),h=JSON.parse('{"path":"/bigcompany/1o2qrb8l/","title":"蚂蚁金服-Java中级","lang":"zh-CN","frontmatter":{"title":"蚂蚁金服-Java中级","createTime":"2025/08/21 13:19:09","permalink":"/bigcompany/1o2qrb8l/"},"readingTime":{"minutes":4.65,"words":1394},"git":{"createdTime":1756736713000},"filePathRelative":"notes/bigcompany/company/蚂蚁金服-Java中级.md","headers":[]}');export{d as comp,h as data};
