import{a as i,c as s,b as l,o}from"./app-ZQgO6-gU.js";const n={};function t(a,e){return o(),s("div",null,e[0]||(e[0]=[l(`<h2 id="什么是-redis-复制" tabindex="-1"><a class="header-anchor" href="#什么是-redis-复制"><span>什么是 Redis 复制？</span></a></h2><p>Redis 复制（Replication）是 Redis 的高可用性解决方案之一。它允许你将数据从一个 Redis 实例（<strong>主节点，Master</strong>）同步到一个或多个 Redis 实例（<strong>从节点，Replica</strong>）。</p><ul><li><strong>主节点（Master）：</strong> 负责处理所有写请求（如 <code>SET</code>, <code>INCR</code>），并将数据变更同步给从节点。一个 Redis 复制架构中只有一个主节点。</li><li><strong>从节点（Replica）：</strong> 只负责处理读请求。从节点的数据是主节点的精确副本。一个主节点可以有多个从节点。</li></ul><h2 id="复制的工作原理" tabindex="-1"><a class="header-anchor" href="#复制的工作原理"><span>复制的工作原理</span></a></h2><p>Redis 复制分为两种同步方式：<strong>全量同步（Full Synchronization）和增量同步（Partial Synchronization）</strong>。</p><h3 id="_1-首次连接时的全量同步" tabindex="-1"><a class="header-anchor" href="#_1-首次连接时的全量同步"><span>1. 首次连接时的全量同步</span></a></h3><p>当从节点首次连接到主节点时，会触发全量同步。这个过程确保从节点拥有主节点的完整数据副本。</p><ol><li><strong>从节点发送 <code>PSYNC</code> 命令</strong>：从节点向主节点发送 <code>PSYNC ? -1</code> 命令，表示请求全量同步。</li><li><strong>主节点开始 BGSAVE</strong>：主节点收到请求后，会后台执行 <code>BGSAVE</code> 命令，生成一个 RDB 文件。</li><li><strong>主节点记录命令</strong>：在 <code>BGSAVE</code> 期间，主节点会将所有新的写命令记录在一个**复制缓冲区（Replication Buffer）**中。</li><li><strong>传输 RDB 文件</strong>：<code>BGSAVE</code> 完成后，主节点将生成的 RDB 文件发送给从节点。</li><li><strong>从节点加载 RDB</strong>：从节点接收并加载 RDB 文件，从而获得与主节点相同的数据。</li><li><strong>传输复制缓冲区</strong>：主节点将复制缓冲区中记录的写命令发送给从节点。从节点执行这些命令，以追赶上主节点在 <code>BGSAVE</code> 期间的最新数据。</li></ol><h3 id="_2-断线重连后的增量同步" tabindex="-1"><a class="header-anchor" href="#_2-断线重连后的增量同步"><span>2. 断线重连后的增量同步</span></a></h3><p>如果主从连接意外断开（如网络波动），当从节点重新连接时，会尝试进行增量同步。</p><ol><li><strong>从节点发送 <code>PSYNC</code> 命令</strong>：从节点向主节点发送 <code>PSYNC &lt;master_replid&gt; &lt;offset&gt;</code> 命令，其中 <code>&lt;master_replid&gt;</code> 是主节点的 ID，<code>&lt;offset&gt;</code> 是从节点已同步的命令偏移量。</li><li><strong>主节点检查</strong>：主节点会检查从节点提供的偏移量，看其请求的命令是否仍在**复制积压缓冲区（Replication Backlog）**中。 <ul><li><strong>如果在：</strong> 主节点只需将积压缓冲区中从断开点开始的命令发送给从节点即可。</li><li><strong>如果不在：</strong> 说明断开时间太长，积压缓冲区的数据已被覆盖。此时，主节点会强制执行一次全量同步。</li></ul></li></ol><h2 id="复制的配置步骤" tabindex="-1"><a class="header-anchor" href="#复制的配置步骤"><span>复制的配置步骤</span></a></h2><p>Redis 复制的配置非常简单，通常只需要在从节点上进行配置。</p><h3 id="步骤-1-启动主节点" tabindex="-1"><a class="header-anchor" href="#步骤-1-启动主节点"><span>步骤 1: 启动主节点</span></a></h3><p>启动一个 Redis 实例作为主节点。默认情况下，所有 Redis 实例都是主节点。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>redis-server /path/to/master/redis.conf</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="步骤-2-启动从节点并配置复制" tabindex="-1"><a class="header-anchor" href="#步骤-2-启动从节点并配置复制"><span>步骤 2: 启动从节点并配置复制</span></a></h3><p>启动另一个 Redis 实例作为从节点，并在其配置文件中添加或使用 <code>REPLICAOF</code> 命令指定主节点。</p><h4 id="方式一-配置文件-推荐" tabindex="-1"><a class="header-anchor" href="#方式一-配置文件-推荐"><span>方式一：配置文件（推荐）</span></a></h4><p>在从节点的 <code>redis.conf</code> 文件中添加以下配置：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># 开启复制，指定主节点的 IP 和端口</span></span>
<span class="line"><span>replicaof &lt;master_ip&gt; &lt;master_port&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后启动从节点：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>redis-server /path/to/replica/redis.conf</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="方式二-动态命令" tabindex="-1"><a class="header-anchor" href="#方式二-动态命令"><span>方式二：动态命令</span></a></h4><p>在从节点启动后，通过 <code>redis-cli</code> 连接并执行 <code>REPLICAOF</code> 命令。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># 在从节点上执行</span></span>
<span class="line"><span>redis-cli</span></span>
<span class="line"><span>127.0.0.1:6379&gt; REPLICAOF &lt;master_ip&gt; &lt;master_port&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="案例说明" tabindex="-1"><a class="header-anchor" href="#案例说明"><span>案例说明</span></a></h2><h3 id="案例一-读写分离和高可用性" tabindex="-1"><a class="header-anchor" href="#案例一-读写分离和高可用性"><span>案例一：读写分离和高可用性</span></a></h3><p>Redis 复制最典型的应用场景是实现<strong>读写分离</strong>和提供<strong>高可用性</strong>。</p><p><strong>场景描述</strong></p><p>假设你有一个高并发的电商应用。在促销活动期间，商品的库存、订单状态等数据更新频繁，同时又有大量的用户请求查询商品详情。</p><ul><li><strong>写操作（Writes）：</strong> 更新库存、创建订单等。</li><li><strong>读操作（Reads）：</strong> 查询商品信息、查看购物车等。</li></ul><p><strong>解决方案</strong></p><p>我们可以使用 Redis 复制来搭建一个主从架构，将读和写请求分开处理。</p><p><strong>详细操作步骤和命令：</strong></p><ol><li><strong>启动主节点：</strong><ul><li>在服务器 A 上，启动一个 Redis 实例，监听默认端口 <code>6379</code>。</li><li><code>redis-server</code></li><li><strong>验证：</strong> 连接到主节点并写入数据。</li><li><code>redis-cli -p 6379</code></li><li><code>127.0.0.1:6379&gt; SET product:1001:stock 100</code></li></ul></li><li><strong>启动从节点：</strong><ul><li>在服务器 B 上，启动一个 Redis 实例，监听不同端口，并配置其为主节点的从节点。</li><li><code>redis-server --port 6380 --replicaof &lt;master_ip&gt; 6379</code></li><li><strong>验证：</strong> 连接到从节点并尝试读取数据。</li><li><code>redis-cli -p 6380</code></li><li><code>127.0.0.1:6380&gt; GET product:1001:stock</code></li><li><code>&quot;100&quot;</code></li><li><strong>注意：</strong> 从节点只能读，尝试写入会失败。</li><li><code>127.0.0.1:6380&gt; SET new_key &quot;new_value&quot;</code></li><li><code>(error) READONLY You can&#39;t write against a read only replica.</code></li></ul></li><li><strong>读写分离：</strong><ul><li>在你的应用代码中，配置数据源。</li><li><strong>写操作：</strong> 所有 <code>SET</code>, <code>HSET</code>, <code>LPUSH</code> 等命令，都发送到主节点 <code>127.0.0.1:6379</code>。</li><li><strong>读操作：</strong> 所有 <code>GET</code>, <code>HGETALL</code>, <code>LRANGE</code> 等命令，都随机发送到从节点 <code>127.0.0.1:6380</code>。</li></ul></li></ol><p><strong>优点</strong></p><ul><li><strong>提升吞吐量</strong>：将读写操作分散到不同的节点上，可以显著提高系统的并发处理能力。尤其是读请求量远大于写请求量时，效果更佳。</li><li><strong>数据冗余</strong>：从节点保存了主节点的数据副本。即使主节点发生故障，从节点仍然可以提供服务，保证了数据不丢失和业务的连续性。</li><li><strong>故障转移（Failover）</strong>：如果主节点宕机，可以手动（或通过 Sentinel、Cluster 自动）将一个从节点晋升为新的主节点，从而快速恢复服务。</li></ul><h3 id="案例二-数据持久化与故障恢复" tabindex="-1"><a class="header-anchor" href="#案例二-数据持久化与故障恢复"><span>案例二：数据持久化与故障恢复</span></a></h3><p>除了高可用性，Redis 复制也是实现数据持久化和故障恢复的重要手段。</p><p><strong>场景描述</strong></p><p>你的应用对数据丢失零容忍。如果主节点因为服务器宕机或意外重启而关闭，你需要保证数据不会丢失。</p><p><strong>解决方案</strong></p><p>即使主节点没有开启 RDB 或 AOF 持久化，从节点也充当了数据的备份。</p><p><strong>详细操作步骤和命令：</strong></p><ol><li><strong>模拟主节点宕机：</strong><ul><li>假设你的主节点正在运行，并已经同步了数据到从节点。</li><li>使用 <code>kill</code> 命令强制关闭主节点进程。</li><li><code>kill -9 &lt;master_pid&gt;</code></li><li><strong>验证：</strong> 连接主节点会失败。</li><li><code>redis-cli -p 6379</code></li><li><code>Could not connect to Redis at 127.0.0.1:6379: Connection refused</code></li></ul></li><li><strong>从节点检查：</strong><ul><li>从节点此时仍然可用，但它会显示与主节点断开连接。</li><li><code>redis-cli -p 6380</code></li><li><code>127.0.0.1:6380&gt; INFO replication</code></li><li><code># Replication...master_host:&lt;master_ip&gt;...master_link_status:down</code></li></ul></li><li><strong>手动恢复（将从节点晋升为主节点）：</strong><ul><li>在从节点上执行 <code>REPLICAOF NO ONE</code> 命令，让它停止复制，并晋升为一个新的主节点。</li><li><code>127.0.0.1:6380&gt; REPLICAOF NO ONE</code></li><li><code>OK</code></li><li><strong>验证：</strong> 现在这个从节点可以接受写请求了。</li><li><code>127.0.0.1:6380&gt; INFO replication</code></li><li><code># Replication...role:master</code></li><li><code>127.0.0.1:6380&gt; SET new_key &quot;new_value&quot;</code></li><li><code>OK</code></li></ul></li></ol><p><strong>优点</strong></p><ul><li><strong>增强数据安全性</strong>：复制提供了实时的数据冗余，即使主节点完全无法恢复，数据也已经在从节点上有了备份。</li><li><strong>快速恢复</strong>：通过手动或自动的方式，可以迅速将服务切换到从节点，大大缩短服务中断时间。</li></ul><h2 id="复制的注意事项" tabindex="-1"><a class="header-anchor" href="#复制的注意事项"><span>复制的注意事项</span></a></h2><ol><li><strong>数据一致性</strong>：Redis 的复制是<strong>异步</strong>的。这意味着主节点执行完命令后会立即返回，而不会等待从节点同步完成。在网络延迟高的情况下，主从之间可能存在短暂的数据不一致。</li><li><strong>读请求分配</strong>：在读写分离架构中，客户端需要智能地将读请求分发到从节点，将写请求分发到主节点。这通常需要由客户端或代理层来完成。</li><li><strong>主节点故障</strong>：当主节点宕机时，如果没有 Sentinel 或 Cluster 这样的高可用组件，需要手动将一个从节点晋升为新的主节点，并让其他从节点连接到新主节点。</li></ol>`,50)]))}const d=i(n,[["render",t]]),c=JSON.parse('{"path":"/nosqldb/t9mr66aj/","title":"Redis复制介绍","lang":"zh-CN","frontmatter":{"title":"Redis复制介绍","createTime":"2025/08/26 13:28:28","permalink":"/nosqldb/t9mr66aj/"},"readingTime":{"minutes":6.62,"words":1986},"git":{"createdTime":1756736713000},"filePathRelative":"notes/nosqldb/redises/Redis复制介绍.md","headers":[]}');export{d as comp,c as data};
