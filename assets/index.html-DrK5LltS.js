import{a as n,c as a,b as e,o as i}from"./app-ZQgO6-gU.js";const l={};function p(d,s){return i(),a("div",null,s[0]||(s[0]=[e(`<h2 id="什么是-redis-管道" tabindex="-1"><a class="header-anchor" href="#什么是-redis-管道"><span>什么是 Redis 管道？</span></a></h2><p>Redis 管道（Pipelining）是 Redis 客户端的一个重要功能，它允许客户端在一次往返（round-trip）通信中，<strong>批量发送多条命令到服务器</strong>，然后一次性接收所有命令的执行结果。</p><p>在没有使用管道的情况下，客户端每发送一条命令，都必须等待服务器的响应才能发送下一条命令。这个过程是串行的，每次往返都会产生网络延迟（latency），这在处理大量命令时会显著降低性能。</p><p><strong>管道的核心思想就是减少网络往返次数（Round-Trip Time, RTT）。</strong></p><h2 id="为什么需要管道" tabindex="-1"><a class="header-anchor" href="#为什么需要管道"><span>为什么需要管道？</span></a></h2><p>假设你需要在 Redis 中执行 1000 条命令。</p><ul><li><p><strong>没有管道：</strong></p><ol><li>客户端发送 <code>COMMAND_1</code>。</li><li>等待服务器返回 <code>RESULT_1</code>。</li><li>客户端发送 <code>COMMAND_2</code>。</li><li>等待服务器返回 <code>RESULT_2</code>。</li><li>...重复 1000 次...</li></ol><p>总耗时 = 1000 * (命令执行时间 + 网络往返时间)</p></li><li><p><strong>使用管道：</strong></p><ol><li>客户端一次性发送 <code>COMMAND_1</code> 到 <code>COMMAND_1000</code>。</li><li>等待服务器返回所有命令的 <code>RESULT_1</code> 到 <code>RESULT_1000</code>。</li></ol><p>总耗时 = 1 * (网络往返时间) + 1000 * (命令执行时间)</p></li></ul><p>可以看到，使用管道后，网络往返的开销从 <code>1000 次</code> 减少到了 <strong><code>1 次</code></strong>，这使得在高延迟的网络环境下，性能提升尤为明显。</p><h2 id="管道的实现机制" tabindex="-1"><a class="header-anchor" href="#管道的实现机制"><span>管道的实现机制</span></a></h2><p>管道的实现主要依赖于客户端库。客户端在本地维护一个缓冲区，当调用 <code>pipelined()</code> 或类似方法时，命令并不会立即发送到服务器，而是先暂存在这个缓冲区里。</p><p>当所有命令都添加到缓冲区后，客户端会执行一个 <code>execute()</code> 或 <code>sync()</code> 方法，将缓冲区中的所有命令一次性打包发送给 Redis 服务器。服务器会顺序执行这些命令，并将所有结果打包返回给客户端。</p><p><strong>需要注意的是，管道并不能原子化地执行这些命令。</strong> 这意味着在管道执行过程中，如果其他客户端的命令插入进来，可能会改变某些命令的执行结果。如果需要原子性，你应该使用 <strong><code>MULTI</code> / <code>EXEC</code></strong> 事务。</p><h2 id="管道与事务-transactions-的区别" tabindex="-1"><a class="header-anchor" href="#管道与事务-transactions-的区别"><span>管道与事务（Transactions）的区别</span></a></h2><p>这是两个经常被混淆的概念，但它们的用途完全不同。</p><table><thead><tr><th>特性</th><th>管道（Pipelining）</th><th>事务（Transactions）</th></tr></thead><tbody><tr><td><strong>主要目的</strong></td><td>优化网络通信，减少 RTT</td><td>保证命令的原子性执行</td></tr><tr><td><strong>原子性</strong></td><td><strong>不具备</strong>。命令在执行过程中可以被其他客户端的命令打断。</td><td><strong>具备</strong>。<code>MULTI</code> 和 <code>EXEC</code> 之间的所有命令会作为一个单独的、不可分割的操作序列执行。</td></tr><tr><td><strong>错误处理</strong></td><td>即使中间有命令执行失败，管道中的其他命令也会继续执行。</td><td>在 <code>EXEC</code> 之前，如果命令语法错误，整个事务都会被放弃。</td></tr><tr><td><strong>用例</strong></td><td>批量写入、批量读取等对性能要求高、但对原子性要求不严格的场景。</td><td>需要保证一组操作要么全部成功，要么全部失败的场景。</td></tr></tbody></table><p><strong>总结：</strong> 管道是性能优化手段，事务是原子性保证手段。它们可以结合使用：将事务中的多条命令用管道一次性发送，既能保证原子性，又能减少网络开销。</p><h2 id="管道的应用案例" tabindex="-1"><a class="header-anchor" href="#管道的应用案例"><span>管道的应用案例</span></a></h2><h3 id="案例一-批量写入数据" tabindex="-1"><a class="header-anchor" href="#案例一-批量写入数据"><span>案例一：批量写入数据</span></a></h3><p>假设你有一个程序，需要将 10000 个用户的数据（如用户名、用户ID）批量写入 Redis 中。</p><p><strong>不使用管道：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>for (int i = 0; i &lt; 10000; i++) {</span></span>
<span class="line"><span>    // 每次循环都会产生一次网络往返</span></span>
<span class="line"><span>    jedis.set(&quot;user:&quot; + i, &quot;data&quot; + i);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码会执行 10000 次网络请求，每次请求都需要等待 Redis 服务器的响应，这会产生巨大的网络延迟开销。</p><p><strong>使用管道：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>Pipeline p = jedis.pipelined();</span></span>
<span class="line"><span>for (int i = 0; i &lt; 10000; i++) {</span></span>
<span class="line"><span>    // 命令被缓存到客户端本地，不会立即发送</span></span>
<span class="line"><span>    p.set(&quot;user:&quot; + i, &quot;data&quot; + i);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>// 一次性发送所有命令</span></span>
<span class="line"><span>p.sync();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过使用管道，所有 10000 条 <code>SET</code> 命令在本地缓冲区中积累，然后一次性发送给 Redis 服务器。服务器执行完所有命令后，一次性将结果返回给客户端。这极大地减少了网络往返次数，从而大幅提升了写入性能。</p><h3 id="案例二-批量读取数据" tabindex="-1"><a class="header-anchor" href="#案例二-批量读取数据"><span>案例二：批量读取数据</span></a></h3><p>在某些业务场景下，你需要一次性获取多个 Redis key 的值。</p><p><strong>不使用管道：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>// 获取多个 key，每次都发送一次请求</span></span>
<span class="line"><span>String value1 = jedis.get(&quot;key1&quot;);</span></span>
<span class="line"><span>String value2 = jedis.get(&quot;key2&quot;);</span></span>
<span class="line"><span>String value3 = jedis.get(&quot;key3&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用管道：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>Pipeline p = jedis.pipelined();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 在管道中添加多个 GET 命令</span></span>
<span class="line"><span>p.get(&quot;key1&quot;);</span></span>
<span class="line"><span>p.get(&quot;key2&quot;);</span></span>
<span class="line"><span>p.get(&quot;key3&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 批量执行，并获取结果列表</span></span>
<span class="line"><span>List&lt;Object&gt; results = p.syncAndReturnAll();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 从结果列表中获取每个 key 的值</span></span>
<span class="line"><span>String value1 = (String) results.get(0);</span></span>
<span class="line"><span>String value2 = (String) results.get(1);</span></span>
<span class="line"><span>String value3 = (String) results.get(2);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过管道，我们同样可以将多次 <code>GET</code> 请求合并为一次，显著减少了网络开销。</p><h3 id="案例三-结合事务使用" tabindex="-1"><a class="header-anchor" href="#案例三-结合事务使用"><span>案例三：结合事务使用</span></a></h3><p>假设你的业务需要原子性地增加一个计数器，并设置一个过期时间。</p><p><strong>不使用管道和事务：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>// 这不是原子操作，其他客户端可能会在 INCR 和 EXPIRE 之间插入操作</span></span>
<span class="line"><span>jedis.incr(&quot;counter&quot;);</span></span>
<span class="line"><span>jedis.expire(&quot;counter&quot;, 3600);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用管道和事务（最佳实践）：</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>Pipeline p = jedis.pipelined();</span></span>
<span class="line"><span>// 开启事务</span></span>
<span class="line"><span>p.multi(); </span></span>
<span class="line"><span>// 命令被加入到事务队列中</span></span>
<span class="line"><span>p.incr(&quot;counter&quot;);</span></span>
<span class="line"><span>p.expire(&quot;counter&quot;, 3600);</span></span>
<span class="line"><span>// 执行事务，同时通过管道发送</span></span>
<span class="line"><span>p.exec(); </span></span>
<span class="line"><span>p.sync();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子展示了如何将管道和事务结合起来：<code>multi()</code> 和 <code>exec()</code> 保证了操作的原子性，而 <code>pipelined()</code> 则保证了这两个命令（以及它们中间的所有命令）通过一次网络往返被发送和执行，从而兼顾了原子性和性能。</p><h2 id="常见-redis-客户端的管道使用示例" tabindex="-1"><a class="header-anchor" href="#常见-redis-客户端的管道使用示例"><span>常见 Redis 客户端的管道使用示例</span></a></h2><h3 id="java-jedis" tabindex="-1"><a class="header-anchor" href="#java-jedis"><span>Java (Jedis)</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>import redis.clients.jedis.Jedis;</span></span>
<span class="line"><span>import redis.clients.jedis.Pipeline;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public class PipeliningExample {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        try (Jedis jedis = new Jedis(&quot;localhost&quot;)) {</span></span>
<span class="line"><span>            Pipeline p = jedis.pipelined();</span></span>
<span class="line"><span>            </span></span>
<span class="line"><span>            // 在管道中添加多条命令</span></span>
<span class="line"><span>            p.set(&quot;user:101&quot;, &quot;name:Alice&quot;);</span></span>
<span class="line"><span>            p.set(&quot;user:102&quot;, &quot;name:Bob&quot;);</span></span>
<span class="line"><span>            p.set(&quot;user:103&quot;, &quot;name:Charlie&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            // 执行管道，一次性发送所有命令并接收结果</span></span>
<span class="line"><span>            p.sync();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="python-redis-py" tabindex="-1"><a class="header-anchor" href="#python-redis-py"><span>Python (redis-py)</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>import redis</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 连接到 Redis</span></span>
<span class="line"><span>r = redis.Redis(host=&#39;localhost&#39;, port=6379, db=0)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 创建管道对象</span></span>
<span class="line"><span>pipe = r.pipeline()</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 在管道中添加多条命令</span></span>
<span class="line"><span>pipe.set(&#39;key1&#39;, &#39;value1&#39;)</span></span>
<span class="line"><span>pipe.set(&#39;key2&#39;, &#39;value2&#39;)</span></span>
<span class="line"><span>pipe.get(&#39;key1&#39;)</span></span>
<span class="line"><span>pipe.get(&#39;key2&#39;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 执行管道，返回所有命令的结果列表</span></span>
<span class="line"><span>results = pipe.execute()</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 打印结果</span></span>
<span class="line"><span>print(results)</span></span>
<span class="line"><span># 输出: [True, True, b&#39;value1&#39;, b&#39;value2&#39;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="node-js-ioredis" tabindex="-1"><a class="header-anchor" href="#node-js-ioredis"><span>Node.js (ioredis)</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>const Redis = require(&#39;ioredis&#39;);</span></span>
<span class="line"><span>const redis = new Redis();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 使用管道</span></span>
<span class="line"><span>const pipeline = redis.pipeline();</span></span>
<span class="line"><span>pipeline.set(&#39;foo&#39;, &#39;bar&#39;);</span></span>
<span class="line"><span>pipeline.incr(&#39;counter&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 执行管道</span></span>
<span class="line"><span>pipeline.exec().then((results) =&gt; {</span></span>
<span class="line"><span>  // 结果是一个数组，每个元素包含 [error, result]</span></span>
<span class="line"><span>  console.log(results);</span></span>
<span class="line"><span>  // 输出: [[null, &#39;OK&#39;], [null, 1]]</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="管道使用的注意事项" tabindex="-1"><a class="header-anchor" href="#管道使用的注意事项"><span>管道使用的注意事项</span></a></h2><ol><li><strong>内存占用：</strong> 管道操作会将所有命令和结果都缓存在客户端内存中。如果一次性发送的命令数量过多（例如数百万条），可能会导致客户端内存溢出。因此，应该控制每次管道发送的命令数量，例如分批次（batch）执行。</li><li><strong>网络开销：</strong> 管道虽然减少了往返次数，但仍然需要将所有命令的数据传输到服务器。如果命令数据量巨大，传输本身也会有开销。</li><li><strong>阻塞：</strong> 在管道执行期间，客户端会阻塞，直到所有命令结果都返回。这在大规模并发场景下，可能会导致短暂的性能瓶颈。</li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>Redis 管道是一个非常高效的性能优化工具，尤其是在需要批量执行命令的场景中。它通过减少网络往返次数来显著提升 Redis 的吞吐量。</p><p>学习和理解管道与事务的区别至关重要，这能帮助你在不同的应用场景中做出正确的选择。在实际项目中，合理使用管道可以充分发挥 Redis 的高性能优势。</p><p>希望这些更详细的案例能帮助您更好地掌握 Redis 管道。您还有什么其他想了解的吗？</p>`,52)]))}const t=n(l,[["render",p]]),c=JSON.parse('{"path":"/nosqldb/rdoy93y7/","title":"Redis管道","lang":"zh-CN","frontmatter":{"title":"Redis管道","createTime":"2025/08/26 13:19:41","permalink":"/nosqldb/rdoy93y7/"},"readingTime":{"minutes":6.8,"words":2039},"git":{"createdTime":1756736713000},"filePathRelative":"notes/nosqldb/redises/Redis管道.md","headers":[]}');export{t as comp,c as data};
