import{a as l,c as n,b as e,o as s}from"./app-ZQgO6-gU.js";const a={};function t(o,i){return s(),n("div",null,i[0]||(i[0]=[e(`<ul><li><h3 id="_1-beanfactory-和-applicationcontext-区别" tabindex="-1"><a class="header-anchor" href="#_1-beanfactory-和-applicationcontext-区别"><span>1. BeanFactory 和 ApplicationContext 区别</span></a></h3><p><strong>BeanFactory</strong>：</p><ul><li>可以理解成一个“懒汉式工厂”，只有在你需要对象时才去创建；</li><li>提供基本的依赖注入和生命周期管理；</li><li>内存占用小，适合轻量级容器。</li></ul><p><strong>ApplicationContext</strong>：</p><ul><li>是 BeanFactory 的增强版，相当于“全能工厂”，在容器启动时就实例化单例 Bean；</li><li>除了基本功能，还支持： <ol><li>国际化消息（i18n）</li><li>事件监听（ApplicationEvent）</li><li>统一资源访问（properties、XML）</li></ol></li><li>更适合企业级 Web 应用。</li></ul><blockquote><p>类比：BeanFactory 就像一个咖啡机，只在你按按钮时才煮咖啡；ApplicationContext 就像咖啡馆，开门时就准备好了咖啡，还提供糖、奶等附加服务。</p></blockquote><hr><h3 id="_2-spring-bean-生命周期" tabindex="-1"><a class="header-anchor" href="#_2-spring-bean-生命周期"><span>2. Spring Bean 生命周期</span></a></h3><p><strong>生命周期步骤</strong>：</p><ol><li><strong>实例化</strong>：Spring 通过反射创建 Bean 对象。</li><li><strong>依赖注入</strong>：填充对象的属性或调用构造器注入依赖。</li><li><strong>Aware 回调</strong>： <ul><li><code>BeanNameAware</code>：获取 Bean 名称；</li><li><code>BeanFactoryAware</code>：获取容器实例；</li></ul></li><li><strong>初始化</strong>： <ul><li><code>afterPropertiesSet()</code>（InitializingBean 接口）；</li><li>配置 <code>init-method</code>；</li><li>注解方式 <code>@PostConstruct</code>。</li></ul></li><li><strong>使用阶段</strong>：Bean 被应用使用。</li><li><strong>销毁阶段</strong>： <ul><li><code>DisposableBean.destroy()</code>；</li><li>配置 <code>destroy-method</code>；</li><li>注解 <code>@PreDestroy</code>。</li></ul></li></ol><blockquote><p>类比：Bean 的生命周期就像开车：造车（实例化）→加油/配件（依赖注入）→检查仪表（Aware 回调）→上路驾驶（使用）→停车拆除（销毁）。</p></blockquote><hr><h3 id="_3-spring-ioc-实现" tabindex="-1"><a class="header-anchor" href="#_3-spring-ioc-实现"><span>3. Spring IOC 实现</span></a></h3><ul><li><strong>核心包</strong>：<code>org.springframework.beans</code> + <code>org.springframework.context</code>。</li><li><strong>流程</strong>： <ol><li>读取 Bean 配置（XML / 注解）。</li><li>根据配置实例化 Bean。</li><li>注入依赖（DI）。</li><li>注册回调/生命周期处理。</li></ol></li><li><strong>ApplicationContext</strong> 扩展： <ul><li>事件监听（EventListener）</li><li>国际化</li><li>与 AOP 更好集成</li></ul></li></ul><blockquote><p>本质：IoC 容器负责创建对象、管理依赖、管理生命周期，让开发者只关注业务逻辑。</p></blockquote><hr><h3 id="_4-spring-aop" tabindex="-1"><a class="header-anchor" href="#_4-spring-aop"><span>4. Spring AOP</span></a></h3><ul><li><strong>面向切面编程</strong>：将横切关注点（日志、权限、事务）从核心业务逻辑中分离；</li><li><strong>组成</strong>： <ol><li><strong>切面（Aspect）</strong>：增强逻辑集合；</li><li><strong>切点（Pointcut）</strong>：匹配哪些方法需要增强；</li><li><strong>通知（Advice）</strong>：增强逻辑（前置/后置/环绕）；</li><li><strong>目标对象（Target）</strong>：被增强的类或方法；</li></ol></li><li><strong>用途</strong>：记录日志、性能监控、事务管理、权限检查。</li></ul><hr><h3 id="_5-spring-aop-实现原理" tabindex="-1"><a class="header-anchor" href="#_5-spring-aop-实现原理"><span>5. Spring AOP 实现原理</span></a></h3><ul><li><strong>JDK 动态代理</strong>： <ul><li>只能代理接口；</li><li>核心类：<code>Proxy</code> + <code>InvocationHandler</code>；</li></ul></li><li><strong>CGLIB 动态代理</strong>： <ul><li>生成目标类的子类；</li><li>目标类不能为 <code>final</code>；</li></ul></li><li>Spring 会根据目标类是否实现接口自动选择代理方式。</li></ul><blockquote><p>比喻：JDK 代理像是在接口外套一层保护壳；CGLIB 代理像是在类上生成一个子类，继承并增强功能。</p></blockquote><hr><h3 id="_6-动态代理-cglib-与-jdk-优劣势" tabindex="-1"><a class="header-anchor" href="#_6-动态代理-cglib-与-jdk-优劣势"><span>6. 动态代理（CGLIB 与 JDK）优劣势</span></a></h3><table><thead><tr><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>JDK</td><td>内存占用小，接口代理简单</td><td>只能代理接口</td></tr><tr><td>CGLIB</td><td>能代理普通类，无需接口</td><td>占用内存大，final 类不能代理</td></tr></tbody></table><hr><h3 id="_7-spring-事务实现方式" tabindex="-1"><a class="header-anchor" href="#_7-spring-事务实现方式"><span>7. Spring 事务实现方式</span></a></h3><ol><li><p><strong>编程式事务</strong>：</p><ul><li>手动控制事务，类似 JDBC 代码：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>try {</span></span>
<span class="line"><span>    conn.setAutoCommit(false);</span></span>
<span class="line"><span>    // 执行业务</span></span>
<span class="line"><span>    conn.commit();</span></span>
<span class="line"><span>} catch (Exception e) {</span></span>
<span class="line"><span>    conn.rollback();</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>声明式事务</strong>：</p><ul><li><strong>XML 配置</strong>：在 XML 中声明事务；</li><li><strong>注解方式</strong>：<code>@Transactional</code>，可指定传播机制、隔离级别。</li></ul></li></ol><hr><h3 id="_8-spring-事务底层原理" tabindex="-1"><a class="header-anchor" href="#_8-spring-事务底层原理"><span>8. Spring 事务底层原理</span></a></h3><ol><li><strong>IOC 划分事务单元</strong>： <ul><li>配置事务管理器、事务属性；</li></ul></li><li><strong>AOP 拦截目标方法</strong>： <ul><li><code>TransactionProxyFactoryBean</code> 生成代理对象；</li><li><code>TransactionInterceptor</code> 拦截方法；</li></ul></li><li><strong>事务处理</strong>： <ul><li>事务开始 → 执行方法 → 提交 / 回滚；</li><li>通过 <code>PlatformTransactionManager</code> 完成不同数据源的事务控制。</li></ul></li></ol><blockquote><p>类比：AOP 拦截像门卫，事务管理器像保险柜，方法执行时先检查锁定状态，执行完再释放。</p></blockquote><hr><h3 id="_9-自定义注解实现功能" tabindex="-1"><a class="header-anchor" href="#_9-自定义注解实现功能"><span>9. 自定义注解实现功能</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>@Target(ElementType.METHOD) // 注解作用于方法</span></span>
<span class="line"><span>@Retention(RetentionPolicy.RUNTIME) // 运行时保留</span></span>
<span class="line"><span>public @interface LogExecutionTime {</span></span>
<span class="line"><span>    String value() default &quot;&quot;;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>方法限制</strong>： <ul><li>返回值只能是基本类型、String、Enum、Annotation 或数组；</li><li>可以有默认值；</li></ul></li><li><strong>元注解</strong>： <ul><li><code>@Target</code>：限定作用范围</li><li><code>@Retention</code>：生命周期</li><li><code>@Documented</code>、<code>@Inherited</code>：可选</li></ul></li></ul><blockquote><p>实际应用：结合 AOP，实现方法执行时间统计、权限检查、日志记录等功能。</p></blockquote><hr><h3 id="_10-spring-mvc-运行流程" tabindex="-1"><a class="header-anchor" href="#_10-spring-mvc-运行流程"><span>10. Spring MVC 运行流程</span></a></h3><ol><li>用户请求 → <strong>DispatcherServlet</strong></li><li>DispatcherServlet 查询 <strong>HandlerMapping</strong> → 找到对应 Controller</li><li>Controller 执行业务逻辑 → 返回 <strong>ModelAndView</strong></li><li>DispatcherServlet 调用 <strong>ViewResolver</strong> → 渲染视图</li><li>返回响应给用户</li></ol><blockquote><p>类比：DispatcherServlet 是总调度员，Controller 是执行员，ViewResolver 是画图员，最后返回成品（网页）给客户。</p></blockquote><hr><h3 id="_12-为什么选择-netty" tabindex="-1"><a class="header-anchor" href="#_12-为什么选择-netty"><span>12. 为什么选择 Netty</span></a></h3><ul><li>高性能网络框架，异步、事件驱动；</li><li>相比原生 NIO： <ul><li>解决了 epoll / select Bug；</li><li>提供内存池、零拷贝；</li><li>高并发性能好；</li></ul></li><li>适合 IM、RPC、游戏服务器、HTTP/2。</li></ul><hr><h3 id="_13-netty-使用场景" tabindex="-1"><a class="header-anchor" href="#_13-netty-使用场景"><span>13. Netty 使用场景</span></a></h3><ul><li>游戏服务器（高并发连接）</li><li>IM / 聊天系统</li><li>HTTP/HTTPS 服务</li><li>RPC 框架底层（Dubbo Netty）</li></ul><hr><h3 id="_15-tcp-粘包-拆包" tabindex="-1"><a class="header-anchor" href="#_15-tcp-粘包-拆包"><span>15. TCP 粘包/拆包</span></a></h3><ul><li><strong>原因</strong>：TCP 是流式协议，没有消息边界，连续发送的数据可能被合并（粘包）或拆开（拆包）；</li><li><strong>表现</strong>： <ul><li>客户端一次读取到多条消息 → 粘包</li><li>数据分成多次读取 → 拆包</li></ul></li></ul><hr><h3 id="_16-tcp-粘包-拆包解决办法" tabindex="-1"><a class="header-anchor" href="#_16-tcp-粘包-拆包解决办法"><span>16. TCP 粘包/拆包解决办法</span></a></h3><ol><li><strong>固定长度</strong>：每条消息固定长度；</li><li><strong>分隔符</strong>：特殊字符标记消息边界；</li><li><strong>消息头 + 长度</strong>：消息前面放长度字段，接收端按长度读取；</li><li><strong>Netty 内置解码器</strong>： <ul><li><code>LengthFieldBasedFrameDecoder</code></li><li><code>DelimiterBasedFrameDecoder</code></li></ul></li></ol><hr><h3 id="_17-netty-线程模型" tabindex="-1"><a class="header-anchor" href="#_17-netty-线程模型"><span>17. Netty 线程模型</span></a></h3><ul><li><strong>Boss</strong>：负责接收连接，注册到 Worker；</li><li><strong>Worker</strong>：处理 I/O 读写事件；</li><li><strong>EventLoopGroup</strong>： <ul><li>一个线程可以处理多个 Channel；</li><li>减少线程切换，提高吞吐量。</li></ul></li></ul><hr><h3 id="_18-netty-零拷贝" tabindex="-1"><a class="header-anchor" href="#_18-netty-零拷贝"><span>18. Netty 零拷贝</span></a></h3><ul><li><strong>概念</strong>：减少数据从内核态到用户态的复制次数，提高性能；</li><li><strong>实现方式</strong>： <ol><li><strong>FileRegion / sendfile</strong>：内核直接传输文件数据；</li><li><strong>CompositeByteBuf</strong>：逻辑合并缓冲区，减少内存复制；</li><li><strong>DirectBuffer</strong>：使用直接内存（非 JVM 堆）；</li></ol></li><li><strong>优势</strong>： <ul><li>提高吞吐量；</li><li>减少 CPU 消耗；</li><li>适合大文件传输和高并发网络应用。</li></ul></li></ul></li></ul>`,1)]))}const c=l(a,[["render",t]]),d=JSON.parse('{"path":"/bigcompany/knhzvs96/","title":"百度-Java中级","lang":"zh-CN","frontmatter":{"title":"百度-Java中级","createTime":"2025/08/21 13:16:37","permalink":"/bigcompany/knhzvs96/"},"readingTime":{"minutes":4.81,"words":1444},"git":{"createdTime":1756736713000},"filePathRelative":"notes/bigcompany/company/百度-Java中级.md","headers":[]}');export{c as comp,d as data};
