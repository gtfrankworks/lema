import{a as e,c as i,b as a,o as n}from"./app-ZQgO6-gU.js";const l={};function d(r,s){return n(),i("div",null,s[0]||(s[0]=[a(`<h2 id="什么是-redis-集群" tabindex="-1"><a class="header-anchor" href="#什么是-redis-集群"><span>什么是 Redis 集群？</span></a></h2><p>Redis 集群（Redis Cluster）是 Redis 官方提供的分布式解决方案，它允许你将数据自动分片（sharding）到多个 Redis 节点上，并提供高可用性。</p><p>与主从复制和哨兵模式不同，Redis 集群旨在解决<strong>海量数据存储</strong>的问题。它不仅提供了<strong>自动故障转移</strong>功能，还能让整个集群处理远超单个 Redis 实例的数据量和并发请求。</p><p>一个 Redis 集群由多个节点（Node）组成，每个节点都可以是主节点或从节点。</p><ul><li><strong>主节点：</strong> 负责处理数据读写请求，并持有部分数据分片。</li><li><strong>从节点：</strong> 负责复制主节点的数据，提供数据冗余和故障转移支持。</li></ul><h2 id="redis-集群的工作原理" tabindex="-1"><a class="header-anchor" href="#redis-集群的工作原理"><span>Redis 集群的工作原理</span></a></h2><p>Redis 集群通过**哈希槽（Hash Slot）**机制来分配和管理数据。</p><h3 id="_1-哈希槽-hash-slot" tabindex="-1"><a class="header-anchor" href="#_1-哈希槽-hash-slot"><span>1. 哈希槽（Hash Slot）</span></a></h3><ul><li>Redis 集群将整个键空间（key space）划分为 16384 个哈希槽（0 到 16383）。</li><li>每个主节点负责管理其中一部分哈希槽。例如，一个三节点的集群，可能分配如下： <ul><li><strong>主节点 A：</strong> 负责哈希槽 0 到 5460</li><li><strong>主节点 B：</strong> 负责哈希槽 5461 到 10922</li><li><strong>主节点 C：</strong> 负责哈希槽 10923 到 16383</li></ul></li><li>当客户端想要写入或读取一个 key 时，它会根据 <code>CRC16(key) % 16384</code> 的算法计算出该 key 属于哪个哈希槽，然后将请求发送到负责该哈希槽的主节点上。</li></ul><h3 id="_2-自动故障转移" tabindex="-1"><a class="header-anchor" href="#_2-自动故障转移"><span>2. 自动故障转移</span></a></h3><ul><li>Redis 集群的每个节点都会持续与其他节点通信，以监控彼此的状态。</li><li>当一个主节点下线时，集群中的其他主节点会发现这个故障。</li><li>集群会自动从下线的该主节点的从节点中，选举出一个新的从节点来接替它的角色，成为新的主节点。这个过程是完全自动的，无需人工干预。</li></ul><h3 id="_3-数据重分片" tabindex="-1"><a class="header-anchor" href="#_3-数据重分片"><span>3. 数据重分片</span></a></h3><ul><li>Redis 集群支持在线<strong>扩容（Scale Out）和缩容（Scale In）</strong>。</li><li>当需要增加节点时，可以向集群添加新的节点，并将部分哈希槽从现有节点迁移到新节点上。</li><li>当需要移除节点时，可以将其上的哈希槽迁移到其他节点，然后安全地移除该节点。</li></ul><h2 id="redis-集群的配置与搭建" tabindex="-1"><a class="header-anchor" href="#redis-集群的配置与搭建"><span>Redis 集群的配置与搭建</span></a></h2><p>搭建一个 Redis 集群需要至少 3 个主节点，通常每个主节点至少配备一个从节点，以保证高可用性。</p><p><strong>详细操作步骤和命令：</strong></p><p>为了方便演示，我们将在单台服务器上启动 6 个实例来模拟一个三主三从的集群。</p><h3 id="_1-准备配置文件" tabindex="-1"><a class="header-anchor" href="#_1-准备配置文件"><span>1. 准备配置文件</span></a></h3><p>创建 6 个配置文件，例如 <code>redis-7000.conf</code> 到 <code>redis-7005.conf</code>。每个配置文件都应包含以下基本配置：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>port 7000  # 更改为对应端口</span></span>
<span class="line"><span>cluster-enabled yes</span></span>
<span class="line"><span>cluster-config-file nodes-7000.conf</span></span>
<span class="line"><span>cluster-node-timeout 5000</span></span>
<span class="line"><span>appendonly yes # 建议开启AOF持久化</span></span>
<span class="line"><span>daemonize yes # 后台运行</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-启动所有实例" tabindex="-1"><a class="header-anchor" href="#_2-启动所有实例"><span>2. 启动所有实例</span></a></h3><p>分别启动 6 个 Redis 实例。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>redis-server redis-7000.conf</span></span>
<span class="line"><span>redis-server redis-7001.conf</span></span>
<span class="line"><span>redis-server redis-7002.conf</span></span>
<span class="line"><span>redis-server redis-7003.conf</span></span>
<span class="line"><span>redis-server redis-7004.conf</span></span>
<span class="line"><span>redis-server redis-7005.conf</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-创建集群" tabindex="-1"><a class="header-anchor" href="#_3-创建集群"><span>3. 创建集群</span></a></h3><p>使用 <code>redis-cli</code> 工具创建集群。我们将前三个节点设为主节点，后三个节点设为从节点。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># --cluster-replicas 1 表示每个主节点有一个从节点</span></span>
<span class="line"><span># 127.0.0.1:7000, 7001, 7002 将被创建为主节点</span></span>
<span class="line"><span># 127.0.0.1:7003, 7004, 7005 将自动作为从节点加入并复制对应的主节点</span></span>
<span class="line"><span>redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 \\</span></span>
<span class="line"><span>127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在执行命令时，会提示你是否接受集群配置，输入 <code>yes</code>。</p><h3 id="_4-验证集群状态" tabindex="-1"><a class="header-anchor" href="#_4-验证集群状态"><span>4. 验证集群状态</span></a></h3><p>连接到任一节点，查看集群信息。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>redis-cli -p 7000</span></span>
<span class="line"><span>127.0.0.1:7000&gt; CLUSTER INFO</span></span>
<span class="line"><span># 查看集群中的所有节点和它们的角色</span></span>
<span class="line"><span>127.0.0.1:7000&gt; CLUSTER NODES</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="案例说明-数据分片与故障转移" tabindex="-1"><a class="header-anchor" href="#案例说明-数据分片与故障转移"><span>案例说明：数据分片与故障转移</span></a></h2><h3 id="场景描述" tabindex="-1"><a class="header-anchor" href="#场景描述"><span>场景描述</span></a></h3><p>你有一个社交应用，用户数据量巨大。为了应对高并发和大规模数据存储，你决定使用 Redis 集群来存储用户的个人信息和朋友圈动态。</p><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h3><p>利用 Redis 集群的数据分片和高可用性功能，将用户数据分散到不同节点，并保障服务不中断。</p><p><strong>详细操作步骤和命令：</strong></p><ol><li><strong>数据写入：</strong><ul><li>当你存储一个用户的个人信息时，客户端会自动计算 key 的哈希槽，并将其路由到正确的节点。</li><li>假设用户 <code>user:1001</code> 的 key 被计算到哈希槽 <code>1234</code>，而该哈希槽由节点 <code>7000</code> 负责。</li><li><strong>命令：</strong></li><li><code>redis-cli -c -p 7000</code> （-c 表示启用集群模式）</li><li><code>127.0.0.1:7000&gt; SET user:1001:name &quot;Alice&quot;</code></li><li><code>-&gt; Redirected to slot 1234 located at 127.0.0.1:7000</code></li></ul></li><li><strong>主节点故障：</strong><ul><li>假设负责哈希槽 <code>0-5460</code> 的主节点 <code>7000</code> 突然下线。</li><li><strong>操作：</strong> 强制关闭 <code>7000</code> 端口的 Redis 进程。</li><li><strong>故障转移过程：</strong><ol><li>集群中的其他节点（如 <code>7001</code> 和 <code>7002</code>）会发现节点 <code>7000</code> 已经下线。</li><li>它们会选举出节点 <code>7000</code> 的从节点（假设是 <code>7003</code>）来接替它的角色。</li><li>节点 <code>7003</code> 会自动被提升为新的主节点，并继续处理哈希槽 <code>0-5460</code> 的请求。</li></ol></li><li><strong>验证：</strong></li><li><code>redis-cli -p 7001 cluster nodes</code></li><li>几秒后，你会看到节点 <code>7000</code> 的状态变为 <code>fail</code>，而节点 <code>7003</code> 的角色已变为 <code>master</code>。</li></ul></li><li><strong>重新上线：</strong><ul><li>当 <code>7000</code> 节点重新启动后，它会自动作为新主节点 <code>7003</code> 的从节点加入集群，继续进行复制。</li></ul></li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>Redis 集群是 Redis 应对大规模并发和数据存储的终极解决方案。它通过哈希槽的分布式机制，将数据均匀地分散到多个节点，实现了数据的水平扩展。同时，其内置的自动故障转移功能确保了服务的高可用性。</p><p>相较于哨兵模式，Redis 集群不仅提供了高可用性，更重要的是提供了<strong>可扩展性</strong>。当数据量和流量继续增长时，你可以轻松地向集群中添加更多节点，从而满足业务需求。</p>`,40)]))}const o=e(l,[["render",d]]),p=JSON.parse('{"path":"/nosqldb/apr45ujb/","title":"Redis集群","lang":"zh-CN","frontmatter":{"title":"Redis集群","createTime":"2025/08/26 13:33:24","permalink":"/nosqldb/apr45ujb/"},"readingTime":{"minutes":5.16,"words":1548},"git":{"createdTime":1756736713000},"filePathRelative":"notes/nosqldb/redises/Redis集群.md","headers":[]}');export{o as comp,p as data};
