import{a as i,c as n,b as a,o as l}from"./app-ZQgO6-gU.js";const e={};function p(d,s){return l(),n("div",null,s[0]||(s[0]=[a(`<h4 id="key-的命名" tabindex="-1"><a class="header-anchor" href="#key-的命名"><span>key 的命名</span></a></h4><p>同一个 Redis 服务被公司中的各个业务线公用，必须保证 key 的唯一性</p><blockquote><p>业务线名称 + 工程名 + 模块名 + 有意义的key名称</p></blockquote><h4 id="选择合适的数据类型-维护更容易" tabindex="-1"><a class="header-anchor" href="#选择合适的数据类型-维护更容易"><span>选择合适的数据类型，维护更容易</span></a></h4><ul><li>Strings: 应用最广泛，例如：计数器，session 等键值“独立”的数据。</li><li>Hashes: 存储结构化（对象）的数据，KV 共同构成一个对象的信息。</li><li>Lists: 队列、栈、有界队列。</li><li>Sets: 去重、无序的数据集合，在类似于社交的业务功能上有广泛应用，例如：共同关注、共同喜好、数据去重。</li><li>Sorted Sets: 带有权重的集合，在类似于排行榜业务上有广泛应用，且可以实现范围查找。</li></ul><h4 id="使用了事务功能-怎么没回滚呢" tabindex="-1"><a class="header-anchor" href="#使用了事务功能-怎么没回滚呢"><span>使用了事务功能，怎么没回滚呢？</span></a></h4><p>Redis 不支持事务回滚</p><ul><li>Redis 命令只会因为错误的语法而失败，应该在开发的时候就避免这种情况</li><li>因为不需要对回滚进行支持，所以 Redis 内部可以保持简单且快速</li></ul><p>可以使用 DISCARD 放弃事务。</p><h4 id="big-key-影响-redis-性能" tabindex="-1"><a class="header-anchor" href="#big-key-影响-redis-性能"><span>Big Key 影响 Redis 性能</span></a></h4><p>Big Key 是指 key 对应的 value 数据大小非常大，比如：</p><ul><li>字符串大于 10KB</li><li>哈希、列表、集合元素个数 &gt; 5000</li></ul><p>Big Key 的危害：</p><ul><li>内存不均</li><li>超时阻塞</li><li>网络流量拥堵</li><li>过期删除</li><li>迁移困难</li></ul><p>Big Key 怎么产生的：</p><ul><li>社交类场景：粉丝列表，对于明星或者大 V 需要特殊设计</li><li>汇总统计类场景：每天都会产生报表数据，数据汇总到一个 key 里，日积月累就成为了 Big Key</li><li>日常缓存类：对 db 中的数据进行缓存，存在大字段的表可能会产生 Big Key</li></ul><p>如何发现 Big Key：</p><ul><li><code>redis-cli --bigkeys</code>: 给出每种数据结构的 Top 1 Big Key，但无法查出全部 Big Key</li><li>Redis 4.0 开始提供 memory usage 命令，可以计算每个键值的字节数</li></ul><p>删除 Big Key：</p><ul><li>Strings: 可以直接使用 del 命令，不会产生阻塞。</li><li>Hashes: 使用 hscan 命令每次获取一部分，再用 hdel 删除。</li><li>Lists: 使用 ltrm 命令渐进式删除列表元素。</li><li>Sets: 使用 sscan 命令，每次获取部分元素，再使用 srem 命令删除每个元素。</li><li>Sorted Sets: 使用 zscan 命令，每次获取部分元素，再使用 zremrangebyrank 命令删除元素。</li></ul><h4 id="redis-内存耗尽" tabindex="-1"><a class="header-anchor" href="#redis-内存耗尽"><span>Redis 内存耗尽</span></a></h4><ul><li><p>业务不断发展，缓存数据不断增多</p><ul><li>加配置、加机器、集群部署</li></ul></li><li><p>无效的（过期）数据没有及时清理</p><ul><li>使用 expire 命令为 key 设置合理的过期时间（结合业务场景）</li></ul></li><li><p>”冷数据“不要进行缓存</p></li><li><p>修改配置</p></li></ul><div class="language-sh line-numbers-mode" data-highlighter="shiki" data-ext="sh" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-sh"><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">##################################################### MEMORY MANAGEMENT #####################################################</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 将内存使用限制设置为指定的字节数。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 当达到内存限制时，Redis 将根据选择的清除策略(请参阅 maxmemory-policy )尝试删除键。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 如果 Redis 不能根据策略删除键，或者策略被设置为“noeviction”，那么 Redis 将对 write 命令进行错误应答，对 read 命令进行应答。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 当使用 Redis 作为LRU或LFU缓存，或为实例设置硬内存限制(使用“noeviction”策略)时，此选项通常很有用。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># WARNING: 如果已经附加了副本，建议您为 maxmemory 设置一个较低的限制，以便在系统上为副本输出缓冲区提供一些空闲RAM(但如果策略是“noeviction”，则不需要这样做)。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># maxmemory &lt;bytes&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># MAXMEMORY POLICY: 当达到 maxmemory 时，您可以选择五种行为:</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># volatile-lru -&gt; 从设置了过期时间的 key 中使用 LRU 算法进行淘汰。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># allkeys-lru -&gt; 从所有 key 中使用 LRU 算法进行淘汰（推荐）。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># volatile-lfu -&gt; 在设置了过期时间的 key 中使用 LFU 算法淘汰数据。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># allkeys-lfu -&gt; 在所有 key 中使用 LFU 算法淘汰数据。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># volatile-random -&gt; 从设置了过期时间的 key 中随机淘汰。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># allkeys-random -&gt; 从所有 key 中随机淘汰数据。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># volatile-ttl -&gt; 在设置了过期时间的 key 中，根据 key 的过期时间进行淘汰，越早过期的优先被淘汰。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># noeviction -&gt; 不清除（默认策略），对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># LRU means Least Recently Used(最近使用)</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># LFU means Least Frequently Used(最经常使用)</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># LRU、LFU 和 volatile-ttl 都是使用近似随机算法实现的。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># Note: 对于上述任何一种策略，当没有合适的键可以清除时，Redis将在写操作上返回一个错误。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#       At the date of writing these commands are: set setnx setex append</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#       getset mset msetnx exec sort</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># The default is:</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># maxmemory-policy noeviction</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># LRU、LFU 和最小TTL 算法不是精确的算法，而是近似的算法(为了节省内存)，因此您可以对其进行调优以提高速度或精度。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 对于默认的 Redis 将随机采样 5 个键并选择一个最近较少使用的键，您可以使用下面的配置指令更改样本大小。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># maxmemory-samples 5</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 从Redis 5开始，在默认情况下，一个副本将忽略它的maxmemory设置(除非在故障转移后或手动将其提升为master)。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 这意味着键的清除将由主进程来处理，当主进程中的键被清除时，将DEL命令发送给副本。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 但是如果你的副本服务器是可写的，你可能会改变这种默认。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># Note: 由于副本在默认情况下不会被删除，因此它最终使用的内存可能比通过 maxmemory 设置的内存多(副本上有一些缓冲区可能更大，或者数据结构有时会占用更多内存，等等)。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># 因此，请确保监控您的副本服务器，并确保它们有足够的内存，在主服务器达到配置的 maxmemory 设置之前，不会出现真正的内存不足的情况。</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">#</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"># replica-ignore-maxmemory yes</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="频繁的命令造成-io-性能瓶颈" tabindex="-1"><a class="header-anchor" href="#频繁的命令造成-io-性能瓶颈"><span>频繁的命令造成 IO 性能瓶颈</span></a></h4><p>可以使用 pipline 在客户端缓存多条命令，批量发给 Redis Server 减少网络 IO。</p>`,25)]))}const h=i(e,[["render",p]]),r=JSON.parse('{"path":"/bigcompany/r3466fe9/","title":"Redis的踩坑","lang":"zh-CN","frontmatter":{"title":"Redis的踩坑","createTime":"2025/08/26 09:42:43","permalink":"/bigcompany/r3466fe9/"},"readingTime":{"minutes":5.18,"words":1553},"git":{"createdTime":1756736713000},"filePathRelative":"notes/bigcompany/mianshiti/redis踩坑.md","headers":[]}');export{h as comp,r as data};
