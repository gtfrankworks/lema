import{a,c as i,b as r,o as e}from"./app-ZQgO6-gU.js";const n={};function s(t,l){return e(),i("div",null,l[0]||(l[0]=[r('<ul><li><h3 id="_1、为什么要用线程池" tabindex="-1"><a class="header-anchor" href="#_1、为什么要用线程池"><span>1、为什么要用线程池</span></a></h3><ul><li><strong>答案</strong>：线程池预先创建一定数量的线程以重用，提高响应速度，降低频繁创建销毁线程的开销，控制并发线程数，方便任务管理。</li></ul><hr><h3 id="_2、mysql优化经验" tabindex="-1"><a class="header-anchor" href="#_2、mysql优化经验"><span>2、MySQL优化经验</span></a></h3><ul><li><strong>答案</strong>： <ul><li>避免全表扫描，建立索引；</li><li>避免 <code>!=</code> / <code>&lt;&gt;</code>；</li><li>优先使用数字字段；</li><li>避免 <code>select *</code>；</li><li>减少临时表频繁创建。</li></ul></li></ul><hr><h3 id="_3、线程死锁及避免方法" tabindex="-1"><a class="header-anchor" href="#_3、线程死锁及避免方法"><span>3、线程死锁及避免方法</span></a></h3><ul><li><strong>答案</strong>： <ul><li><strong>死锁条件</strong>：互斥、请求与保持、不剥夺、循环等待；</li><li><strong>避免方法</strong>： <ol><li>加锁顺序统一；</li><li>加锁超时 + 回退重试；</li><li>死锁检测机制。</li></ol></li></ul></li></ul><hr><h3 id="_4、spring中bean作用域" tabindex="-1"><a class="header-anchor" href="#_4、spring中bean作用域"><span>4、Spring中Bean作用域</span></a></h3><ul><li><strong>答案</strong>： <ul><li><code>singleton</code>：全局唯一实例；</li><li><code>prototype</code>：每次获取新实例；</li><li><code>request</code>：每次HTTP请求同一实例；</li><li><code>session</code>：每个HTTP Session同一实例；</li><li><code>globalSession</code>：Portlet全局共享。</li></ul></li></ul><hr><h3 id="_5、spring框架设计模式" tabindex="-1"><a class="header-anchor" href="#_5、spring框架设计模式"><span>5、Spring框架设计模式</span></a></h3><ul><li><strong>答案</strong>： <ul><li>代理模式：AOP、Remoting；</li><li>单例模式：默认 Bean；</li><li>模板方法模式：代码复用；</li><li>前端控制器模式：DispatcherServlet；</li><li>依赖注入模式：IoC 核心；</li><li>工厂模式：BeanFactory 创建 Bean。</li></ul></li></ul><hr><h3 id="_6、springmvc核心及请求流程" tabindex="-1"><a class="header-anchor" href="#_6、springmvc核心及请求流程"><span>6、SpringMVC核心及请求流程</span></a></h3><ul><li><strong>答案</strong>： <ul><li>核心：控制反转（IoC）+ 面向切面（AOP）</li><li>请求流程： <ol><li>用户请求 → DispatcherServlet；</li><li>DispatcherServlet 分发到 Controller；</li><li>Controller 处理 → ModelAndView；</li><li>DispatcherServlet 渲染视图 → 返回响应。</li></ol></li></ul></li></ul><hr><h3 id="_7、jvm内存结构" tabindex="-1"><a class="header-anchor" href="#_7、jvm内存结构"><span>7、JVM内存结构</span></a></h3><ul><li><strong>答案</strong>： <ul><li>程序计数器：线程私有，记录行号；</li><li>虚拟机栈：线程私有，存储局部变量、操作数栈；</li><li>本地方法栈：线程私有，服务 native 方法；</li><li>堆：线程共享，对象实例存储区；</li><li>方法区：线程共享，存储类信息、常量、静态变量。</li></ul></li></ul><hr><h3 id="_8、栈内存溢出" tabindex="-1"><a class="header-anchor" href="#_8、栈内存溢出"><span>8、栈内存溢出</span></a></h3><ul><li><strong>答案</strong>：线程递归调用过深或栈帧过大导致 <code>StackOverflowError</code>，可通过 <code>-Xss</code> 调节栈大小。</li></ul><hr><h3 id="_9、jvm内存模型" tabindex="-1"><a class="header-anchor" href="#_9、jvm内存模型"><span>9、JVM内存模型</span></a></h3><ul><li><strong>答案</strong>： <ul><li>线程私有：程序计数器、虚拟机栈、本地方法栈；</li><li>线程共享：堆、方法区（JDK8 后元数据区 + 运行时常量池）。</li></ul></li></ul><hr><h3 id="_10、jvm-gc及对象晋升" tabindex="-1"><a class="header-anchor" href="#_10、jvm-gc及对象晋升"><span>10、JVM GC及对象晋升</span></a></h3><ul><li><strong>答案</strong>： <ul><li>新生代 = Eden + Survivor0 + Survivor1；</li><li>Minor GC 回收新生代，存活对象进 Survivor；</li><li>对象在 Survivor 经历一定次数 Minor GC（默认15）晋升老年代；</li><li>老年代满触发 Full GC / Major GC。</li></ul></li></ul><hr><h3 id="_11、java垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_11、java垃圾回收算法"><span>11、Java垃圾回收算法</span></a></h3><ul><li><strong>答案</strong>： <ul><li>标记-清除、标记-整理、复制算法、分代收集、引用计数（HotSpot 不用）。</li></ul></li></ul><hr><h3 id="_12、对象是否存活判断" tabindex="-1"><a class="header-anchor" href="#_12、对象是否存活判断"><span>12、对象是否存活判断</span></a></h3><ul><li><strong>答案</strong>：通过 <strong>可达性分析</strong>，从 GC Roots 可直接或间接访问的对象为存活对象。</li></ul><hr><h3 id="_13、垃圾回收器及-cms-g1" tabindex="-1"><a class="header-anchor" href="#_13、垃圾回收器及-cms-g1"><span>13、垃圾回收器及 CMS/G1</span></a></h3><ul><li><strong>答案</strong>： <ul><li>Serial、Parallel、CMS、G1；</li><li><strong>CMS</strong>：老年代并发回收，停顿少但有碎片化；</li><li><strong>G1</strong>：分区回收，停顿可控，碎片少。</li></ul></li></ul><hr><h3 id="_14、类加载" tabindex="-1"><a class="header-anchor" href="#_14、类加载"><span>14、类加载</span></a></h3><ul><li><strong>答案</strong>：JVM 将 <code>.class</code> 文件加载到内存形成 <code>Class</code> 对象。</li></ul><hr><h3 id="_15、类加载过程" tabindex="-1"><a class="header-anchor" href="#_15、类加载过程"><span>15、类加载过程</span></a></h3><ul><li><strong>答案</strong>： <ol><li>加载（Load）</li><li>验证（Verify）</li><li>准备（Prepare）</li><li>解析（Resolve）</li><li>初始化（Initialize）</li></ol></li></ul><hr><h3 id="_16、类加载器及常见类型" tabindex="-1"><a class="header-anchor" href="#_16、类加载器及常见类型"><span>16、类加载器及常见类型</span></a></h3><ul><li><strong>答案</strong>： <ul><li>Bootstrap、Extension、App、自定义类加载器。</li></ul></li></ul><hr><h3 id="_17、双亲委派模型" tabindex="-1"><a class="header-anchor" href="#_17、双亲委派模型"><span>17、双亲委派模型</span></a></h3><ul><li><strong>答案</strong>：子加载器请求加载类时，先委派父加载器，父加载器找不到再自己加载。</li></ul><hr><h3 id="_18、为什么需要双亲委派" tabindex="-1"><a class="header-anchor" href="#_18、为什么需要双亲委派"><span>18、为什么需要双亲委派</span></a></h3><ul><li><strong>答案</strong>：保证核心类（如 <code>java.lang.*</code>）唯一，避免重复加载和安全风险。</li></ul><hr><h3 id="_19、怎么打破双亲委派" tabindex="-1"><a class="header-anchor" href="#_19、怎么打破双亲委派"><span>19、怎么打破双亲委派</span></a></h3><ul><li><strong>答案</strong>：使用自定义类加载器，优先加载自己定义的类而非委派给父加载器。</li></ul><hr><h3 id="_20、强引用、软引用、弱引用、虚引用" tabindex="-1"><a class="header-anchor" href="#_20、强引用、软引用、弱引用、虚引用"><span>20、强引用、软引用、弱引用、虚引用</span></a></h3><table><thead><tr><th>类型</th><th>特点</th></tr></thead><tbody><tr><td>强引用</td><td>普通引用，GC 不回收</td></tr><tr><td>软引用</td><td>内存不足时回收，用于缓存</td></tr><tr><td>弱引用</td><td>下一次 GC 回收，用于注册表</td></tr><tr><td>虚引用</td><td>无法获取对象，监控对象回收状态</td></tr></tbody></table></li></ul>',1)]))}const h=a(n,[["render",s]]),d=JSON.parse('{"path":"/bigcompany/163gcqrx/","title":"字节跳动-Java工程师","lang":"zh-CN","frontmatter":{"title":"字节跳动-Java工程师","createTime":"2025/08/21 13:07:45","permalink":"/bigcompany/163gcqrx/"},"readingTime":{"minutes":3.08,"words":923},"git":{"createdTime":1756736713000},"filePathRelative":"notes/bigcompany/company/字节跳动-Java工程师.md","headers":[]}');export{h as comp,d as data};
