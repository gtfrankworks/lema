import{a as r,c as o,b as n,o as l}from"./app-ZQgO6-gU.js";const s={};function i(g,t){return l(),o("div",null,t[0]||(t[0]=[n('<p>设计模式是在软件开发中，针对特定问题，经过长期实践总结出的通用解决方案。它们不是现成的代码库，而是一套可复用的设计思想，旨在提高代码的灵活性、可读性和可维护性。</p><p>设计模式通常被分为三大类，共 23 种经典模式。</p><h2 id="_1-创建型模式-creational-patterns" tabindex="-1"><a class="header-anchor" href="#_1-创建型模式-creational-patterns"><span>1. 创建型模式（Creational Patterns）</span></a></h2><p>这类模式主要用于对象的创建，将对象的创建过程与使用过程分离，从而使系统在创建对象时更具灵活性。</p><ul><li><strong>单例模式（Singleton）</strong><ul><li><strong>意图</strong>：确保一个类只有一个实例，并提供一个全局访问点。</li><li><strong>应用</strong>：配置管理器、数据库连接池、日志记录器等。</li></ul></li><li><strong>工厂方法模式（Factory Method）</strong><ul><li><strong>意图</strong>：定义一个用于创建对象的接口，让子类决定实例化哪一个类。</li><li><strong>应用</strong>：日志框架（log4j, slf4j）、连接池框架等。</li></ul></li><li><strong>抽象工厂模式（Abstract Factory）</strong><ul><li><strong>意图</strong>：提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们的具体类。</li><li><strong>应用</strong>：跨平台 UI 库、数据库驱动程序等。</li></ul></li><li><strong>建造者模式（Builder）</strong><ul><li><strong>意图</strong>：将一个复杂对象的构建与它的表示分离，使同样的构建过程可以创建不同的表示。</li><li><strong>应用</strong>：构建复杂的对象，如 <code>StringBuilder</code>、<code>URLBuilder</code>。</li></ul></li><li><strong>原型模式（Prototype）</strong><ul><li><strong>意图</strong>：使用原型实例指定创建对象的种类，并通过克隆（<code>clone</code>）这些原型来创建新对象。</li><li><strong>应用</strong>：当创建新对象成本较高时，如需要从数据库中读取大量数据来创建对象。</li></ul></li></ul><h2 id="_2-结构型模式-structural-patterns" tabindex="-1"><a class="header-anchor" href="#_2-结构型模式-structural-patterns"><span>2. 结构型模式（Structural Patterns）</span></a></h2><p>这类模式关注如何将类和对象组合成更大的结构，以解决特定问题。</p><ul><li><strong>适配器模式（Adapter）</strong><ul><li><strong>意图</strong>：将一个类的接口转换成客户希望的另一个接口，使原本不兼容的类可以一起工作。</li><li><strong>应用</strong>：将旧的 API 适配到新的接口，如 Java 中的 <code>java.io.InputStreamReader</code>。</li></ul></li><li><strong>装饰器模式（Decorator）</strong><ul><li><strong>意图</strong>：动态地给一个对象添加一些额外的职责，比使用子类更灵活。</li><li><strong>应用</strong>：Java I/O 库，如 <code>BufferedReader</code> 和 <code>BufferedInputStream</code>。</li></ul></li><li><strong>代理模式（Proxy）</strong><ul><li><strong>意图</strong>：为另一个对象提供一个替身或占位符，以控制对这个对象的访问。</li><li><strong>应用</strong>：远程代理（RMI）、虚拟代理、保护代理，AOP（面向切面编程）的核心实现。</li></ul></li><li><strong>组合模式（Composite）</strong><ul><li><strong>意图</strong>：将对象组合成树形结构，以表示“部分-整体”的层次结构。</li><li><strong>应用</strong>：文件系统中的目录和文件、GUI 组件中的容器和组件。</li></ul></li><li><strong>外观模式（Facade）</strong><ul><li><strong>意图</strong>：为子系统中的一组接口提供一个统一的接口。</li><li><strong>应用</strong>：封装复杂的子系统，提供一个简单的入口，如 JDBC 封装。</li></ul></li></ul><h2 id="_3-行为型模式-behavioral-patterns" tabindex="-1"><a class="header-anchor" href="#_3-行为型模式-behavioral-patterns"><span>3. 行为型模式（Behavioral Patterns）</span></a></h2><p>这类模式关注对象之间的职责分配和通信。</p><ul><li><strong>观察者模式（Observer）</strong><ul><li><strong>意图</strong>：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</li><li><strong>应用</strong>：事件监听系统，如 GUI 编程中的按钮点击事件、消息队列。</li></ul></li><li><strong>策略模式（Strategy）</strong><ul><li><strong>意图</strong>：定义一系列算法，将它们封装起来，并且使它们可以相互替换。</li><li><strong>应用</strong>：根据不同的策略执行不同的行为，如排序算法、支付方式。</li></ul></li><li><strong>命令模式（Command）</strong><ul><li><strong>意图</strong>：将请求封装成一个对象，从而使你可用不同的请求、队列或日志来参数化客户端。</li><li><strong>应用</strong>：可撤销操作、宏命令，如文本编辑器的撤销功能。</li></ul></li><li><strong>模板方法模式（Template Method）</strong><ul><li><strong>意图</strong>：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。</li><li><strong>应用</strong>：在父类中定义通用流程，子类实现特定步骤，如算法框架。</li></ul></li><li><strong>迭代器模式（Iterator）</strong><ul><li><strong>意图</strong>：提供一种方法顺序访问一个聚合对象中各个元素，而又无需暴露该对象的内部表示。</li><li><strong>应用</strong>：Java 集合框架中的 <code>Iterator</code> 接口。</li></ul></li></ul><p>掌握这些设计模式是成为一名优秀软件工程师的关键一步，它们能帮助你更好地理解和设计复杂的系统。</p><h2 id="_4-设计模式的作用" tabindex="-1"><a class="header-anchor" href="#_4-设计模式的作用"><span>4. 设计模式的作用</span></a></h2><p>设计模式的主要作用可以归纳为以下几点：</p><p><strong>1. 提供通用语言</strong> 设计模式为开发人员提供了一套共同的词汇。当你和同事讨论时，如果提到“单例模式”或“工厂模式”，大家都能立即理解你的意图和设计思路，这极大地提高了沟通效率。</p><p><strong>2. 提高代码可重用性和可维护性</strong> 设计模式鼓励你将复杂的问题分解成更小的、可管理的组件。这使得代码更容易被理解、修改和复用。例如，通过<strong>工厂模式</strong>，你可以轻松地在不修改客户端代码的情况下替换掉对象的具体实现。</p><p><strong>3. 增强代码的灵活性和扩展性</strong> 设计模式帮助你预见未来的变化。通过使用<strong>策略模式</strong>，你可以将不同的算法封装起来，当需要增加新的算法时，只需添加一个新的策略类即可，而无需修改原有的代码。</p><p><strong>4. 解决特定问题</strong> 每种设计模式都针对一个特定的问题。例如，当你想确保一个类在整个应用中只有一个实例时，<strong>单例模式</strong>就是最适合的解决方案。当你想在运行时给对象添加新功能时，<strong>装饰器模式</strong>会是你的首选。</p>',18)]))}const a=r(s,[["render",i]]),u=JSON.parse('{"path":"/design/","title":"Java设计模式简介","lang":"zh-CN","frontmatter":{"title":"Java设计模式简介","createTime":"2025/08/27 17:30:33","permalink":"/design/"},"readingTime":{"minutes":4.97,"words":1491},"git":{"createdTime":1756736713000},"filePathRelative":"notes/design/README.md","headers":[]}');export{a as comp,u as data};
