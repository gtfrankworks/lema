import{a as l,c as i,b as r,o as s}from"./app-ZQgO6-gU.js";const n={};function a(e,t){return s(),i("div",null,t[0]||(t[0]=[r(`<h3 id="_1-从简历项目中选一个项目-遇到的重大挑战和解决思路" tabindex="-1"><a class="header-anchor" href="#_1-从简历项目中选一个项目-遇到的重大挑战和解决思路"><span>1. 从简历项目中选一个项目，遇到的重大挑战和解决思路</span></a></h3><ul><li><strong>举例</strong>：在微服务项目中，实现分布式事务。</li><li><strong>挑战</strong>：跨多个微服务更新数据时保证一致性。</li><li><strong>解决思路</strong>： <ul><li>使用 <strong>TCC（Try-Confirm-Cancel）模式</strong> 或 <strong>Saga模式</strong>；</li><li>对关键业务操作增加重试和补偿机制；</li><li>使用消息队列确保异步操作可靠执行；</li><li>严格日志记录和异常捕获。</li></ul></li></ul><hr><h3 id="_2-一段代码执行多个-redis-命令-不加锁如何保证原子性" tabindex="-1"><a class="header-anchor" href="#_2-一段代码执行多个-redis-命令-不加锁如何保证原子性"><span>2. 一段代码执行多个 Redis 命令，不加锁如何保证原子性？</span></a></h3><ul><li><strong>解决方法</strong>：使用 <strong>Lua 脚本</strong>在 Redis 中原子执行多个命令。 示例：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>-- KEYS[1], KEYS[2] 是 key，ARGV[1] 是 value</span></span>
<span class="line"><span>redis.call(&quot;SET&quot;, KEYS[1], ARGV[1])</span></span>
<span class="line"><span>redis.call(&quot;INCR&quot;, KEYS[2])</span></span>
<span class="line"><span>return 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Redis 会把 Lua 脚本当作一个命令执行，保证原子性。</li></ul><hr><h3 id="_3-数据结构-二叉树、红黑树" tabindex="-1"><a class="header-anchor" href="#_3-数据结构-二叉树、红黑树"><span>3. 数据结构：二叉树、红黑树</span></a></h3><ul><li><strong>二叉树</strong>：每个节点最多两个子节点。适合排序、查找。</li><li><strong>红黑树</strong>： <ul><li>自平衡二叉查找树；</li><li>每个节点有颜色标记（红/黑），保证树高为 O(log n)；</li><li>常用于 TreeMap、TreeSet。</li></ul></li></ul><hr><h3 id="_4-b-tree-和-b-tree-区别" tabindex="-1"><a class="header-anchor" href="#_4-b-tree-和-b-tree-区别"><span>4. B-tree 和 B+tree 区别</span></a></h3><table><thead><tr><th>特性</th><th>B-tree</th><th>B+tree</th></tr></thead><tbody><tr><td>数据位置</td><td>内部节点和叶子节点均可存储数据</td><td>只存储在叶子节点</td></tr><tr><td>顺序访问</td><td>需中序遍历</td><td>叶子节点通过指针顺序访问，遍历快</td></tr><tr><td>查询性能</td><td>层级较多</td><td>层级更少，查询更稳定</td></tr><tr><td>应用场景</td><td>数据库索引、文件系统</td><td>MySQL InnoDB 索引、文件系统</td></tr></tbody></table><hr><h3 id="_5-mysql-哪个版本和存储引擎使用-b-tree" tabindex="-1"><a class="header-anchor" href="#_5-mysql-哪个版本和存储引擎使用-b-tree"><span>5. MySQL 哪个版本和存储引擎使用 B+tree？</span></a></h3><ul><li><strong>InnoDB</strong>（MySQL 5.x/8.x）使用 <strong>B+tree</strong> 索引。</li><li><strong>为什么不使用红黑树</strong>： <ul><li>B+tree 支持顺序访问和范围查询；</li><li>红黑树不适合磁盘存储，磁盘 IO 随机访问成本高。</li></ul></li></ul><hr><h3 id="_6-常见消息中间件区别" tabindex="-1"><a class="header-anchor" href="#_6-常见消息中间件区别"><span>6. 常见消息中间件区别</span></a></h3><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>开发语言</td><td>Java</td><td>Erlang</td><td>Java</td><td>Scala</td></tr><tr><td>单机吞吐量</td><td>万级</td><td>万级</td><td>10万级</td><td>10万级</td></tr><tr><td>时效性</td><td>ms级</td><td>us级</td><td>ms级</td><td>ms级以内</td></tr><tr><td>可用性</td><td>高</td><td>高</td><td>非常高</td><td>非常高</td></tr><tr><td>功能特性</td><td>成熟、协议多</td><td>高并发、管理界面丰富</td><td>扩展性佳</td><td>面向大数据</td></tr></tbody></table><ul><li><strong>选择建议</strong>： <ul><li>中小型公司：RabbitMQ；</li><li>大型公司：RocketMQ；</li><li>日志采集、大数据：Kafka。</li></ul></li></ul><hr><h3 id="_7-rabbitmq-如何保证消息可靠性" tabindex="-1"><a class="header-anchor" href="#_7-rabbitmq-如何保证消息可靠性"><span>7. RabbitMQ 如何保证消息可靠性</span></a></h3><ol><li><strong>消息不丢失</strong>： <ul><li>开启 confirm 或事务；</li><li>持久化交换机、队列、消息；</li><li>手动 ack。</li></ul></li><li><strong>消息不重复消费</strong>： <ul><li>幂等性处理。</li></ul></li><li><strong>消息顺序</strong>： <ul><li>同队列、单消费者。</li></ul></li><li><strong>消息重试</strong>： <ul><li>SpringBoot：<code>@Retryable</code> + <code>@Recover</code> 注解控制重试次数和延迟。</li></ul></li></ol><hr><h3 id="_8-spring-cloud-服务发现原理" tabindex="-1"><a class="header-anchor" href="#_8-spring-cloud-服务发现原理"><span>8. Spring Cloud 服务发现原理</span></a></h3><ul><li>客户端定期（30s）发送心跳更新租约，若失败超过阈值（90s），服务会被移除。</li><li>Eureka Server 节点之间复制注册信息，实现高可用。</li><li>客户端可缓存服务列表，即使 Eureka 挂掉仍可访问服务。</li></ul><hr><h3 id="_9-spring-cloud-核心组件" tabindex="-1"><a class="header-anchor" href="#_9-spring-cloud-核心组件"><span>9. Spring Cloud 核心组件</span></a></h3><ul><li><strong>Eureka</strong>：服务注册与发现</li><li><strong>Ribbon</strong>：客户端负载均衡</li><li><strong>Feign</strong>：基于注解的 HTTP 客户端</li><li><strong>Hystrix</strong>：服务熔断、线程隔离</li><li><strong>Zuul</strong>：API 网关</li><li><strong>其他注册中心</strong>：Zookeeper、Consul</li></ul><hr><h3 id="_10-微服务限流方式" tabindex="-1"><a class="header-anchor" href="#_10-微服务限流方式"><span>10. 微服务限流方式</span></a></h3><ul><li><strong>令牌桶（Token Bucket）</strong></li><li><strong>漏桶（Leaky Bucket）</strong></li><li><strong>计数器（Counter）</strong></li><li><strong>滑动窗口（Sliding Window）</strong></li></ul><hr><h3 id="_11-限流的情况下-服务隔离还有没有必要" tabindex="-1"><a class="header-anchor" href="#_11-限流的情况下-服务隔离还有没有必要"><span>11. 限流的情况下，服务隔离还有没有必要？</span></a></h3><ul><li><strong>有必要</strong>： <ul><li>限流是保护服务入口，防止请求过载；</li><li>服务隔离保证不同服务故障不影响整体系统，避免雪崩效应。</li></ul></li></ul><hr><h3 id="_12-dubbo-负载均衡" tabindex="-1"><a class="header-anchor" href="#_12-dubbo-负载均衡"><span>12. Dubbo 负载均衡</span></a></h3><ul><li><strong>负载均衡算法</strong>： <ul><li>Random、RoundRobin、LeastActive、ConsistentHash</li></ul></li><li><strong>位置</strong>： <ul><li>一般在 <strong>客户端</strong> 进行负载均衡，客户端选择调用哪台服务。</li></ul></li></ul><hr><h3 id="_13-redis-分布式锁实现" tabindex="-1"><a class="header-anchor" href="#_13-redis-分布式锁实现"><span>13. Redis 分布式锁实现</span></a></h3><ul><li><strong>方式</strong>： <ul><li>SET key value NX PX timeout</li><li>使用 Redisson 库简化实现</li></ul></li><li><strong>注意事项</strong>： <ul><li>防止死锁：设置过期时间</li><li>保证释放锁是持有者自己释放（Lua 脚本检查 value）</li></ul></li></ul><hr><h3 id="_14-看过的源码设计亮点" tabindex="-1"><a class="header-anchor" href="#_14-看过的源码设计亮点"><span>14. 看过的源码设计亮点</span></a></h3><ul><li><strong>Spring BeanFactory</strong>：使用 <strong>工厂模式</strong>创建 Bean</li><li><strong>Spring AOP</strong>：使用 <strong>动态代理模式</strong>实现横切关注点</li><li><strong>MyBatis</strong>：使用 <strong>模板方法模式</strong>和 <strong>代理模式</strong></li><li><strong>设计亮点</strong>： <ul><li>IOC/DI 解耦</li><li>延迟加载</li><li>面向接口编程</li></ul></li></ul><hr><h3 id="_15-如何实现-aop-项目应用场景" tabindex="-1"><a class="header-anchor" href="#_15-如何实现-aop-项目应用场景"><span>15. 如何实现 AOP？项目应用场景</span></a></h3><ul><li><strong>实现方式</strong>： <ul><li>基于 <strong>动态代理</strong>（JDK/CGlib）</li><li>基于 <strong>AspectJ 注解</strong></li></ul></li><li><strong>项目应用</strong>： <ul><li>日志记录</li><li>权限校验</li><li>事务管理</li><li>性能统计</li></ul></li></ul><hr><h3 id="_16-后置处理器作用" tabindex="-1"><a class="header-anchor" href="#_16-后置处理器作用"><span>16. 后置处理器作用</span></a></h3><ul><li><strong>BeanPostProcessor</strong>： <ul><li>在 Bean 初始化前后执行额外逻辑</li><li>示例：修改属性、注入依赖、动态代理</li></ul></li></ul><hr><h3 id="_17-spring-bean-作用域" tabindex="-1"><a class="header-anchor" href="#_17-spring-bean-作用域"><span>17. Spring Bean 作用域</span></a></h3><ul><li><strong>单例（singleton）</strong>：默认，一个容器只有一个实例</li><li><strong>原型（prototype）</strong>：每次获取一个新实例</li><li><strong>request</strong>：每次 HTTP 请求创建一个 Bean</li><li><strong>session</strong>：每个会话一个 Bean</li><li><strong>使用场景</strong>： <ul><li>request 作用域适合 <strong>Web 请求级别的对象</strong>（如用户会话数据、上下文信息）</li></ul></li></ul>`,53)]))}const d=l(n,[["render",a]]),h=JSON.parse('{"path":"/bigcompany/xxvp1nck/","title":"腾讯-Java高级","lang":"zh-CN","frontmatter":{"title":"腾讯-Java高级","createTime":"2025/08/21 13:04:32","permalink":"/bigcompany/xxvp1nck/"},"readingTime":{"minutes":3.98,"words":1193},"git":{"createdTime":1756736713000},"filePathRelative":"notes/bigcompany/company/腾讯-Java高级.md","headers":[]}');export{d as comp,h as data};
