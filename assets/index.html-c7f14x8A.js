import{a as s,c as a,b as n,o as r}from"./app-ZQgO6-gU.js";const l={};function i(e,t){return r(),a("div",null,t[0]||(t[0]=[n(`<ul><li><h2 id="一、数据结构相关" tabindex="-1"><a class="header-anchor" href="#一、数据结构相关"><span><strong>一、数据结构相关</strong></span></a></h2><h3 id="_1-二叉搜索树-bst-和平衡二叉树的关系及区别" tabindex="-1"><a class="header-anchor" href="#_1-二叉搜索树-bst-和平衡二叉树的关系及区别"><span><strong>1. 二叉搜索树（BST）和平衡二叉树的关系及区别</strong></span></a></h3><p><strong>二叉搜索树（BST）</strong></p><ul><li>定义：每个节点满足左子树 &lt; 根 &lt; 右子树。</li><li>特点：支持快速查找、插入、删除，平均时间复杂度 O(log n)，最坏情况 O(n)（退化为链表）。</li></ul><p><strong>平衡二叉树</strong></p><ul><li>在 BST 的基础上，保证树的高度平衡，左右子树高度差 ≤ 1。</li><li>优点：保证查找、插入、删除时间复杂度为 O(log n)。</li></ul><p><strong>AVL 树（强平衡）与红黑树（弱平衡）的区别</strong></p><table><thead><tr><th>特性</th><th>AVL 树</th><th>红黑树</th></tr></thead><tbody><tr><td>平衡程度</td><td>高度平衡，左右子树高度差 ≤ 1</td><td>较弱平衡，通过颜色属性约束路径黑色节点数量</td></tr><tr><td>查找效率</td><td>高（树更平衡）</td><td>略低</td></tr><tr><td>插入/删除效率</td><td>低（可能频繁旋转）</td><td>高（旋转次数少）</td></tr><tr><td>适用场景</td><td>读操作多的场景</td><td>写操作频繁、如 JDK 的 <code>TreeMap</code> / <code>HashMap</code> 链表转树</td></tr></tbody></table><hr><h3 id="_2-b-树和-b-树及-mysql-使用原因" tabindex="-1"><a class="header-anchor" href="#_2-b-树和-b-树及-mysql-使用原因"><span><strong>2. B 树和 B+ 树及 MySQL 使用原因</strong></span></a></h3><p><strong>B 树</strong></p><ul><li>所有关键字分布在整棵树；每个节点保存数据；搜索可能在非叶子节点结束。</li><li>查询性能等价于二分查找。</li></ul><p><strong>B+ 树</strong></p><ul><li>非叶子节点只存索引（关键字，不保存数据），叶子节点存所有数据。</li><li>叶子节点通过链表串联，支持顺序遍历。</li><li>非叶子节点只做索引，能存更多元素，更“矮胖”，减少 IO。</li></ul><p><strong>MySQL 使用 B+ 树原因</strong></p><ol><li>磁盘存储优化：非叶子节点只存索引，可在一个页存储更多节点。</li><li>范围查询高效：只需遍历叶子链表。</li><li>查询稳定：查找总能走到叶子节点。</li></ol><hr><h3 id="_3-hashmap-如何解决-hash-冲突" tabindex="-1"><a class="header-anchor" href="#_3-hashmap-如何解决-hash-冲突"><span><strong>3. HashMap 如何解决 Hash 冲突</strong></span></a></h3><ul><li><strong>链表法</strong>：每个桶维护链表，冲突时新节点插入链表。</li><li><strong>JDK 1.8 优化</strong>：当链表长度 &gt; 8，链表转红黑树，提高查询性能。</li><li><strong>原理举例</strong>：</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>hash(&quot;key1&quot;) → 桶0</span></span>
<span class="line"><span>hash(&quot;key2&quot;) → 桶0</span></span>
<span class="line"><span>桶0: key1 → key2 → null   // 链表</span></span>
<span class="line"><span>链表长度 &gt; 8 → 转红黑树</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_4-epoll-与-poll-区别及应用" tabindex="-1"><a class="header-anchor" href="#_4-epoll-与-poll-区别及应用"><span><strong>4. epoll 与 poll 区别及应用</strong></span></a></h3><table><thead><tr><th>特性</th><th>poll</th><th>epoll</th></tr></thead><tbody><tr><td>机制</td><td>轮询监听</td><td>内核事件通知</td></tr><tr><td>优势</td><td>简单</td><td>大量 fd 性能好，避免轮询开销</td></tr><tr><td>应用场景</td><td>连接数少，简单服务</td><td>高并发网络服务，如 Nginx、Netty</td></tr></tbody></table><hr><h3 id="_5-线程池原理-fixedthreadpool-阻塞队列" tabindex="-1"><a class="header-anchor" href="#_5-线程池原理-fixedthreadpool-阻塞队列"><span><strong>5. 线程池原理 &amp; FixedThreadPool 阻塞队列</strong></span></a></h3><ul><li><strong>原理</strong><ol><li>线程池维护一组工作线程 <code>workerSet</code>。</li><li>任务提交到阻塞队列 <code>workQueue</code>。</li><li>空闲线程从队列中取任务执行。</li></ol></li><li><strong>FixedThreadPool</strong><ul><li>使用 <strong>无界队列 <code>LinkedBlockingQueue</code></strong>，队列永远不会拒绝任务，线程固定。</li></ul></li></ul><hr><h3 id="_6-synchronized-与-reentrantlock-区别" tabindex="-1"><a class="header-anchor" href="#_6-synchronized-与-reentrantlock-区别"><span><strong>6. synchronized 与 ReentrantLock 区别</strong></span></a></h3><table><thead><tr><th>特性</th><th>synchronized</th><th>ReentrantLock</th></tr></thead><tbody><tr><td>获取方式</td><td>隐式</td><td>显示 lock() / unlock()</td></tr><tr><td>可中断</td><td>否</td><td>是，可响应中断</td></tr><tr><td>公平性</td><td>不支持</td><td>可实现公平锁</td></tr><tr><td>多条件等待</td><td>不支持</td><td>Condition 支持多个条件</td></tr><tr><td>实现层</td><td>JVM</td><td>API</td></tr></tbody></table><hr><h3 id="_7-synchronized-锁升级机制" tabindex="-1"><a class="header-anchor" href="#_7-synchronized-锁升级机制"><span><strong>7. synchronized 锁升级机制</strong></span></a></h3><ul><li><strong>自旋锁</strong>：线程短时间内等待，避免阻塞。</li><li><strong>偏向锁</strong>：偏向第一个获取锁的线程，减少无竞争情况下的 CAS 操作。</li><li><strong>轻量级锁</strong>：偏向锁在多线程竞争下升级，仍在用户态自旋。</li><li><strong>重量级锁</strong>：线程阻塞挂起，操作系统调度唤醒。</li></ul><p><strong>联系</strong>：锁从轻到重依次升级，减少开销并保证安全。</p><hr><h3 id="_8-http-问题与-https-安全机制" tabindex="-1"><a class="header-anchor" href="#_8-http-问题与-https-安全机制"><span><strong>8. HTTP 问题与 HTTPS 安全机制</strong></span></a></h3><p><strong>HTTP 不足</strong></p><ul><li>明文传输 → 易被窃听</li><li>不验证身份 → 易被伪装</li><li>无完整性校验 → 易被篡改</li></ul><p><strong>常用加密算法</strong></p><ul><li>MD5、DES、AES、RSA</li></ul><p><strong>HTTPS 安全保障</strong></p><ol><li><strong>对称加密</strong>：保证数据传输保密性（AES）。</li><li><strong>非对称加密</strong>：传输密钥安全（RSA）。</li><li><strong>数字证书 &amp; CA</strong>：验证身份。</li><li><strong>摘要算法</strong>：保证报文完整性（SHA）。</li></ol><hr><h2 id="二、蚂蚁-java-二面题" tabindex="-1"><a class="header-anchor" href="#二、蚂蚁-java-二面题"><span><strong>二、蚂蚁 Java 二面题</strong></span></a></h2><h3 id="_1-设计模式大类" tabindex="-1"><a class="header-anchor" href="#_1-设计模式大类"><span><strong>1. 设计模式大类</strong></span></a></h3><ul><li><strong>创建型</strong>：Singleton、Factory Method、Abstract Factory、Builder、Prototype</li><li><strong>结构型</strong>：Adapter、Bridge、Composite、Decorator、Facade、Flyweight、Proxy</li><li><strong>行为型</strong>：Observer、Strategy、Command、Template Method、State、Mediator、Iterator</li></ul><hr><h3 id="_2-volatile-关键字" tabindex="-1"><a class="header-anchor" href="#_2-volatile-关键字"><span><strong>2. volatile 关键字</strong></span></a></h3><ul><li><strong>可见性</strong>：修改立即刷新到主内存，其他线程可见。</li><li><strong>有序性</strong>：禁止指令重排（在 JVM 层面）。</li><li><strong>不保证原子性</strong>：如 <code>i++</code> 不是原子操作。</li></ul><hr><h3 id="_3-java-内存结构" tabindex="-1"><a class="header-anchor" href="#_3-java-内存结构"><span><strong>3. Java 内存结构</strong></span></a></h3><ul><li><strong>方法区（Metaspace）</strong>：存类信息</li><li><strong>堆</strong>：对象实例存储 <ul><li>新生代：Eden + Survivor</li><li>老年代：长期存活对象</li><li>默认晋升阈值：JVM 8+ 默认 15 岁</li></ul></li><li><strong>栈</strong>：方法调用帧</li><li><strong>PC 寄存器</strong>：程序计数</li><li><strong>本地方法栈</strong>：Native 方法</li></ul><hr><h3 id="_4-concurrenthashmap-线程安全-jdk1-8-变化" tabindex="-1"><a class="header-anchor" href="#_4-concurrenthashmap-线程安全-jdk1-8-变化"><span><strong>4. ConcurrentHashMap 线程安全 &amp; JDK1.8 变化</strong></span></a></h3><ul><li><strong>原理</strong>：分段锁（JDK1.7）→ synchronized + CAS + 链表/红黑树（JDK1.8）</li><li><strong>JDK1.8 优化</strong>：每个桶使用 <strong>链表或红黑树</strong>，减少锁粒度，实现更高并发。</li></ul><hr><h3 id="_5-concurrenthashmap-底层红黑树原因" tabindex="-1"><a class="header-anchor" href="#_5-concurrenthashmap-底层红黑树原因"><span><strong>5. ConcurrentHashMap 底层红黑树原因</strong></span></a></h3><ul><li>链表过长 → 查询效率低</li><li>超过阈值转红黑树 → 保证查找复杂度 O(log n)</li></ul><hr><h3 id="_6-mysql-优化思路" tabindex="-1"><a class="header-anchor" href="#_6-mysql-优化思路"><span><strong>6. MySQL 优化思路</strong></span></a></h3><ul><li><strong>索引优化</strong>：B+ 树索引、覆盖索引</li><li><strong>SQL 优化</strong>：避免全表扫描、避免 SELECT *</li><li><strong>缓存优化</strong>：Redis 缓存热点数据</li><li><strong>分库分表</strong>：减小单库压力</li><li><strong>连接池</strong>：减少频繁连接开销</li></ul><hr><h3 id="_7-oom-处理" tabindex="-1"><a class="header-anchor" href="#_7-oom-处理"><span><strong>7. OOM 处理</strong></span></a></h3><ul><li><strong>分析工具</strong>：jmap、jstack、MAT</li><li><strong>处理策略</strong>： <ol><li>增加堆内存</li><li>优化对象生命周期</li><li>避免大对象长时间驻留</li></ol></li></ul><hr><h2 id="三、蚂蚁-java-三面题" tabindex="-1"><a class="header-anchor" href="#三、蚂蚁-java-三面题"><span><strong>三、蚂蚁 Java 三面题</strong></span></a></h2><h3 id="_1-项目介绍" tabindex="-1"><a class="header-anchor" href="#_1-项目介绍"><span><strong>1. 项目介绍</strong></span></a></h3><ul><li>说明项目背景、业务目标、技术栈、职责、难点及优化方案</li></ul><h3 id="_2-redis-缓存一致性" tabindex="-1"><a class="header-anchor" href="#_2-redis-缓存一致性"><span><strong>2. Redis 缓存一致性</strong></span></a></h3><ul><li><p><strong>双删延时策略</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>1. 删除缓存</span></span>
<span class="line"><span>2. 更新数据库</span></span>
<span class="line"><span>3. 延时再删除一次缓存</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_3-redis-问题" tabindex="-1"><a class="header-anchor" href="#_3-redis-问题"><span><strong>3. Redis 问题</strong></span></a></h3><ul><li><strong>缓存雪崩</strong>：大量 key 同时过期 → 系统压力 <ul><li>解决：TTL 随机、加锁、限流</li></ul></li><li><strong>缓存击穿</strong>：热点 key 过期 → 频繁请求 DB <ul><li>解决：互斥锁/互斥队列</li></ul></li><li><strong>缓存穿透</strong>：查询不存在的 key → 全部查询 DB <ul><li>解决：布隆过滤器或空值缓存</li></ul></li></ul><h3 id="_4-消息中间件比较" tabindex="-1"><a class="header-anchor" href="#_4-消息中间件比较"><span><strong>4. 消息中间件比较</strong></span></a></h3><table><thead><tr><th>中间件</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr><td>RocketMQ</td><td>高吞吐、分布式、事务消息</td><td>电商订单、金融系统</td></tr><tr><td>Kafka</td><td>高吞吐、分布式日志、流处理</td><td>大数据、日志收集</td></tr><tr><td>RabbitMQ</td><td>AMQP、可靠投递、路由灵活</td><td>企业消息、任务队列</td></tr><tr><td>ActiveMQ</td><td>JMS 标准</td><td>企业系统整合</td></tr></tbody></table></li></ul>`,1)]))}const d=s(l,[["render",i]]),h=JSON.parse('{"path":"/bigcompany/k9lnfr7m/","title":"蚂蚁金服-Java高级","lang":"zh-CN","frontmatter":{"title":"蚂蚁金服-Java高级","createTime":"2025/08/21 13:22:39","permalink":"/bigcompany/k9lnfr7m/"},"readingTime":{"minutes":5.06,"words":1519},"git":{"createdTime":1756736713000},"filePathRelative":"notes/bigcompany/company/蚂蚁金服-Java高级.md","headers":[]}');export{d as comp,h as data};
