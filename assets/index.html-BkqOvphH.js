import{a as i,c as e,b as t,o as n}from"./app-ZQgO6-gU.js";const p={};function g(r,a){return n(),e("div",null,a[0]||(a[0]=[t('<figure><img src="https://i.loli.net/2020/11/14/Tpe4DlgWKMfXUwJ.png" alt="flyweight-title" tabindex="0" loading="lazy"><figcaption>flyweight-title</figcaption></figure><h1 id="享元模式" tabindex="-1"><a class="header-anchor" href="#享元模式"><span>享元模式</span></a></h1><blockquote><p>运用共享技术来有效地支持大量细粒度对象的复用。</p></blockquote><p>这个设计模式在 GOF 的书中是用 flyweight 这个词来定义这种模式的，然后翻译成中文就叫 享元 了，讲真挺不自在，首先这个词是一个自造词（享元）</p><figure><img src="https://i.loli.net/2020/11/12/b8iZeYslH47DO6a.png" alt="flyweight-search.png" tabindex="0" loading="lazy"><figcaption>flyweight-search.png</figcaption></figure><p>再者就是这个词语我认为用轻量化的解释更合适，不过现在被翻译成享元肯定是有他的原因的，至于为什么翻译享元已经不重要了，这都不会影响我们学习的对不对！</p><h2 id="如何理解" tabindex="-1"><a class="header-anchor" href="#如何理解"><span>如何理解</span></a></h2><p>我们先一起来理解一下这个词的意思，然后再说这个模式解决的问题，希望我的解释能帮你快速的了解这个设计模式的意图。</p><p>我是这样理解的。享元，共享单元。什么意思呢，将一些资源共享，以减少一些不必要的资源消耗。我接着举几个例子说明一下；为了代入感更强，我就拿游戏举例了。</p><p><strong>声明：以下内容只为学习类比使用，并不代表游戏设计方案，游戏如何设计实现，我未参与，也未研究，感兴趣的可自行了解。</strong></p><h3 id="_1-我的世界" tabindex="-1"><a class="header-anchor" href="#_1-我的世界"><span>1. 我的世界</span></a></h3><figure><img src="https://i.loli.net/2020/11/12/qOtZ4YdgxePj1Iy.jpg" alt="mc" tabindex="0" loading="lazy"><figcaption>mc</figcaption></figure><h4 id="游戏地图" tabindex="-1"><a class="header-anchor" href="#游戏地图"><span>游戏地图</span></a></h4><p>我们都知道我的世界是一个自由度超高的沙盒游戏。进到游戏之后我们应该会看到一个画面，就是地图在不断的渲染。这里可能以前玩的时候大家都没有注意过，只是觉得游戏好大，但是不怎么卡。不卡的原因有很多。我们今天要说的就是如何通过享元模式来减少资源负担。</p><p>假如我的世界地图中每个单位格子的内容大小为1kb，粗略估计一个画面内格子的数量为1,000,000，此时加载地图需要 1GB 的内存，如果每个格子2kb则 2GB。如果一个单元格内容所用的贴画是 10kb 呢。目前来看 10G 内存也都能接受，可这款游戏放在当年的话，估计不会有人玩了。</p><h4 id="如何解决" tabindex="-1"><a class="header-anchor" href="#如何解决"><span>如何解决</span></a></h4><p>其实这个方案非常的正常，也非常的简单。首先我们可以这样做，事先将需要用到的格子贴画统计好，然后一次加载到内存中，记录一下内存的地址，需要用的时候，直接取出来渲染就好了。他们的样子都差不多，只是摆放的位置不同。还有一种方式呢，就是我用一个先去我的 <strong>资源库</strong> 找，找不到就创建一个放到资源库中，如果能够找到，就直接返回。这两种方式都可以。第一种方式将压力放在了启动过程，第二种的方式将压力放在第一次渲染的过程。而一般情况下，游戏的开发都是用第一种方式，也就是我们所说的“过图”，”地图加载“。这个时候去做的，因为一次卡顿加载完和你走着走着卡一下当然第一种更容易接受。</p><h3 id="_2-英雄联盟" tabindex="-1"><a class="header-anchor" href="#_2-英雄联盟"><span>2.英雄联盟</span></a></h3><figure><img src="https://i.loli.net/2020/11/12/Wxw5741lX6ThejY.jpg" alt="lol" tabindex="0" loading="lazy"><figcaption>lol</figcaption></figure><p>英雄联盟这款游戏大家应该并不陌生，S10 刚刚结束（10月31日全球总决赛），SN来年再战，加油。</p><h4 id="兵线" tabindex="-1"><a class="header-anchor" href="#兵线"><span>“兵线”</span></a></h4><p>游戏中一共有 3 路兵线，每次出现几只我不清楚，8只好了。 3路乘以2（双方）然后在乘以8，这应该是48个对象。而且他们还包含各自的动作，比如魔法兵吐得“口水“，炮车喝奶茶吐的“珍珠”等等，如果是你在开发兵线系统的时候，内存爆炸了，比如有的玩家搞怪，不杀小兵，积攒了很多小兵，然后他卡了，说你游戏垃圾。你该如何去做呢。</p><p>其实我们分析下来的话，这里只会出现三种不同的兵种，步兵、魔法兵、炮车。然后再分为红蓝两方。在加上两个子弹。是不是就只有这8个对象呢，至于他们的轨迹，那些是每个对象的**“外部状态”**</p><h2 id="如何构成" tabindex="-1"><a class="header-anchor" href="#如何构成"><span>如何构成</span></a></h2><p>知道了这种设计模式思路，就要继续了解一下享元模式具体的构成角色都有哪些了。比如以英雄联盟的兵线为例吧。</p><p><strong>客户端</strong></p><p>首先有一个客户端，负责获取对象，然后渲染，这里我们通过#get、#draw(x,y)来表示获取和画来代替这步动作，（x，y）表示渲染出来的对象坐标。</p><p><strong>享元工厂</strong></p><p>然后还有一个为我们提供小兵的统一接口，这里使用的就是我们前面学习的工厂方法，小兵工厂。这里顺便复习一下之前的工厂和抽象工厂两个设计模式。如果我通过一个工厂来实现小兵对象的创建，那么就是一个工厂模式，但是我现在想在应用的时候，在灵活一些，我们可以从小兵身上抽取特征，比如步兵、魔法兵、炮车、这是小兵类别，但我们有两个不同的作战方，红方和蓝方，所以此时可以使用抽象工厂模式来生产小兵，红方小兵工厂生产出来的都是红方的步兵、魔法兵、炮车。蓝方生产出来的就是蓝方的步兵、魔法兵、炮车。</p><p><strong>享元对象</strong></p><p>有了工厂之后，我们就要有具体的共享对象了，共享对象就是我们上面所说的那 8 个。</p><p>下面这个类图顺便复习了一下 <strong>抽象工厂模式</strong>。</p><figure><img src="https://i.loli.net/2020/11/12/dKDUbQ9sJRvFmTA.png" alt="flyweight-bingxian" tabindex="0" loading="lazy"><figcaption>flyweight-bingxian</figcaption></figure><h2 id="享元模式类图-📌" tabindex="-1"><a class="header-anchor" href="#享元模式类图-📌"><span>享元模式类图 📌</span></a></h2><figure><img src="https://i.loli.net/2020/11/12/YgS7J51GWuwZPBX.png" alt="flyweight.png" tabindex="0" loading="lazy"><figcaption>flyweight.png</figcaption></figure><h2 id="代码-📃" tabindex="-1"><a class="header-anchor" href="#代码-📃"><span>代码 📃</span></a></h2><p>下面就使用 <strong>享元模式</strong> 来模拟一下英雄联盟的兵线的开发。</p><figure><img src="https://i.loli.net/2020/11/12/stDkSmh83HpK1TV.png" alt="flyweight-coder.png" tabindex="0" loading="lazy"><figcaption>flyweight-coder.png</figcaption></figure><figure><img src="https://i.loli.net/2020/11/12/Yrh3FlIOuH5jREd.png" alt="flyweight-test.png" tabindex="0" loading="lazy"><figcaption>flyweight-test.png</figcaption></figure><blockquote><p>关注回复 “源码” 获取享元模式创建LOL兵线代码。</p></blockquote><h2 id="总结-📚" tabindex="-1"><a class="header-anchor" href="#总结-📚"><span>总结 📚</span></a></h2><ol><li>通过享元模式可以让我们用更小的空间来构造一个更大对象。这也是利用了池技术来实现的。</li><li>使用享元模式可以有效的缓解内存使用的问题。</li><li>你会发现，当你有外部状态的时候（具体体现在红蓝两方在创建小兵对象的时候，需要指定颜色），享元模式会变得稍显复杂。</li></ol>',42)]))}const l=i(p,[["render",g]]),o=JSON.parse('{"path":"/design/tbgr2htk/","title":"享元模式","lang":"zh-CN","frontmatter":{"title":"享元模式","createTime":"2025/08/27 23:15:36","permalink":"/design/tbgr2htk/"},"readingTime":{"minutes":5.51,"words":1654},"git":{"createdTime":1756736713000},"filePathRelative":"notes/design/享元模式.md","headers":[]}');export{l as comp,o as data};
