import{a as s,c as t,b as i,o as a}from"./app-ZQgO6-gU.js";const n={};function d(l,e){return a(),t("div",null,e[0]||(e[0]=[i(`<h3 id="_1、java-中-、equals-和-hashcode-的区别" tabindex="-1"><a class="header-anchor" href="#_1、java-中-、equals-和-hashcode-的区别"><span>1、Java 中 <code>==</code>、<code>equals</code> 和 <code>hashCode</code> 的区别</span></a></h3><ol><li><p><strong><code>==</code></strong></p><ul><li><p>基本数据类型：比较值是否相等。</p></li><li><p>引用类型（对象）：比较内存地址是否相等，即是否指向同一个对象。</p></li><li><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>int a = 5, b = 5;</span></span>
<span class="line"><span>System.out.println(a == b); // true</span></span>
<span class="line"><span></span></span>
<span class="line"><span>String s1 = new String(&quot;abc&quot;);</span></span>
<span class="line"><span>String s2 = new String(&quot;abc&quot;);</span></span>
<span class="line"><span>System.out.println(s1 == s2); // false</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong><code>equals()</code></strong></p><ul><li><p>定义在 <code>Object</code> 类中，默认比较对象内存地址（引用）。</p></li><li><p>子类可以重写，用于比较对象的内容是否相等。</p></li><li><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>String s1 = new String(&quot;abc&quot;);</span></span>
<span class="line"><span>String s2 = new String(&quot;abc&quot;);</span></span>
<span class="line"><span>System.out.println(s1.equals(s2)); // true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><strong><code>hashCode()</code></strong></p><ul><li>返回对象的哈希码，用于散列结构（如 <code>HashMap</code>、<code>HashSet</code>）中快速定位对象。</li><li>与 <code>equals()</code> 配合使用： <ul><li>如果两个对象相等 (<code>equals</code> 返回 true)，它们的 <code>hashCode</code> 必须相等。</li><li><code>hashCode</code> 相等，不一定 <code>equals</code> 相等。</li></ul></li></ul></li><li><p><strong><code>equals</code> 与 <code>==</code> 关系</strong></p><ul><li>对于 <code>Integer</code>、<code>Byte</code> 等包装类： <ul><li><code>-128~127</code> 范围内的值会缓存，<code>==</code> 比较的是值。</li><li>超出范围时，<code>==</code> 比较的是地址。</li></ul></li></ul></li></ol><hr><h3 id="_2、int、char、long-各占字节数" tabindex="-1"><a class="header-anchor" href="#_2、int、char、long-各占字节数"><span>2、<code>int</code>、<code>char</code>、<code>long</code> 各占字节数</span></a></h3><table><thead><tr><th>类型</th><th>占用字节数</th><th>默认值</th></tr></thead><tbody><tr><td>int</td><td>4</td><td>0</td></tr><tr><td>float</td><td>4</td><td>0.0f</td></tr><tr><td>short</td><td>2</td><td>0</td></tr><tr><td>char</td><td>2</td><td>&#39;\\u0000&#39;</td></tr><tr><td>long</td><td>8</td><td>0L</td></tr><tr><td>byte</td><td>1</td><td>0</td></tr><tr><td>boolean</td><td>1</td><td>false</td></tr></tbody></table><ul><li>基本数据类型存放在栈中。</li><li>包装类存放引用在栈中，值在堆中。</li></ul><hr><h3 id="_3、int-与-integer-的区别" tabindex="-1"><a class="header-anchor" href="#_3、int-与-integer-的区别"><span>3、<code>int</code> 与 <code>Integer</code> 的区别</span></a></h3><table><thead><tr><th>特性</th><th>int</th><th>Integer</th></tr></thead><tbody><tr><td>类型</td><td>基本数据类型</td><td>包装类（引用类型）</td></tr><tr><td>默认值</td><td>0</td><td>null</td></tr><tr><td>是否可实例化</td><td>不需要</td><td>需要</td></tr><tr><td>内存存储</td><td>栈中存储值</td><td>栈中存储引用，堆中存储值</td></tr></tbody></table><ul><li><p>自动装箱和拆箱：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>int a = 10;</span></span>
<span class="line"><span>Integer b = a; // 自动装箱</span></span>
<span class="line"><span>int c = b;     // 自动拆箱</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h3 id="_4、java-多态理解" tabindex="-1"><a class="header-anchor" href="#_4、java-多态理解"><span>4、Java 多态理解</span></a></h3><ul><li><p><strong>定义</strong>：同一个操作作用于不同对象，产生不同效果。</p></li><li><p><strong>条件</strong>：</p><ol><li>继承</li><li>方法重写（子类重写父类方法）</li><li>父类引用指向子类对象</li></ol></li><li><p><strong>作用</strong>：</p><ul><li>降低耦合，提高扩展性。</li></ul></li><li><p><strong>示例</strong>：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>class Animal {</span></span>
<span class="line"><span>    void sound() { System.out.println(&quot;Animal sound&quot;); }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>class Dog extends Animal {</span></span>
<span class="line"><span>    void sound() { System.out.println(&quot;Dog bark&quot;); }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Animal a = new Dog();</span></span>
<span class="line"><span>a.sound(); // Dog bark</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h3 id="_5、string、stringbuffer、stringbuilder-区别" tabindex="-1"><a class="header-anchor" href="#_5、string、stringbuffer、stringbuilder-区别"><span>5、<code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code> 区别</span></a></h3><table><thead><tr><th>类型</th><th>可变性</th><th>线程安全</th><th>使用场景</th></tr></thead><tbody><tr><td>String</td><td>不可变</td><td>是</td><td>少量字符串操作</td></tr><tr><td>StringBuffer</td><td>可变</td><td>是</td><td>多线程环境下的字符串操作</td></tr><tr><td>StringBuilder</td><td>可变</td><td>否</td><td>单线程环境下字符串操作，效率高</td></tr></tbody></table><hr><h3 id="_6、内部类及作用" tabindex="-1"><a class="header-anchor" href="#_6、内部类及作用"><span>6、内部类及作用</span></a></h3><ul><li><strong>定义</strong>：在类内部定义的类。</li><li><strong>作用</strong>： <ol><li>实现多重继承效果</li><li>隐藏实现细节，提高封装性</li><li>减少字节码文件大小</li></ol></li><li><strong>类型</strong>： <ol><li><strong>成员内部类</strong>：非 static，持有外部类引用</li><li><strong>静态内部类</strong>：static，不持有外部类引用</li><li><strong>匿名内部类</strong>：无类名，用于一次性实现接口/抽象类</li><li><strong>局部内部类</strong>：方法或代码块中定义，仅在局部可见</li></ol></li></ul><hr><h3 id="_7、抽象类与接口区别" tabindex="-1"><a class="header-anchor" href="#_7、抽象类与接口区别"><span>7、抽象类与接口区别</span></a></h3><table><thead><tr><th>特性</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>方法</td><td>可有抽象方法和普通方法</td><td>默认抽象方法（Java 8 后可有 default 方法）</td></tr><tr><td>成员变量</td><td>可有任意类型</td><td>public static final</td></tr><tr><td>继承</td><td>单继承</td><td>多实现</td></tr><tr><td>静态方法/块</td><td>可以</td><td>接口静态方法可以，块不可</td></tr><tr><td>主要作用</td><td>提供子类通用模板</td><td>规范方法实现、解耦</td></tr></tbody></table><ul><li><strong>应用场景</strong>： <ul><li>抽象类：有通用方法，需要模板功能</li><li>接口：定义规则或规范，解耦和可扩展性</li></ul></li></ul><hr><h3 id="_8、泛型中-extends-和-super-的区别" tabindex="-1"><a class="header-anchor" href="#_8、泛型中-extends-和-super-的区别"><span>8、泛型中 <code>extends</code> 和 <code>super</code> 的区别</span></a></h3><ul><li><code>&lt;? extends T&gt;</code>：上界通配符，读取安全，写入不安全。</li><li><code>&lt;? super T&gt;</code>：下界通配符，写入安全，读取返回 Object 类型。</li></ul><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>List&lt;? extends Number&gt; list1 = new ArrayList&lt;Integer&gt;();</span></span>
<span class="line"><span>Number n = list1.get(0); // 允许读取</span></span>
<span class="line"><span>// list1.add(10);</span><span> // 不允许</span></span>
<span class="line"><span></span></span>
<span class="line"><span>List&lt;? super Integer&gt; list2 = new ArrayList&lt;Number&gt;();</span></span>
<span class="line"><span>list2.add(10); // 允许写入</span></span>
<span class="line"><span>Object o = list2.get(0); // 读取返回 Object</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_9、父类的静态方法能否被子类重写-静态属性和静态方法继承性" tabindex="-1"><a class="header-anchor" href="#_9、父类的静态方法能否被子类重写-静态属性和静态方法继承性"><span>9、父类的静态方法能否被子类重写？静态属性和静态方法继承性</span></a></h3><ul><li><strong>静态方法</strong>：不能重写，只能隐藏（方法名相同，调用时依赖引用类型）。</li><li><strong>静态属性/方法</strong>：可以被子类继承。</li></ul><p>示例：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>class Parent {</span></span>
<span class="line"><span>    static void staticMethod() { System.out.println(&quot;Parent&quot;); }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>class Child extends Parent {</span></span>
<span class="line"><span>    static void staticMethod() { System.out.println(&quot;Child&quot;); }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>Parent p = new Child();</span></span>
<span class="line"><span>p.staticMethod(); // Parent</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_10、进程与线程区别" tabindex="-1"><a class="header-anchor" href="#_10、进程与线程区别"><span>10、进程与线程区别</span></a></h3><table><thead><tr><th>特性</th><th>进程</th><th>线程</th></tr></thead><tbody><tr><td>定义</td><td>程序的执行实例</td><td>进程的执行单元</td></tr><tr><td>内存</td><td>独立内存空间</td><td>共享进程内存空间</td></tr><tr><td>创建</td><td>开销大</td><td>开销小</td></tr><tr><td>调度</td><td>系统调度</td><td>线程调度</td></tr></tbody></table><hr><h3 id="_11、final、finally、finalize-区别" tabindex="-1"><a class="header-anchor" href="#_11、final、finally、finalize-区别"><span>11、<code>final</code>、<code>finally</code>、<code>finalize</code> 区别</span></a></h3><table><thead><tr><th>关键字/方法</th><th>作用</th></tr></thead><tbody><tr><td>final</td><td>修饰类、方法、变量，表示不可变或不可继承</td></tr><tr><td>finally</td><td>异常处理块，保证代码执行</td></tr><tr><td>finalize()</td><td>Object 类方法，对象被垃圾回收前调用</td></tr></tbody></table><hr><h3 id="_12、serializable-与-parcelable-区别" tabindex="-1"><a class="header-anchor" href="#_12、serializable-与-parcelable-区别"><span>12、<code>Serializable</code> 与 <code>Parcelable</code> 区别</span></a></h3><table><thead><tr><th>特性</th><th>Serializable</th><th>Parcelable</th></tr></thead><tbody><tr><td>速度</td><td>慢</td><td>快</td></tr><tr><td>可扩展性</td><td>可继承</td><td>Android 特有，需要实现接口</td></tr><tr><td>使用场景</td><td>Java 对象序列化</td><td>Android Intent/Bundle传递</td></tr></tbody></table><hr><h3 id="_13、对-kotlin-的理解" tabindex="-1"><a class="header-anchor" href="#_13、对-kotlin-的理解"><span>13、对 Kotlin 的理解</span></a></h3><ul><li>Kotlin 是一种现代 JVM 语言，兼容 Java。</li><li>特点： <ol><li>空安全（<code>null</code> 安全）</li><li>数据类（Data class）减少模板代码</li><li>函数式编程支持</li><li>协程支持高效异步编程</li></ol></li></ul><hr><h3 id="_14、string-转-integer-的方式及原理" tabindex="-1"><a class="header-anchor" href="#_14、string-转-integer-的方式及原理"><span>14、<code>String</code> 转 <code>Integer</code> 的方式及原理</span></a></h3><ol><li><p><strong><code>Integer.parseInt(String s)</code></strong></p><ul><li>转换为基本类型 <code>int</code>，若非数字抛 <code>NumberFormatException</code>。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>int i = Integer.parseInt(&quot;123&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong><code>Integer.valueOf(String s)</code></strong></p><ul><li>返回 <code>Integer</code> 对象，-128~127 会缓存（常用小整数优化）。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>Integer i = Integer.valueOf(&quot;123&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><p><strong><code>new Integer(String s)</code></strong></p><ul><li>直接创建新对象，不使用缓存。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span>Integer i = new Integer(&quot;123&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ol><p><strong>原理</strong>：</p><ul><li><code>parseInt</code> 使用字符转数字算法逐位计算。</li><li><code>valueOf</code> 内部调用 <code>parseInt</code>，然后返回缓存或新对象。</li><li><code>new Integer</code> 每次都创建新对象。</li></ul>`,50)]))}const c=s(n,[["render",d]]),o=JSON.parse('{"path":"/bigcompany/vig44zrj/","title":"中软国际-Java初级","lang":"zh-CN","frontmatter":{"title":"中软国际-Java初级","createTime":"2025/08/21 13:55:01","permalink":"/bigcompany/vig44zrj/"},"readingTime":{"minutes":4.5,"words":1350},"git":{"createdTime":1756736713000},"filePathRelative":"notes/bigcompany/company/中软国际-Java初级.md","headers":[]}');export{c as comp,o as data};
