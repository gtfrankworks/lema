import{a as s,c as i,b as n,o as a}from"./app-ZQgO6-gU.js";const l={};function d(r,e){return a(),i("div",null,e[0]||(e[0]=[n(`<h2 id="什么是-redis-哨兵模式" tabindex="-1"><a class="header-anchor" href="#什么是-redis-哨兵模式"><span>什么是 Redis 哨兵模式？</span></a></h2><p>Redis 哨兵（Sentinel）是 Redis 官方推荐的高可用性解决方案。它是一个独立的进程，用于监控一个或多个 Redis 主从复制架构，并在主节点发生故障时自动执行故障转移（failover）。</p><ul><li><strong>主节点：</strong> 负责所有读写操作。</li><li><strong>从节点：</strong> 只负责复制主节点的数据，处理读操作。</li><li><strong>哨兵实例：</strong> 监控主从节点，并在主节点下线时自动将一个从节点提升为新的主节点。</li></ul><p>一个标准的 Redis Sentinel 架构由一个主节点、多个从节点和多个哨兵实例组成。</p><p><strong>哨兵模式的核心作用是实现自动故障转移。</strong> 当主节点下线时，哨兵会自动将从节点提升为主节点，从而保证服务的高可用性，无需人工干预。</p><h2 id="哨兵模式的工作原理" tabindex="-1"><a class="header-anchor" href="#哨兵模式的工作原理"><span>哨兵模式的工作原理</span></a></h2><p>哨兵模式的工作原理可以分为三个阶段：监控、故障发现和故障转移。</p><h3 id="_1-监控-monitoring" tabindex="-1"><a class="header-anchor" href="#_1-监控-monitoring"><span>1. 监控（Monitoring）</span></a></h3><p>每个哨兵实例都会持续监控主节点和从节点。</p><ul><li><strong>主观下线（Subjectively Down）</strong>：当一个哨兵实例在指定的时间内（<code>down-after-milliseconds</code>）没有收到主节点或从节点的有效响应时，它会认为该节点“主观下线”。这只是该哨兵自己的判断。</li><li><strong>客观下线（Objectively Down）</strong>：当足够多的哨兵实例（<code>quorum</code> 参数指定的数量）都认为主节点主观下线时，它们会共同达成一个共识，认为主节点“客观下线”。只有当主节点被判断为客观下线后，才会触发故障转移流程。</li></ul><h3 id="_2-故障发现-failure-detection" tabindex="-1"><a class="header-anchor" href="#_2-故障发现-failure-detection"><span>2. 故障发现（Failure Detection）</span></a></h3><p>一旦主节点被判定为客观下线，哨兵实例之间会进行协商，选举出一个<strong>领导者哨兵（Leader Sentinel）</strong>。这个领导者哨兵将负责执行后续的故障转移。</p><h3 id="_3-故障转移-failover" tabindex="-1"><a class="header-anchor" href="#_3-故障转移-failover"><span>3. 故障转移（Failover）</span></a></h3><p>被选举为领导者的哨兵会执行以下步骤：</p><ol><li><strong>选举新主节点</strong>：从所有下线的从节点中，选择一个最优的从节点，将其提升为新的主节点。选择的依据通常包括：优先级（<code>replica-priority</code>）、复制偏移量（offset）等。</li><li><strong>执行 <code>REPLICAOF NO ONE</code></strong>：领导者哨兵向选出的从节点发送 <code>REPLICAOF NO ONE</code> 命令，使其停止复制，并晋升为新的主节点。</li><li><strong>重新配置其他从节点</strong>：领导者哨兵向所有其他从节点发送 <code>REPLICAOF</code> 命令，让它们开始复制新的主节点。</li><li><strong>配置旧主节点</strong>：如果旧的主节点重新上线，领导者哨兵会将其配置为新主节点的从节点，让其继续工作。</li></ol><h2 id="哨兵模式的配置" tabindex="-1"><a class="header-anchor" href="#哨兵模式的配置"><span>哨兵模式的配置</span></a></h2><p>配置哨兵模式相对简单，通常需要配置一个或多个哨兵实例。</p><h3 id="_1-启动主从复制架构" tabindex="-1"><a class="header-anchor" href="#_1-启动主从复制架构"><span>1. 启动主从复制架构</span></a></h3><p>首先，需要像之前的文档中一样，启动一个主节点和至少一个从节点。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># 启动主节点（6379端口）</span></span>
<span class="line"><span>redis-server /path/to/master/redis.conf</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 启动从节点（6380端口）</span></span>
<span class="line"><span>redis-server /path/to/replica/redis.conf --replicaof 127.0.0.1 6379</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-配置哨兵实例" tabindex="-1"><a class="header-anchor" href="#_2-配置哨兵实例"><span>2. 配置哨兵实例</span></a></h3><p>创建一个 <code>sentinel.conf</code> 文件，并添加以下配置：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># 监控一个名为 &#39;mymaster&#39; 的主节点，其 IP 和端口为 127.0.0.1:6379</span></span>
<span class="line"><span># 2 表示至少需要 2 个哨兵实例认为主节点下线，才会触发故障转移。</span></span>
<span class="line"><span>sentinel monitor mymaster 127.0.0.1 6379 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定哨兵实例在多长时间内没有收到主节点的响应，就认为其主观下线，单位为毫秒</span></span>
<span class="line"><span>sentinel down-after-milliseconds mymaster 5000</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 故障转移的超时时间</span></span>
<span class="line"><span>sentinel failover-timeout mymaster 60000</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 从节点晋升为新主节点的优先级。数字越小优先级越高，0表示不会被提升</span></span>
<span class="line"><span># sentinel replica-priority mymaster 100</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-启动哨兵实例" tabindex="-1"><a class="header-anchor" href="#_3-启动哨兵实例"><span>3. 启动哨兵实例</span></a></h3><p>使用 <code>sentinel.conf</code> 文件来启动哨兵实例。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-"><span class="line"><span># 在不同的服务器上启动至少 3 个哨兵实例，以保证高可用性</span></span>
<span class="line"><span>redis-sentinel /path/to/sentinel/sentinel.conf</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="案例说明-自动故障转移" tabindex="-1"><a class="header-anchor" href="#案例说明-自动故障转移"><span>案例说明：自动故障转移</span></a></h2><h3 id="场景描述" tabindex="-1"><a class="header-anchor" href="#场景描述"><span>场景描述</span></a></h3><p>你有一个 Redis 主从架构，由一个主节点（<code>127.0.0.1:6379</code>）和一个从节点（<code>127.0.0.1:6380</code>）组成。为了防止主节点宕机导致服务中断，你部署了三个哨兵实例来监控它们。</p><h3 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h3><p>当主节点意外宕机时，哨兵模式会自动执行故障转移，将从节点晋升为主节点，从而确保服务持续可用。</p><p><strong>详细操作步骤和命令：</strong></p><ol><li><strong>初始状态：</strong><ul><li>启动主节点：<code>redis-server --port 6379</code></li><li>启动从节点：<code>redis-server --port 6380 --replicaof 127.0.0.1 6379</code></li><li>启动三个哨兵实例，使用 <code>sentinel.conf</code> 配置文件，其中 <code>quorum</code> 为 <code>2</code>。</li><li><strong>验证：</strong></li><li><code>redis-cli -p 26379</code></li><li><code>127.0.0.1:26379&gt; sentinel master mymaster</code></li><li><code>...role:master...</code></li></ul></li><li><strong>模拟主节点宕机：</strong><ul><li>强制关闭主节点进程（端口 <code>6379</code>）。</li><li><code>killall redis-server</code> （如果你只有一个 Redis 实例）</li><li>或者 <code>kill -9 &lt;pid_of_master&gt;</code></li></ul></li><li><strong>哨兵自动故障转移：</strong><ul><li>哨兵实例会立即检测到主节点下线。当两个哨兵都判定主节点主观下线后，会触发故障转移。</li><li>哨兵会选举出领导者，并自动将从节点（<code>127.0.0.1:6380</code>）提升为新的主节点。</li><li><strong>验证：</strong></li><li>几秒后，再次连接到新的主节点。</li><li><code>redis-cli -p 6380</code></li><li><code>127.0.0.1:6380&gt; INFO replication</code></li><li><code># Replication...role:master</code></li><li>此时，旧的主节点（<code>6379</code>）已经下线，而 <code>6380</code> 端口的从节点已经接替了它的角色，并继续提供服务。</li></ul></li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>Redis 哨兵模式是构建高可用 Redis 系统的基石。它通过自动监控、故障发现和故障转移机制，极大地提升了 Redis 服务的健壮性和可靠性，特别是在主节点发生意外故障时，可以最大限度地减少服务中断时间。</p><p>它解决了手动故障转移的痛点，是生产环境中 Redis 主从复制的必备伴侣。</p>`,36)]))}const c=s(l,[["render",d]]),t=JSON.parse('{"path":"/nosqldb/uw7wxsph/","title":"Redis哨兵模式","lang":"zh-CN","frontmatter":{"title":"Redis哨兵模式","createTime":"2025/08/26 13:32:39","permalink":"/nosqldb/uw7wxsph/"},"readingTime":{"minutes":4.92,"words":1476},"git":{"createdTime":1756736713000},"filePathRelative":"notes/nosqldb/redises/Redis哨兵模式.md","headers":[]}');export{c as comp,t as data};
