import{a as s,c as a,b as n,o as e}from"./app-ZQgO6-gU.js";const p={};function l(t,i){return e(),a("div",null,i[0]||(i[0]=[n(`<figure><img src="https://i.loli.net/2020/10/29/YIpkj5QDBHb7ytN.png" alt="timg" tabindex="0" loading="lazy"><figcaption>timg</figcaption></figure><h1 id="科普闲聊" tabindex="-1"><a class="header-anchor" href="#科普闲聊"><span>科普闲聊</span></a></h1><blockquote><p>复杂度守恒定律由Larry Tesler于1984年提出，也称泰斯勒定律（Tesler&#39;s Law）。复杂度守恒定律（Law of conservation of complexity）由Larry Tesler于1984年提出，也称泰斯勒定律（Tesler&#39;s Law）。 根据复杂度守恒定律，每个应用程序都具有其内在的、无法简化的复杂度。无论在产品开发环节还是在用户与产品的交互环节，这一固有的复杂度都无法依照我们的意愿去除，只能设法调整、平衡。</p></blockquote><p>这一观点主要被应用在交互设计领域。我们不得不面对的问题是，该由谁来为这一固有的复杂度埋单。打个比方，应该由软件开发工程师花费额外的时间来使软件变得更加简单好用，还是应该让用户自己去解决软件使用中可能存在的问题？</p><p>以上出自百度百科：<a href="https://baike.baidu.com/item/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%88%E6%81%92%E5%AE%9A%E5%BE%8B/7508660?fr=aladdin" target="_blank" rel="noopener noreferrer">复杂度守恒定律 - 百度百科</a></p><hr><p>如上所述，复杂度守恒定律是一个规避不掉的东西，最早的时候我接触到这个词是发出的一个提问，当时有各种大佬出来解答，大家感兴趣可以去看看。</p><p><a href="https://bbs.csdn.net/topics/392308895" target="_blank" rel="noopener noreferrer">到底什么是RPC?远程调用有什么好处?</a></p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-text"><span class="line"><span>迷惑不解,不知是何.</span></span>
<span class="line"><span>我了解了一下dubbo框架,很多的术语搞得是更加模糊不清.</span></span>
<span class="line"><span>顺便提一点,</span></span>
<span class="line"><span>为什么深奥的东西就是被人向往的?</span></span>
<span class="line"><span>将复杂的东西弄成粗浅易懂的这不是更好吗?</span></span>
<span class="line"><span></span></span>
<span class="line"><span>2018-01-15 09:04:03</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但我一直以为，技术的东西，本就不复杂。让它变得复杂的是我那迫切想要得到结果的心。</p><p>学习从来都没有捷径，你只是想要速成。学的快慢是一个问题，学与不学是另一个问题，听懂掌声。</p><hr><h1 id="学习时间" tabindex="-1"><a class="header-anchor" href="#学习时间"><span>学习时间</span></a></h1><h2 id="_2020年10月的某一天午饭后" tabindex="-1"><a class="header-anchor" href="#_2020年10月的某一天午饭后"><span>2020年10月的某一天午饭后</span></a></h2><p>“桥接模式？，那是个啥” 心中突然蹦出这么一个想法。我心血来潮，打开 Google ，输入 <code>桥接模式</code> ，回车走你，等了半天。</p><figure><img src="https://i.loli.net/2020/10/26/dJ7BuUjW9RcpQiE.png" alt="google-error.png" tabindex="0" loading="lazy"><figcaption>google-error.png</figcaption></figure><p>这丝毫没有影响到我的情绪~~（艹）~~，随即我快速的切换搜索引擎视图忘掉刚刚发生的这一切。又是一记回车敲出，这次，它出现了</p><figure><img src="https://i.loli.net/2020/10/26/uZGN4z3ckbvI72T.png" alt="baidu-bridge.png" tabindex="0" loading="lazy"><figcaption>baidu-bridge.png</figcaption></figure><p>不知道是我手不行了，还是键盘要坏了，总之模式两字没带上，出来个桥梁，想着都差不多（呸，差不多个鬼）就看看吧，顺便学习了一下桥梁的专业释义（我就是这样东西越看越多，越看越杂的！龇牙咧嘴中！）。</p><p>不行，得回过神来，继续找<code>桥梁模式</code>去。这怎么都一样啊，<strong>抽象化</strong>、<strong>实现化</strong>、<strong>脱耦</strong>看不懂啊，然后就是那个到处都是，其实出自菜鸟教程的图形案例。</p><figure><img src="https://i.loli.net/2020/10/26/vcIRdKGbMN4teTD.png" alt="runoob-bridge.png" tabindex="0" loading="lazy"><figcaption>runoob-bridge.png</figcaption></figure><blockquote><p>图片来源：https://www.runoob.com/w3cnote/bridge-pattern2.html</p></blockquote><p>先看看问题吧，一个图形有2种形状（圆形、矩形）和2种颜色（红色、蓝色）的时候怎么去用类表示，我啥也不说，那肯定继承啊，我这 <strong>封装、继承、多态老扎实了</strong>。</p><p>心里念着”首先有一个<strong>图形</strong>的基类，然后开始继承走起 <strong>红色的圆形</strong>、 <strong>红色的矩形</strong>、 <strong>蓝色的圆形</strong>、<strong>蓝色的矩形</strong>。“ 没毛病，一个抽象类，四个实现类，搞定。</p><figure><img src="https://i.loli.net/2020/10/28/qcKwM42eOFBg6Vu.png" alt="bridge.png" tabindex="0" loading="lazy"><figcaption>bridge.png</figcaption></figure><p>代码写完，测一手。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    @</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Test</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> shape</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(){</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        Shape</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> blueCircle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> BlueCircle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        Shape</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> blueRectangle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> BlueRectangle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        Shape</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> redCircle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> RedCircle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">        Shape</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> redRectangle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> RedRectangle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        blueCircle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">create</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        blueRectangle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">create</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        redCircle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">create</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        redRectangle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">create</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-restructuredtext line-numbers-mode" data-highlighter="shiki" data-ext="restructuredtext" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code class="language-restructuredtext"><span class="line"><span>蓝色の圆形</span></span>
<span class="line"><span>蓝色の长方形</span></span>
<span class="line"><span>红色の圆形</span></span>
<span class="line"><span>红色の长方形</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>感觉还可以，这时坐在我边上的大哥说了句，如果再加一种形状呢？</p><p>我：“卧槽，你啥时候来的，想要偷窥我学习？”</p><p>大哥：“先回答问题，别转移话题”</p><p>我：“再加两个类不就行了”， <strong>RedTriangle</strong>、<strong>BlueTriangle</strong>，</p><p>大哥：“也还行，如果再这基础上再加一种绿颜色呢？”</p><p>我：“额。。。再加三个类 <strong>GreenCircle</strong>、 <strong>GreenRectangle</strong>、<strong>GreenTriangle</strong>。。。（开始声音微弱）”</p><p>大哥：“再加一个椭圆呢”</p><p>“emm... 我刀呢！”</p><p>“老弟别激动，大哥帮你看看”</p><h2 id="大哥帮忙诊断代码" tabindex="-1"><a class="header-anchor" href="#大哥帮忙诊断代码"><span>大哥帮忙诊断代码</span></a></h2><p>大哥：“你这个是 <strong>乱用继承</strong> 导致的类爆炸晚期啊，要是不拔除对这种继承的理解，基本是废了啊”</p><p>我：“大哥我还不想放弃，救救我，咳...咳（一口老血咳出）”</p><p>大哥：“那你说说看，你都是什么时候用的继承？”</p><p>我：“多个类有共同特征的时候，会抽象出来特征，然后使用继承来扩展”</p><p>大哥：“嗯，看来你还有救，那你看你现在抽象出来的东西对吗？”</p><p>我小声嘀咕：“很多图形，抽象出来个图形，没问题啊”</p><p>大哥：“那颜色呢？颜色和图形是什么关系？”</p><p>我：“emm....，什么什么关系啊？大哥，给点提示吧&quot;</p><p>大哥：“UML中的聚合组合我没教你么？”</p><p>我：“这个真没有”</p><p>大哥：“那这个地方我再教你一次，记着点奥。咳咳！”</p><figure><img src="https://i.loli.net/2020/10/27/RQfH3ho9Zg7TJmG.png" alt="uml" tabindex="0" loading="lazy"><figcaption>uml</figcaption></figure><p>大哥：“这个就是组合和聚合的意思，同时他们与主体之间的关联关系的表达。”</p><p>大哥：“现在在看你的 <strong>类爆炸</strong> 知道怎么医治了么？”</p><p>我：“我应该把颜色也抽象出来，然后使用聚合与图形进行关联！对不对！”</p><p>大哥：“还不赖嘛，你继续看吧，我忙我的去了”</p><h2 id="重构代码" tabindex="-1"><a class="header-anchor" href="#重构代码"><span>重构代码</span></a></h2><p>领悟了大哥的意思之后，我对代码进行了重构。</p><p>仍然将图形类抽象出来，同时将颜色作为一个接口引入，因为图形的形状和颜色本来就是两个不同的维度，所以它现在的类图应该是这个样子的。</p><figure><img src="https://i.loli.net/2020/10/27/DUeGhk2pIcoKdwW.png" alt="bridge1.png" tabindex="0" loading="lazy"><figcaption>bridge1.png</figcaption></figure><p>有了类图，很快我就重构好了代码，测试一下。</p><blockquote><p>完整代码关注公众号回复：“源码” 获取</p></blockquote><figure><img src="https://i.loli.net/2020/10/27/EPTuQae6DofyFSG.png" alt="bridge-test.png" tabindex="0" loading="lazy"><figcaption>bridge-test.png</figcaption></figure><p>当我要新增一种图形或者一个颜色时，只需要增加一个类就可以了。真香。</p><h1 id="bridge-桥梁-接-模式" tabindex="-1"><a class="header-anchor" href="#bridge-桥梁-接-模式"><span>bridge 桥梁（接）模式</span></a></h1><blockquote><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p></blockquote><h2 id="把这绕口的东西看清楚" tabindex="-1"><a class="header-anchor" href="#把这绕口的东西看清楚"><span>把这绕口的东西看清楚</span></a></h2><p>将抽象部分与它的实现部分分离，使他们都可以独立地变化。这句话我不知道别人能不能读的懂，就我而言，刚看到这句话实在是没有搞清楚在表达什么，我猜想其中的原因，一个是因为设计模式是搞建筑的人提出来了，另一个原因是老外写的软件设计模式。翻译成中文为了达到统一的标准，所以很多知识变得晦涩难懂。</p><p><em>这里在顺带提一下所谓的统一的标准，就像开放平台的接口一样。他为了有更好的扩展性，定义了统一的对外接口，以后无论哪方想要对接，都需要适应我的标准，而不是给每个人都定制化一个接口。所以知识的传播也一样，要以一定的官方标准来定义和传播，不然可能传着传着就出现了歧义。这也就是复杂度守恒定律的根本，它本身其实真的并不复杂。以上个人见解，可以无视。</em></p><h2 id="在看抽象化、实现化、脱。脱。脱你妹啊脱-解耦。" tabindex="-1"><a class="header-anchor" href="#在看抽象化、实现化、脱。脱。脱你妹啊脱-解耦。"><span>在看抽象化、实现化、脱。脱。脱你妹啊脱，解耦。</span></a></h2><p>因为之前有大哥的帮忙，所以很容易就理解了<code>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</code>这句话。</p><p>就拿我刚刚学的图形的那个案例。</p><ul><li>抽象部分就是图形的形状+颜色，图形它一定是有形状和颜色的。存在自身上的两个不同的维度变化</li><li>实现部分就是具体的形状和颜色。形状和颜色一定有具体的体现。要么圆形红色，要么方形透明。而形状又是图形本身的一部分，所以可以跟在主体后通过继承进行变化。颜色可以独立出去进行单独的扩展。</li></ul><p>独立的变化就是讲到抽象部分和实现部分的两个实现</p><ul><li>抽象部分的一个变化就是通过一个矩形类继承图形抽象类。同时完善一个构造函数，这是对抽象部分的矫正或者完备。</li><li>实现部分的变化遵循了<strong>里式替换</strong>与抽象部分的关联又根据<strong>依赖倒置</strong>原则设计。所以实现部分可以在自己的接口定义范畴能进行自由变化，同时又可以与抽象部分进行关联**（桥接）**</li></ul><p>我试着把晦涩的东西简化一下</p><p><strong>一个对象的多个维度状态独立变化时，将其通过类组合的方式进行关联，使其每个维度自由变化，降低与主体的耦合。</strong></p><h2 id="桥接模式类图-📌" tabindex="-1"><a class="header-anchor" href="#桥接模式类图-📌"><span>桥接模式类图 📌</span></a></h2><figure><img src="https://i.loli.net/2020/10/27/eQgjH6wkB2pSLfO.png" alt="bridge2.png" tabindex="0" loading="lazy"><figcaption>bridge2.png</figcaption></figure><h2 id="代码-📄" tabindex="-1"><a class="header-anchor" href="#代码-📄"><span>代码 📄</span></a></h2><blockquote><p>完整代码关注公众号回复：“源码” 获取</p></blockquote><figure><img src="https://i.loli.net/2020/10/27/iXWcetHJUxyBFNT.png" alt="bridge-code.png" tabindex="0" loading="lazy"><figcaption>bridge-code.png</figcaption></figure><h2 id="总结-🐱‍💻" tabindex="-1"><a class="header-anchor" href="#总结-🐱‍💻"><span>总结 🐱‍💻</span></a></h2><p>哎呀，这个桥接模式我是万万没想到它会是这个样子。同样又是学完不知道在哪用的一种模式，但这就是我放弃学习的理由？那可真是太可笑了。</p><ul><li>当一个对象内存在多个维度多种状态时，可以使用桥接模式解耦，以防新增维度状态时导致 <strong>类爆炸</strong></li><li>维度的体现可以延迟到使用阶段，比如上述例子，颜色被分离出去，当需要具体对象时，在通过 set 方法对维度赋值（回复源码，获取全部源码和文章原稿）</li></ul><p>桥接模式的好处大家都看在眼里，记在心里。用了桥接模式首先解决的就是因为乱用继承导致的类爆炸问题，同时无论之后怎么扩展类，都只需要在对应维度维护新的实现就可以了，降低了对象间的耦合。</p><p>不好的地方，整个设计模式的缺点全都包含这一条： <strong>增加了系统的复杂性，对系统设计的理解多了一层内容。维护的类变多了。</strong> 这更能体现出一劳永逸的感觉，先吃苦，后舒坦。其实对于桥接模式还有一点，就是需要你能正确的去划分出一个对象的多维度状态，不然又成了“手里拿个锤子，看什么都像钉子”的感觉了。</p><h1 id="打工人的早高峰" tabindex="-1"><a class="header-anchor" href="#打工人的早高峰"><span>打工人的早高峰</span></a></h1><p>今天的公交车一点都不挤！就是下车的时候鸡蛋不知道咋回事碎了！还好是鸡蛋碎了，听懂掌声。</p>`,87)]))}const h=s(p,[["render",l]]),d=JSON.parse('{"path":"/design/xkjkugqg/","title":"桥连接模式","lang":"zh-CN","frontmatter":{"title":"桥连接模式","createTime":"2025/08/27 23:12:09","permalink":"/design/xkjkugqg/"},"readingTime":{"minutes":9.2,"words":2761},"git":{"createdTime":1756736713000},"filePathRelative":"notes/design/桥连接模式.md","headers":[]}');export{h as comp,d as data};
